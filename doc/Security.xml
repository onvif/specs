<?xml version="1.0"?>
<?xml-stylesheet href="docbook.xsl" type="text/xsl" ?>
<book xmlns="http://docbook.org/ns/docbook" version="5.0">
  <info>
    <title>Advanced Security Service Specification</title>
    <titleabbrev>Security Configuration</titleabbrev>
    <releaseinfo>21.12</releaseinfo>
    <author>
      <orgname>ONVIF™</orgname>
      <uri>www.onvif.org</uri>
    </author>
    <pubdate>December 2021</pubdate>
    <mediaobject>
      <imageobject>
        <imagedata fileref="media/logo.png" contentwidth="60mm"/>
      </imageobject>
    </mediaobject>
    <copyright>
      <year>2008-2020</year>
      <holder>ONVIF™ All rights reserved.</holder>
    </copyright>
    <legalnotice>
      <para>Recipients of this document may copy, distribute, publish, or display this document so long as this copyright notice, license and disclaimer are retained with all copies of the document. No license is granted to modify this document.</para>
      <para>THIS DOCUMENT IS PROVIDED "AS IS," AND THE CORPORATION AND ITS MEMBERS AND THEIR AFFILIATES, MAKE NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, OR TITLE; THAT THE CONTENTS OF THIS DOCUMENT ARE SUITABLE FOR ANY PURPOSE; OR THAT THE IMPLEMENTATION OF SUCH CONTENTS WILL NOT INFRINGE ANY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS.</para>
      <para>IN NO EVENT WILL THE CORPORATION OR ITS MEMBERS OR THEIR AFFILIATES BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE OR CONSEQUENTIAL DAMAGES, ARISING OUT OF OR RELATING TO ANY USE OR DISTRIBUTION OF THIS DOCUMENT, WHETHER OR NOT (1) THE CORPORATION, MEMBERS OR THEIR AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES, OR (2) SUCH DAMAGES WERE REASONABLY FORESEEABLE, AND ARISING OUT OF OR RELATING TO ANY USE OR DISTRIBUTION OF THIS DOCUMENT.  THE FOREGOING DISCLAIMER AND LIMITATION ON LIABILITY DO NOT APPLY TO, INVALIDATE, OR LIMIT REPRESENTATIONS AND WARRANTIES MADE BY THE MEMBERS AND THEIR RESPECTIVE AFFILIATES TO THE CORPORATION AND OTHER MEMBERS IN CERTAIN WRITTEN POLICIES OF THE CORPORATION.</para>
    </legalnotice>
    <revhistory>
      <revision>
        <revnumber>1.0</revnumber>
        <date>Aug - 2013</date>
        <author>
          <personname>Dirk Stegemann</personname>
        </author>
        <revremark>Initial version</revremark>
      </revision>
      <revision>
        <revnumber>1.0.1</revnumber>
        <date>Dec - 2013</date>
        <author>
          <personname>Michio Hirai, </personname>
        </author>
        <author>
          <personname>Dirk Stegemann</personname>
        </author>
        <revremark>Change Request 1219, 1220
1222, 1267, 1271, 1272, 1277</revremark>
      </revision>
      <revision>
        <revnumber>1.0.2</revnumber>
        <date>June - 2014</date>
        <author>
          <personname>Dirk Stegemann, Stefan Andersson</personname>
        </author>
        <revremark>Change Request 1268, 1276, 1349, 1350, 1351, 1352, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1390</revremark>
      </revision>
      <revision>
        <revnumber>1.1</revnumber>
        <date>Dec - 2014</date>
        <author>
          <personname>Dirk Stegemann</personname>
        </author>
        <revremark>Change Request 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1543, 1554</revremark>
      </revision>
      <revision>
        <revnumber>1.2</revnumber>
        <date>Jun - 2015</date>
        <author>
          <personname>Dirk Stegemann</personname>
        </author>
        <revremark>Change Request 1552, 1555, 1565, 1580, 1583, 1590, 1615, 1616, 1617, 1618, 1619
Added certificate-based client authentication</revremark>
      </revision>
      <revision>
        <revnumber>1.3</revnumber>
        <date>Feb-2016</date>
        <author>
          <personname>Stefan Andersson Steve Wolf</personname>
        </author>
        <revremark>Added IEEE 802.1X configuration</revremark>
      </revision>
      <revision>
        <revnumber>
        </revnumber>
        <date>Mar-2017</date>
        <author>
          <personname>Hans Busch</personname>
        </author>
        <revremark>Change Request 1843</revremark>
      </revision>
      <revision>
        <revnumber>18.06</revnumber>
        <date>Jun-2018</date>
        <author>
          <personname>Hiroyuki Sano</personname>
        </author>
        <revremark>Change Request 2240, 2259</revremark>
      </revision>
      <revision>
        <revnumber>18.12</revnumber>
        <date>Dec-2018</date>
        <author>
          <personname>Steve Wolf</personname>
        </author>
        <revremark>Change Request 2262, 2308</revremark>
      </revision>
      <revision>
        <revnumber>19.12</revnumber>
        <date>Dec-2019</date>
        <author>
          <personname>Davide Cristanelli</personname>
        </author>
        <revremark>Added Authorization of TLS authenticated connections</revremark>
      </revision>
      <revision>
        <revnumber>21.12</revnumber>
        <date>Dec-2021</date>
        <author>
          <personname>Oksana Tyushkina, Rick Boer</personname>
        </author>
        <revremark>Fix typo in commands names. Fix inconsistency in Security NoMatchingPrivateKey</revremark>
      </revision>
    </revhistory>
  </info>
  <chapter>
    <title>Scope</title>
    <para>This document defines the web service interface for ONVIF security configuration features such as a keystore and a TLS server on an ONVIF device.</para>
    <para>Web service usage is outside of the scope of this document. Please refer to the ONVIF core specification.</para>
  </chapter>
  <chapter>
    <title>Normative References</title>
    <para>IEEE 802.1X, Port-Based Network Access Control</para>
    <programlisting><![CDATA[<http://standards.ieee.org/getieee802/download/802.1X-2004.pdf>
]]></programlisting>
    <para>ONVIF Core Specification</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.onvif.org/specs/core/ONVIF-Core-Specification.pdf">http://www.onvif.org/specs/core/ONVIF-Core-Specification.pdf</link>&gt;</para>
    <para>RFC 2246 The TLS Protocol Version 1.0</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc2246.txt">http://www.ietf.org/rfc/rfc2246.txt</link>&gt;</para>
    <para>RFC 2898 PKCS#5 Password-based Cryptography Specification v2.0</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc2898.txt">http://www.ietf.org/rfc/rfc2898.txt</link>&gt;</para>
    <para>RFC 2986  PKCS #10: Certification RequestSyntaxSpecification Version 1.7</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc2986.txt">http://www.ietf.org/rfc/rfc2986.txt</link>&gt;</para>
    <para>RFC 3279 Algorithms and Identifiers for the Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc3279.txt">http://www.ietf.org/rfc/rfc3279.txt</link>&gt;</para>
    <para>RFC 3447 Public Key Cryptography Standards #1: RSA Cryptogaphy Specifications Version 2.1</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc3447.txt">http://www.ietf.org/rfc/rfc3447.txt</link>&gt;</para>
    <para>RFC 4055 Additional Algorithms and Identifiers for RSA Cryptography for use in the Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc4055.txt">http://www.ietf.org/rfc/rfc4055.txt</link>&gt;</para>
    <para>RFC 4346 The Transport Layer Security (TLS) Protocol Version 1.1</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc4346.txt">http://www.ietf.org/rfc/rfc4346.txt</link>&gt;</para>
    <para>RFC 5208 Public-Key Cryptography Standards (PKCS) #8: Private-Key Information Syntax Specification v1.2</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc5208.txt">http://www.ietf.org/rfc/rfc5208.txt</link>&gt;</para>
    <para>RFC 5246 The Transport Layer Security (TLS) Protocol Version 1.2</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc5246.txt">http://www.ietf.org/rfc/rfc5246.txt</link>&gt;</para>
    <para>RFC 5280 Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc5280.txt">http://www.ietf.org/rfc/rfc5280.txt</link>&gt;</para>
    <para>RFC 5958 Asymmetric Key Packages</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc5958.txt">http://www.ietf.org/rfc/rfc5958.txt</link>&gt;</para>
    <para>RFC 5959 Algorithms for Asymmetric Key Package Content Type</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc5959.txt">http://www.ietf.org/rfc/rfc5959.txt</link>&gt;</para>
    <para>Unified Modeling Language (UML) </para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.omg.org/spec/UML">http://www.omg.org/spec/UML</link>&gt;</para>
    <para>PKCS#5 Password-based Encryption Standard v1.5, RSA Laboratories, 1993</para>
    <para>PKCS#12: Personal Information Exchange Syntax v1.0, RSA Laboratories, 1999</para>
  </chapter>
  <chapter>
    <title>Terms and Definitions</title>
    <section>
      <title>Definitions</title>
      <informaltable>
        <tgroup cols="2">
          <colspec colname="c1" colwidth="17*"/>
          <colspec colname="c3" colwidth="79*"/>
          <tbody valign="top">
            <row>
              <entry>
                <para>Alias</para>
              </entry>
              <entry>
                <para>An alias is a name for an object on the device that is chosen by the client
                  and treated transparently by the device.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Certificate</para>
              </entry>
              <entry>
                <para>A certificate as used in this specification binds a public key to a subject
                  entity. The certificate is digitally signed by the certificate issuer (the
                  certification authority) to allow for verifying its authenticity.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Certification Authority</para>
              </entry>
              <entry>
                <para>A certification authority is an entity that issues certificates to subject
                  entities.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Certification Path</para>
              </entry>
              <entry>
                <para>A certification path is a sequence of certificates in which the signature of
                  each certificate except for the last certificate can be verified with the subject
                  public key in the next certificate in the sequence.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Certificate Revocation List</para>
              </entry>
              <entry>
                <para>A certificate revocation list is a digitally signed list of IDs of
                  certificates that have been revoked by the issuing CA.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Digital Signature</para>
              </entry>
              <entry>
                <para>A digital signature for an object allows to verify the object’s authenticity,
                  i.e., to check whether the object has in fact been created by the signer and has
                  not been modified afterwards. A digital signature is based on a key pair, where
                  the private key is used to create the signature and the public key is used for
                  verification of the signature.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Inner</para>
              </entry>
              <entry>
                <para>The authentication protocol used after having established a secure connection
                  using the outer authentication protocol. Also called Stage 2.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Key</para>
              </entry>
              <entry>
                <para>A key is an input to a cryptographic algorithm. Sufficient randomness of the
                  key is usually a necessary condition for the security of the algorithm. This
                  specification supports RSA key pairs as keys.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Key Pair</para>
              </entry>
              <entry>
                <para>A key that consists of a public key and (optionally) a private key.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Outer</para>
              </entry>
              <entry>
                <para>The initial authentication protocol used to establish a secure connection
                  between the device and the IEEE 802.1X authentication server. Also called Stage
                  1.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Passphrase</para>
              </entry>
              <entry>
                <para>A secret string that is shared between two or more parties. A passphrase may
                  be used to derive keys.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>RSA key pair</para>
              </entry>
              <entry>
                <para>A key pair that is accepted as input by the RSA algorithm.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>TLS Server</para>
              </entry>
              <entry>
                <para>TLS-enabled HTTP Server (HTTPS)</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
    <section>
      <title>Abbreviations</title>
      <variablelist>
        <varlistentry>
          <term>CA</term>
          <listitem><para>Certification Authority</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>CN</term>
          <listitem><para>Common Name</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>CRL</term>
          <listitem><para>Certificate Revocation List</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>CSR</term>
          <listitem><para>Certificate Signing Request (also called Certification Request)</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>EAP</term>
          <listitem><para>Extensible Authentication Protocol</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>HTTP</term>
          <listitem><para>Hypertext Transfer Protocol</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>IEEE</term>
          <listitem><para>Institute of Electrical and Electronics Engineers</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>MAC</term>
          <listitem><para>Message Authentication Code</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>MD5</term>
          <listitem><para>Message Digest Algorithm 5</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>MSCHAPv2</term>
          <listitem><para>Microsoft’s Challenge Handshake Authentication Protocol version 2</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>PEAP</term>
          <listitem><para>Protected EAP</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>SHA</term>
          <listitem><para>Secure Hashing Algorithm</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>SSL</term>
          <listitem><para>Secure Socket Layer</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>TLS</term>
          <listitem><para>Transport Layer Security</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>TTLS</term>
          <listitem><para>Tunneled TLS</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>WS</term>
          <listitem><para>Web Services</para></listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section>
      <title>Namespace</title>
      <para><xref linkend="namespaces"/> lists the namespaces references by this document.</para>
      <table xml:id="namespaces">
        <title>Referenced namespaces (with prefix)</title>
        <tgroup cols="2">
          <colspec colname="c1" colwidth="13*" />
          <colspec colname="c2" colwidth="87*" />
          <thead>
            <row>
              <entry>
                <para>Prefix</para>
              </entry>
              <entry>
                <para>Namespace URI</para>
              </entry>
            </row>
          </thead>
          <tbody valign="top">
            <row>
              <entry>
                <para>env</para>
              </entry>
              <entry>
                <para>http://www.w3.org/2003/05/soap-envelope</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>tas</para>
              </entry>
              <entry>
                  <para>http://www.onvif.org/advancedsecurity/wsdl</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>ter</para>
              </entry>
              <entry>
                <para>http://www.onvif.org/ver10/error</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>tt</para>
              </entry>
              <entry>
                <para>http://www.onvif.org/ver10/schema</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>xs </para>
              </entry>
              <entry>
                <para>http://www.w3.org/2001/XMLSchema</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </chapter>
  <chapter>
    <title>Overview</title>
    <section>
      <title>General Structure</title>
      <para>This specification covers the following security configuration features:</para>
      <itemizedlist>
        <listitem>
          <para>Keys and certificates management interface (keystore)</para>
        </listitem>
        <listitem>
          <para>TLS server configuration interface</para>
        </listitem>
        <listitem>
          <para>IEEE 802.1X</para>
        </listitem>
      </itemizedlist>
      <para>Basic security features such as user authentication based on WS UsernameToken and HTTP Authentication as well as a default access policy are specified in the [ONVIF Core Specification] as part of the device management service.</para>
      <para>WSDL for the Security Configuration Service is specified in &lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.onvif.org/ver10/advancedsecurity/wsdl/security.wsdl">http://www.onvif.org/ver10/advancedsecurity/wsdl/security.wsdl</link>&gt;.</para>
      <para>All sections in this specification are normative unless explicitly marked as informative.</para>
    </section>
    <section>
      <title>Certificate-based Client Authentication</title>
      <section>
        <title>Overview</title>
        <para>A client may be authenticated based on a certification path that it presents to the server, e.g., a TLS client is authenticated by a TLS server.</para>
        <para>The certificate-based authentication is performed according to a certification path validation algorithm that enforces a certification path validation policy. A certification path validation policy contains at least one trust anchor (in the form of a certificate) that the device shall assume to be correct. Furthermore, a certification path validation policy contains sources of revocation information to be considered when determining whether a certificate in question has been revoked. This specification uses CRLs as sources of revocation information, while future versions may include additional sources.</para>
        <para>A certificate revocation list (CRL) contains certificates that have been revoked by the issuing CA. Therefore, the private key corresponding to the public key in a revoked certificate shall be considered compromised.</para>
      </section>
      <section xml:id="_Ref395181338">
        <title>Certification path validation</title>
        <para>This section defines an algorithm to validate a certification path that is, e.g., supplied by an ONVIF client to an ONVIF device.</para>
        <para>Algorithm input:</para>
        <orderedlist>
          <listitem>
            <para>Certification path c<subscript>1</subscript>,…,c<subscript>m</subscript></para>
          </listitem>
          <listitem>
            <para>Current date and time</para>
          </listitem>
          <listitem>
            <para>Certification path validation policy</para>
          </listitem>
        </orderedlist>
        <para>Algorithm output:</para>
        <itemizedlist>
          <listitem>
            <para>
              <emphasis>valid</emphasis> if the certification path is considered valid, <emphasis>invalid</emphasis> otherwise.</para>
          </listitem>
        </itemizedlist>
        <para>Algorithm steps:</para>
        <orderedlist>
          <listitem>
            <para>Construct all prospective certification paths c<subscript>1</subscript>,…,c<subscript>n</subscript> from the input certification path c<subscript>1</subscript>,…,c<subscript>m </subscript>as specified in Sect. <xref linkend="_Ref392600159" />. If no prospective certification path can be constructed from the input certification path, return <emphasis>invalid</emphasis>.</para>
          </listitem>
          <listitem>
            <para>For all prospective certification paths c<subscript>1</subscript>,…,c<subscript>n</subscript></para>
            <orderedlist numeration="loweralpha">
              <listitem>
                <para>Determine whether c<subscript>1</subscript>,…,c<subscript>n</subscript> is valid by applying the algorithm defined in Sect. <xref linkend="_Ref392600142" /> with inputs</para>
                <itemizedlist>
                  <listitem>
                    <para>Prospective certification path c<subscript>1</subscript>,…,c<subscript>n</subscript></para>
                  </listitem>
                  <listitem>
                    <para>Current date and time</para>
                  </listitem>
                  <listitem>
                    <para>Certification path validation policy</para>
                  </listitem>
                </itemizedlist>
              </listitem>
              <listitem>
                <para>If c<subscript>1</subscript>,…,c<subscript>n</subscript> is valid, output <emphasis>valid.</emphasis></para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>Output <emphasis>invalid</emphasis>.</para>
          </listitem>
        </orderedlist>
        <para>A device that supports certification path validation as defined in this specification shall implement this algorithm.</para>
      </section>
      <section xml:id="_Ref392600159">
        <title>Construct Prospective Certification Paths</title>
        <para>This section defines an algorithm to construct prospective certification paths from an input certification path as indicated by the certification path validation policy.</para>
        <para>Algorithm input:</para>
        <orderedlist>
          <listitem>
            <para>Certification path c<subscript>1</subscript>,…,c<subscript>m</subscript></para>
          </listitem>
          <listitem>
            <para>Certification path validation policy</para>
          </listitem>
        </orderedlist>
        <para>Algorithm output:</para>
        <orderedlist>
          <listitem>
            <para>Prospective certification paths c<subscript>1</subscript>,…,c<subscript>n </subscript>if at least one prospective certification path exists.</para>
          </listitem>
          <listitem>
            <para>NULL if no prospective certification path exists.</para>
          </listitem>
        </orderedlist>
        <para>Algorithm steps:</para>
        <orderedlist>
          <listitem>
            <para>For all i in {1,…,m} such that c<subscript>i</subscript> is considered a trust anchor according to the certification path validation policy, add c<subscript>1</subscript>,…,c<subscript>i </subscript>to the set of prospective certification paths.</para>
          </listitem>
          <listitem>
            <para>Determine all certification path extensions c<subscript>m+1</subscript>,…,c<subscript>n</subscript> such that</para>
            <itemizedlist>
              <listitem>
                <para>for all c<subscript>i</subscript> with i in {m+1,…n-1}, the issuer of c<subscript>i</subscript> is the subject of c<subscript>i+1</subscript></para>
              </listitem>
              <listitem>
                <para>c<subscript>n</subscript> is considered a trust anchor according to the certification path validation policy</para>
              </listitem>
            </itemizedlist>
          </listitem>
          <listitem>
            <para>Add all extended certification paths c<subscript>1</subscript>,…,c<subscript>m</subscript>,c<subscript>m+1</subscript>,…,c<subscript>n </subscript>to the set of prospective certification paths.</para>
          </listitem>
          <listitem>
            <para>Return the set of prospective certification paths.</para>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="_Ref392600142">
        <title>Validate Prospective Certification Path</title>
        <para>This section defines an algorithm to validate a prospective certification path.</para>
        <para>Algorithm input:</para>
        <orderedlist>
          <listitem>
            <para>Prospective certification path c<subscript>1</subscript>,…,c<subscript>n</subscript></para>
          </listitem>
          <listitem>
            <para>Current date and time <emphasis>t</emphasis></para>
          </listitem>
          <listitem>
            <para>Certification path validation policy</para>
          </listitem>
        </orderedlist>
        <para>Algorithm output:</para>
        <itemizedlist>
          <listitem>
            <para>
              <emphasis>True</emphasis> if certification path is considered valid under the certification path validation policy, <emphasis>false</emphasis> otherwise.</para>
          </listitem>
        </itemizedlist>
        <para>Algorithm steps:</para>
        <orderedlist>
          <listitem>
            <para>Execute the algorithm specified in [RFC 5280], Sect. 6.1, with inputs</para>
            <orderedlist numeration="loweralpha">
              <listitem>
                <para>Prospective certification path c<subscript>n</subscript>,…,c<subscript>1</subscript></para>
              </listitem>
              <listitem>
                <para>Current date and time <emphasis>t</emphasis></para>
              </listitem>
              <listitem>
                <para>
                  <emphasis>User-initial-policy-set</emphasis> as defined in the certification path validation policy</para>
              </listitem>
              <listitem>
                <para>
                  <emphasis>Initial-policy-mapping-inhibit</emphasis> as defined in the certification path validation policy</para>
              </listitem>
              <listitem>
                <para>
                  <emphasis>Initial-explicit-policy</emphasis> as defined in the certification path validation policy</para>
              </listitem>
              <listitem>
                <para>
                  <emphasis>Initial-any-policy-inhibit</emphasis> as defined in the certification path validation policy</para>
              </listitem>
              <listitem>
                <para>
                  <emphasis>Initial-permitted-subtrees</emphasis> as defined in the certification path validation policy</para>
              </listitem>
              <listitem>
                <para>
                  <emphasis>Initial-excluded-subtrees</emphasis> as defined in the certification path validation policy</para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>If the output of step (1) contains a success indication, return <emphasis>true</emphasis>. Otherwise, return <emphasis>false</emphasis>.</para>
          </listitem>
        </orderedlist>
        <para>For determining the revocation status of a given certificate <emphasis>cert</emphasis> (Step (3) in [RFC 5280, Sect. 6.1.3]) in Step (1), the device shall use the algorithm defined in Sect. <xref linkend="_Ref392600406" /> with inputs</para>
        <orderedlist numeration="loweralpha">
          <listitem>
            <para>Certificate := <emphasis>cert</emphasis></para>
          </listitem>
          <listitem>
            <para>Certification path validation policy</para>
          </listitem>
        </orderedlist>
        <para>In order to determine whether an X.509 version 1 or version 2 certificate is a CA certificate as required in [RFC 5280], Sect. 6.1.4, step (k), the device shall use the source specified in the cA-information-source-for-v1-and-v2 information of the certification path validation policy.</para>
      </section>
      <section xml:id="_Ref392600406">
        <title>Determine Certificate Revocation Status</title>
        <para>Algorithm input:</para>
        <orderedlist>
          <listitem>
            <para>Certificate <emphasis>cert</emphasis></para>
          </listitem>
          <listitem>
            <para>Certification path validation policy</para>
          </listitem>
        </orderedlist>
        <para>Algorithm output:</para>
        <itemizedlist>
          <listitem>
            <para>REVOKED if certificate is considered revoked.</para>
          </listitem>
          <listitem>
            <para>UNREVOKED if certificate is considered to have been released from hold.</para>
          </listitem>
          <listitem>
            <para>UNDERTERMINED if the certificate is considered neither revoked nor released from hold.</para>
          </listitem>
        </itemizedlist>
        <para>Algorithm steps:</para>
        <orderedlist>
          <listitem>
            <para>For all CRLs <emphasis>l</emphasis> that shall be considered according to the certification path validation policy, execute the CRL validation algorithm defined in [RFC 5280], Sect. 6.3 with inputs</para>
            <orderedlist numeration="loweralpha">
              <listitem>
                <para>Certificate := the certificate <emphasis>cert</emphasis></para>
              </listitem>
              <listitem>
                <para>
                  <emphasis>use-deltas</emphasis> as defined in the certification path validation policy</para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>For all other sources of revocation information to be considered according to the certification path validation policy, determine the revocation status of the certificate <emphasis>cert</emphasis> based on the certification path validation policy.</para>
          </listitem>
          <listitem xml:id="_Ref392600111">
            <para>Combine the outputs of steps (1) and (2) as specified by the certification path validation policy and output the result.</para>
          </listitem>
        </orderedlist>
      </section>
      <section>
        <title>Certification Path Validation Policy</title>
        <section>
          <title>Certification Path Validation Algorithm Parameters</title>
          <para>By default, a device shall use the values defined in <xref linkend="_Ref395170314" /> for the algorithm parameters defined in [RFC 5280, Sect. 6.1.1] for the certification path validation algorithm defined in Sect. <xref linkend="_Ref392600142" />.</para>
          <table xml:id="_Ref395170314">
            <title>Default parameter values for the certification path validation algorithm</title>
            <tgroup cols="3">
              <colspec colname="c1" colwidth="25*" />
              <colspec colname="c2" colwidth="14*" />
              <colspec colname="c3" colwidth="61*" />
              <thead>
                <row>
                  <entry>
                    <para>Parameter</para>
                  </entry>
                  <entry>
                    <para>Default Value</para>
                  </entry>
                  <entry>
                    <para>Default Value Semantics</para>
                  </entry>
                </row>
              </thead>
              <tbody valign="top">
                <row>
                  <entry>
                    <para>User-initial-policy-set</para>
                  </entry>
                  <entry>
                    <para>Any-policy</para>
                  </entry>
                  <entry>
                    <para>The device is not concerned about certificate policy.</para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>Initial-policy-mapping-inhibit</para>
                  </entry>
                  <entry>
                    <para>0</para>
                  </entry>
                  <entry>
                    <para>Policy mapping is not inhibited.</para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>Initial-explicit-policy</para>
                  </entry>
                  <entry>
                    <para>0</para>
                  </entry>
                  <entry>
                    <para>The prospective certification path does not have to be valid for at least one certificate policy in the user-initial-policy-set</para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>Initial-any-policy-inhibit</para>
                  </entry>
                  <entry>
                    <para>0</para>
                  </entry>
                  <entry>
                    <para>The any-policy identifier, if asserted in a certificate, does not have to be ignored</para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>Initial-permitted-subtrees</para>
                  </entry>
                  <entry>
                    <para>(not specified)</para>
                  </entry>
                  <entry>
                    <para>No restrictions on the subtree within which all subject names in every certificate in the prospective certification path must fall.</para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>Initial-excluded-subtrees</para>
                  </entry>
                  <entry>
                    <para>(not specified)</para>
                  </entry>
                  <entry>
                    <para>No restrictions on the subtree within which no subject names in any certificate in the prospective certification path may fall.</para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>CA-information-source-for-v1-and-v2</para>
                  </entry>
                  <entry>
                    <para>None</para>
                  </entry>
                  <entry>
                    <para>The device shall consider X.509 version 1 and version 2 certificates as non-CA certificates.</para>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </section>
        <section>
          <title> Revocation Status Checking </title>
          <para>By default, a device shall use the parameter values defined in <xref linkend="_Ref395170420" /> for the parameters defined in [RFC 5280, Sect. 6.1.1] for the CRL-based certificate revocation status checking algorithm defined in Sect. <xref linkend="_Ref392600406" />.</para>
          <table xml:id="_Ref395170420">
            <title>Default parameter values for the revocation status checking algorithm</title>
            <tgroup cols="3">
              <colspec colname="c1" colwidth="33*" />
              <colspec colname="c2" colwidth="14*" />
              <colspec colname="c3" colwidth="53*" />
              <thead>
                <row>
                  <entry>
                    <para>Parameter</para>
                  </entry>
                  <entry>
                    <para>Default Value</para>
                  </entry>
                  <entry>
                    <para>Default Value Semantics</para>
                  </entry>
                </row>
              </thead>
              <tbody valign="top">
                <row>
                  <entry>
                    <para>Use-deltas</para>
                  </entry>
                  <entry>
                    <para>False</para>
                  </entry>
                  <entry>
                    <para>Delta CRLs, if available, are applied to CRLs.</para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>Relevant-reason-codes</para>
                  </entry>
                  <entry>
                    <para>All-reasons</para>
                  </entry>
                  <entry>
                    <para>The device considers a certificate revoked if it has been revoked for any reason defined in [RFC 5280].</para>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </table>
          <para>By default, a device shall consider all trusted sources of revocation information that it has access to when determining the revocation status of a certificate. The device shall consider the certificate in question revoked if and only if at least one such source indicates that the certificate in question is revoked. If one such source is unavailable, the device shall behave as if this source had provided the reply UNDETERMINED.</para>
          <para>A device shall consider at least the CRLs that are present in the keystore of the device.</para>
          <para>By default, certificates that are considered revoked shall not be included in prospective certification paths.</para>
        </section>
        <section>
          <title>Trust Anchors</title>
          <para>The trust anchors assigned to the certification path validation policy shall be used as trust anchor input to the certification path validation algorithm specified in Sect. <xref linkend="_Ref392600142" />.</para>
        </section>
        <section>
          <title>Certificate Repository for constructing Certification Paths</title>
          <para>By default, the certification path validation algorithm specified in Sect. <xref linkend="_Ref395181338" /> shall consider all certificates in the keystore on the device when constructing prospective certification paths.</para>
        </section>
        <section>
          <title>Specific certification path validation parameters</title>
          <para>
            <xref linkend="_Ref395173040" /> defines additional certification path validation parameters.</para>
          <table xml:id="_Ref395173040">
            <title>Specific certification path validation parameters</title>
            <tgroup cols="3">
              <colspec colname="c1" colwidth="52*" />
              <colspec colname="c2" colwidth="12*" />
              <colspec colname="c3" colwidth="35*" />
              <thead>
                <row>
                  <entry>
                    <para>Parameter</para>
                  </entry>
                  <entry>
                    <para>Default Value</para>
                  </entry>
                  <entry>
                    <para>Default Value Semantics</para>
                  </entry>
                </row>
              </thead>
              <tbody valign="top">
                <row>
                  <entry>
                    <para>RequireTLSWWWClientAuthExtendedKeyUsage</para>
                  </entry>
                  <entry>
                    <para>False</para>
                  </entry>
                  <entry>
                    <para>If true, a TLS server shall only allow TLS clients to connect that present a client certificate containing the Require WWW client auth extended key usage extension as specified in RFC 5280, Sect. 4.2.1.12.</para>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </section>
      </section>
      <section>
        <title>Validate CRLs</title>
        <para>By default, the device shall use the following algorithm to obtain and validate the certification path for a CRL issuer in Step (f) of the CRL processing algorithm defined in [RFC 5280, Sect. 6.3.3].</para>
        <para>Algorithm input:</para>
        <orderedlist>
          <listitem>
            <para>CRL <emphasis>l</emphasis></para>
          </listitem>
          <listitem>
            <para>Certification path validation policy</para>
          </listitem>
        </orderedlist>
        <para>Algorithm output: <emphasis>valid</emphasis> if the CRL is considered valid, <emphasis>invalid</emphasis> otherwise</para>
        <para>Algorithm steps:</para>
        <orderedlist>
          <listitem>
            <para>Let c<subscript>1</subscript>,…,c<subscript>m</subscript> denote the certificates in the certificate repository for constructing certification paths as defined by the certification path validation policy that contain the issuer of <emphasis>l</emphasis> as subject.</para>
          </listitem>
          <listitem>
            <para>For each certificate c<subscript>i</subscript></para>
            <orderedlist numeration="loweralpha">
              <listitem>
                <para>Execute the certification path validation algorithm defined in Sect. <xref linkend="_Ref395181338" /> with input</para>
                <itemizedlist>
                  <listitem>
                    <para>The certification path with c<subscript>i</subscript> as the only certificate in the path</para>
                  </listitem>
                  <listitem>
                    <para>Current time and date</para>
                  </listitem>
                  <listitem>
                    <para>Certification path validation policy</para>
                  </listitem>
                </itemizedlist>
              </listitem>
              <listitem>
                <para>If c<subscript>i</subscript> is valid, verify the signature of the CRL with the subject public key in c<subscript>i</subscript>.</para>
              </listitem>
              <listitem>
                <para>If the signature verification was successful, return <emphasis>valid</emphasis>.</para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>Return <emphasis>invalid.</emphasis></para>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section>
      <title>IEEE 802.1X</title>
      <para>IEEE 802.1X is an IEEE standard for port based network access control for the purpose of providing authentication and authorization of the devices attached to LAN ports. It allows access to the LAN port to devices that are configured for access, and prevents access to the LAN port to devices that are not correctly configured.</para>
      <para>This specification recommends the adoption of IEEE 802.1X for port based authentication for wireless networks.</para>
      <para>This specification defines a set of commands to configure and manage a device’s IEEE 802.1X configurations, both for wireless and hardwired network interfaces.  It assumes that IEEE 802.1X configuration and reconfiguration is performed outside of the IEEE 802.1X-secured network.</para>
      <para>Many schema elements in this specification include Dot1X as shorthand for IEEE 802.1X.  This convention increases the readability of source code generated from the WSDL.</para>
    </section>
  </chapter>
  <chapter>
    <title>Security Configuration Service</title>
    <section>
      <title>General Structure</title>
      <para>This section covers the security features</para>
      <itemizedlist>
        <listitem>
          <para>Keystore</para>
        </listitem>
        <listitem>
          <para>TLS server</para>
        </listitem>
        <listitem>
          <para>IEEE 802.1X</para>
        </listitem>
      </itemizedlist>
      <para>The design and data model of the ONVIF Security Configuration Service is reflected in <xref linkend="_Ref350769587" />.</para>
      <figure xml:id="_Ref350769587">
        <title>ONVIF Security Configuration Service [UML] Class Diagram</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="media/Security/image2.png" contentwidth="159.97mm" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>
    <section>
      <title>Keystore</title>
      <section>
        <title>Elements of the Keystore</title>
        <para>The keystore security feature handles the storage and management of passphrases, keys, and certificates on an ONVIF device.</para>
        <para>The keystore specified in this document supports passphrases, keys, key pairs, which are a particular type of key, RSA key pairs, which are a particular type of key pairs, certificates, certification paths, certificate revocation lists, and certification path validation policies.</para>
        <para>The boolean attribute <emphasis>externallyGenerated</emphasis> of a key shall be true if and only if the key was generated outside the device.</para>
        <para>The boolean attribute <emphasis>securelyStored</emphasis> of a key shall be true if and only if the key is stored in a specially protected hardware component (e.g., a trusted platform module) inside the device.</para>
      </section>
      <section>
        <title>Unique Identifiers</title>
        <para>An ID is used to uniquely identify objects of a particular type in the keystore on a device, i.e., no two objects of the same type shall have the same ID at any time.</para>
        <para>Passphrases in the keystore shall be uniquely identified by passphrase IDs, keys shall be uniquely identified by key IDs, certificates shall be uniquely identified by certificate IDs, certification paths in the keystore shall be uniquely identified by certification path IDs, certificate revocation lists shall be uniquely identified by certificate revocation list IDs, certification path validation policies shall be uniquely identified by certification path validation policy IDs, and IEEE 802.1X configurations shall be uniquely identified by IEEE 802.1X configuration IDs.</para>
        <para>It shall be noted that while IDs within a specific type shall be unique, no requirement exists for the uniqueness of IDs across different types. For example, there may be a key and a certificate in the keystore that share the same ID.</para>
        <para>Devices may assign the ID of a deleted identified object to another, subsequently generated object. However, devices should avoid re-using IDs as long as possible to avoid race conditions on the client side.</para>
        <para>A client may supply an alias for passphrases, keys, certificates, certification paths, certificate revocation lists, certification path validation policies and IEEE 802.1X configurations upon creation, e.g., to facilitate recognizing the created object at a later time. The device shall treat such aliases as unstructured data.</para>
      </section>
      <section>
        <title>Uniqueness of Objects in the Keystore</title>
        <para>A device shall allow multiple copies of the same passphrase to be present in the keystore under different IDs simultaneously.</para>
        <para>A device shall allow multiple copies of the same certificate and multiple copies of the same certification path to be present in the keystore under different IDs, respectively.</para>
        <para>A device shall allow multiple copies of the same certificate revocation list to be present in the keystore under different IDs, respectively.</para>
        <para>A device shall allow multiple copies of the same certification path validation policy to be present in the keystore under different IDs, respectively.</para>
        <para>A device shall allow multiple copies of the same IEEE 802.1X configuration to be present in the keystore under different IDs simultaneously.</para>
        <para>A device shall not allow multiple copies of the same key to be present in the keystore simultaneously.</para>
      </section>
      <section>
        <title>Referential Integrity</title>
        <para>The keystore design relies on associations between</para>
        <itemizedlist>
          <listitem>
            <para>Keys, especially key pairs, and certificates</para>
          </listitem>
          <listitem>
            <para>Public keys and private keys in key pairs</para>
          </listitem>
          <listitem>
            <para>Certificates and certification paths</para>
          </listitem>
          <listitem>
            <para>Keys and security features</para>
          </listitem>
          <listitem>
            <para>Certification paths and IEEE 802.1X configurations</para>
          </listitem>
          <listitem>
            <para>Passphrases and IEEE 802.1X configurations</para>
          </listitem>
          <listitem>
            <para>IEEE 802.1X configurations and security features</para>
          </listitem>
          <listitem>
            <para>Certificates and security features</para>
          </listitem>
          <listitem>
            <para>Certification path validation policies and certificates</para>
          </listitem>
          <listitem>
            <para>Certificate revocation lists and certificates</para>
          </listitem>
          <listitem>
            <para>Certification path validation policies and security features</para>
          </listitem>
        </itemizedlist>
        <para>A device shall enforce the following referential integrity rules for delete operations:</para>
        <itemizedlist>
          <listitem>
            <para>A key shall not be deleted if it is referenced by a certificate or a security feature.</para>
          </listitem>
          <listitem>
            <para>A certificate shall not be deleted if it is referenced by a certification path, a certificate revocation list, a certification path validation policy, or a security feature.</para>
          </listitem>
          <listitem>
            <para>A certification path shall not be deleted if it is referenced by an IEEE 802.1X configuration or a security feature.</para>
          </listitem>
          <listitem>
            <para>A passphrase shall not be deleted if it is referenced by an IEEE 802.1X configuration.</para>
          </listitem>
          <listitem>
            <para>A certification path validation policy shall not be deleted if it is referenced by a security feature.</para>
          </listitem>
          <listitem>
            <para>An IEEE 802.1X configuration shall not be deleted if it is referenced by a security feature.</para>
          </listitem>
        </itemizedlist>
        <para>This integrity rule may be enforced by the following mechanism. Reference counters are maintained for keys, certificates, certification paths, passphrases, and IEEE 802.1X configurations. Each time a reference to an object of these types is added, e.g., by associating a certificate to a key pair or assigning a key pair or certificate to a security feature, the reference counter of the object is incremented. Conversely, if a reference to an object is deleted, the reference counter of the referenced object is decremented. Deleting a key, certificate, or certification path is only permitted if the corresponding reference counter is equal to zero.</para>
        <para>A device shall enforce the following referential integrity rules for update operations:</para>
        <itemizedlist>
          <listitem>
            <para>
              <phrase>A key shall not be updated if it is referenced by a certificate or a security feature. However, </phrase>a private key may be added to an existing key pair if the private key matches the public key in the key pair. If a private key is about to be added to a key pair that already contains the private key to be added, the adding operation shall have no effect.</para>
          </listitem>
          <listitem>
            <para>A certificate shall not be updated if it is referenced by a certification path, a certificate revocation list, a certification path validation policy, or a security feature.</para>
          </listitem>
          <listitem>
            <para>A certification path validation policy shall not be updated if it is referenced by a security feature.</para>
          </listitem>
        </itemizedlist>
        <para>This specification omits APIs for modifying keys or certificates. If a key or certificate is to be updated, it has to be deleted and newly generated with the updated information. If other API exists that allows for modification of keys or certificates, special care shall be taken in order not to break the referential integrity rule.</para>
        <para>A device shall enforce the following invariants:</para>
        <itemizedlist>
          <listitem>
            <para>The private key and the public key in an asymmetric key pair in the keystore shall always match, i.e., the asymmetric operation under the public key is the inverse of the corresponding operation under the private key.</para>
          </listitem>
          <listitem>
            <para>The public key in a certificate in the keystore and the public key in an associated key pair in the keystore shall always be equal for all associated key pairs.</para>
          </listitem>
        </itemizedlist>
      </section>
      <section xml:id="_Ref353728108">
        <title>Key Status</title>
        <para>A key in the keystore is always in exactly one of the following states:</para>
        <itemizedlist>
          <listitem>
            <para>
              <emphasis>ok</emphasis> (The key is ready to be used)</para>
          </listitem>
          <listitem>
            <para>
              <emphasis>generating</emphasis> (The key is being generated and not yet ready for use)</para>
          </listitem>
          <listitem>
            <para>
              <emphasis>corrupt</emphasis> (The key is corrupt and shall not be used, e.g., because it was not properly generated or a hardware fault corrupted a key that was ready to be used)</para>
          </listitem>
        </itemizedlist>
      </section>
      <section>
        <title>Keystore Operations</title>
        <section>
          <title>Passphrase Management</title>
          <section>
            <title>UploadPassphrase</title>
            <para>This operation uploads a passphrase to the keystore of the device.</para>
            <para>Passphrases are uniquely identified using passphrase IDs. The device shall generate a new passphrase ID for the uploaded passphrase.</para>
            <para>If the command was successful, the device shall return the ID of the uploaded passphrase.</para>
            <para>If the device does not have enough storage capacity for storing the passphrase to be uploaded, the device shall produce a maximum number of passphrases reached fault and shall not upload the supplied passphrase.</para>
            <para>If the device cannot process the passphrase to be uploaded, the device shall produce a BadPassphrase fault and shall not upload a passphrase.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">Passphrase - [xs:string] </para>
                  <para role="text">The passphrase to upload.</para>
                  <para role="param">PassphraseAlias - optional [xs:string]</para>
                  <para role="text"> The alias for the passphrase to upload.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">PassphraseID - [tas:PassphraseID]</para>
                  <para role="text"> The PassphraseID of the uploaded passphrase.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Receiver - ter:Action - ter:MaximumNumberOfPassphrasesReached</para>
                  <para role="text"> The device does not have enough storage space to store the passphrase to be uploaded.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:BadPassphrase</para>
                  <para role="text"> The provided passphrase cannot be processed by the device.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">WRITE_SYSTEM</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>GetAllPassphrases</title>
            <para>This operation returns information about all passphrases that are stored in the keystore of the device.</para>
            <para>This operation may be used, e.g., if a client lost track of which passphrases are present on the device.</para>
            <para>If no passphrase is stored on the device, the device shall return an empty list.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="text">This message is empty.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">PassphraseAttribute - optional, unbounded [tas:PassphraseAttribute]</para>
                  <para role="text"> List of passphrase attributes.  Each attribute contains information about a passphrase in the keystore.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="text">None</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">READ_SYSTEM_SECRET</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>DeletePassphrase</title>
            <para>This operation deletes a passphrase from the keystore of the device.</para>
            <para>Passphrases are uniquely identified using passphrase IDs. If no passphrase is stored under the requested passphrase ID in the keystore, a device shall produce an invalid passphrase ID fault. If there is a passphrase under the requested passphrase ID stored in the keystore and the passphrase could not be deleted, a device shall produce a passphrase deletion failed fault.</para>
            <para>After a passphrase is successfully deleted, the device may assign its former ID to other passphrases.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">PassphraseID - [tas:PassphraseID]</para>
                  <para role="text"> The ID of the passphrase that is to be deleted from the keystore.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="text">This message is empty.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Receiver - ter:Action - ter:PassphraseDeletionFailed</para>
                  <para role="text"> Deleting the passphrase with the requested PassphraseID failed.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:PassphraseID</para>
                  <para role="text"> No passphrase is stored under the requested PassphraseID.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">UNRECOVERABLE</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
        </section>
        <section>
          <title>Key Management</title>
          <section>
            <title>CreateRSAKeyPair</title>
            <para>This operation triggers the asynchronous generation of an RSA key pair of a particular keylength (specified as the number of bits) as specified in [RFC 3447], with a suitable key generation mechanism on the device. Keys, especially RSA key pairs, are uniquely identified using key IDs. </para>
            <para>If the device does not have enough storage capacity for storing the key pair to be created, the maximum number of keys reached fault shall be produced and no key pair shall be generated. Otherwise, the operation generates a keyID for the new key and associates the <emphasis>generating</emphasis> status to it. Immediately after key generation has started, the device shall return the keyID to the client and continue to generate the key pair. The client may query the device with the GetKeyStatus operation (see Sect. <xref linkend="_Ref361388129" />) whether the generation has finished. The client may also subscribe to Key Status events (see Sect. <xref linkend="_Ref353780603" />) to be notified about key status changes.</para>
            <para>The device also returns a best-effort estimate of how much time it requires to create the key pair.<footnote xml:id="__FN1__"><para>Implementors may estimate the key generation time for a fixed key length as the average elapsed time of a number of key generation operations for this key length.</para></footnote> A client may use this information as an indication how long to wait before querying the device whether key generation is completed.</para>
            <para>After the key has been successfully created, the device shall assign it the <emphasis>ok</emphasis> status. If the key generation fails, the device shall assign the key the <emphasis>corrupt</emphasis> status.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">KeyLength - [xs:nonNegativeInteger]</para>
                  <para role="text"> The length of the key to be created.</para>
                  <para role="param">Alias - optional [xs:string] </para>
                  <para role="text">The client-defined alias of the key.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">KeyID - [tas:KeyID]</para>
                  <para role="text"> The key ID of the key pair being generated.</para>
                  <para role="param">EstimatedCreationTime - [xs:duration]</para>
                  <para role="text"> Best-effort estimation of how long the key generation will take.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Receiver - ter:Action - ter:MaximumNumberOfKeysReached</para>
                  <para role="text"> The keystore does not have enough storage space to store the key pair that has to be generated.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:KeyLength</para>
                  <para role="text"> The specified key length is not supported by the device.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">WRITE_SYSTEM</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>UploadKeyPairInPKCS8</title>
            <para>This operation uploads a key pair in a PKCS#8 data structure as specified in [RFC 5958, RFC 5959]. </para>
            <para>If an encryption passphrase ID is supplied in the request, the device shall assume that the KeyPair parameter contains an EncryptedPrivateKeyInfo ASN.1 structure that is encrypted under the passphrase in the keystore that corresponds to the supplied ID, where the EncryptedPrivateKeyInfo structure contains both the private key and the corresponding public key. If no encryption passphrase ID is supplied, the device shall assume that the KeyPair parameter contains a OneAsymmetricKey ASN.1 structure which contains both the private key and the corresponding public key. If a passphrase is supplied, the device shall ignore an eventually supplied passphrase ID and assume that the KeyPair parameter contains an EncryptedPrivateKeyInfo ASN.1 structure that is encrypted under the supplied passphrase, where the EncryptedPrivateKeyInfo structure contains both the private key and the corresponding public key.</para>
            <para>If the supplied key pair cannot be processed by the device, the device shall produce an UnsupportedPublicKeyAlgorithm fault and shall not store the uploaded key pair in the keystore.</para>
            <para>Key pairs are uniquely identified using key IDs. If a key pair exists in the keystore with the public key equal to the public key in the request and this key pair does not contain a private key, the device shall add the supplied private key to the existing key pair and return the ID of this key pair.</para>
            <para>If a key pair exists in the keystore with the public key equal to the public key in the request and this key pair contains a private key, the device shall leave the key pair unchanged and return the ID of this key pair.</para>
            <para>If the existing key pair does not have status <emphasis>ok</emphasis>, the device shall produce an InvalidKeyStatus fault and shall not modify the existing key pair.</para>
            <para>If no key pair exists in the keystore with the public key equal to the public key in the request, the device shall generate a new key pair with the supplied private key and the supplied public key, status <emphasis>ok</emphasis> and the externally generated attribute set to <emphasis>true</emphasis>. Furthermore, the device shall return the ID of this key pair.</para>
            <para>If a new key pair is created, the device shall assign the supplied alias to it. Otherwise, the device shall ignore an eventually supplied alias.</para>
            <para>If decryption of the EncryptedPrivateKeyInfo failed, the device shall produce a DecryptionFailed fault and shall not store the uploaded key pair in the keystore.</para>
            <para>If the device does not have enough storage capacity for storing the key pair that eventually has to be created, the device shall generate a maximum number of keys reached fault. Furthermore the device shall not generate a key pair.</para>
            <para>If no passphrase exists under the ID specified by EncryptionPassphraseID, the device shall produce an invalid passphrase ID fault and shall not store the uploaded key pair in the keystore.</para>
            <para>If the supplied PKCS#8 data structure cannot be processed by the device, the device shall produce a BadPKCS8File fault and shall not store the uploaded key pair in the keystore.</para>
            <para>If the public key in the uploaded key pair does not match the uploaded private key, the device shall produce a PublicPrivateKeyMismatch fault and shall not store the uploaded key pair in the keystore.</para>
            <para>If the command was successful, the device shall return the ID of the key pair in the keystore that contains the supplied public and private key.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">KeyPair - [tas:Base64DERencodedASN1Value]</para>
                  <para role="text"> The key pair to be uploaded in a PKCS#8 data structure.</para>
                  <para role="param">Alias - optional [xs:string]</para>
                  <para role="text"> The client-defined alias of the key pair.</para>
                  <para role="param">EncryptionPassphraseID - optional [tas:PassphraseID]</para>
                  <para role="text"> The ID of the passphrase to use for decrypting the uploaded key pair.</para>
                  <para role="param">EncryptionPassphrase - optional [xs:string]</para>
                  <para role="text"> The passphrase to use for decrypting the uploaded key pair.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">KeyID - [tas:KeyID]</para>
                  <para role="text"> The key ID of the uploaded key pair.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Receiver - ter:Action - ter:MaximumNumberOfKeysReached</para>
                  <para role="text"> The device does not have enough storage space to store the key pair to be uploaded.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:PassphraseID</para>
                  <para role="text"> No passphrase is stored under the requested PassphraseID.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:DecryptionFailed</para>
                  <para role="text"> The given date could not be decrypted.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:UnsupportedPublicKeyAlgorithm</para>
                  <para role="text"> The public key algorithm of the supplied key pair is not supported by the device.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:InvalidKeyStatus</para>
                  <para role="text"> The key with the requested KeyID has an inappropriate status.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:BadPKCS8File</para>
                  <para role="text"> The PKCS#8 data structure cannot be processed by the device.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:PublicPrivateKeyMismatch</para>
                  <para role="text"> The supplied private key does not match the supplied public key.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">WRITE_SYSTEM</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section xml:id="_Ref361388129">
            <title>GetKeyStatus</title>
            <para>This operation returns the status of a key as defined in Sect. <xref linkend="_Ref353728108" />.</para>
            <para>Keys are uniquely identified using key IDs. If no key is stored under the requested key ID in the keystore, an InvalidKeyID fault is produced. Otherwise, the status of the key is returned.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">KeyID - [tas:KeyID]</para>
                  <para role="text"> The ID of the key for which to return the status.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">KeyStatus - [xs:string]</para>
                  <para role="text"> Status of the requested key.  The value should be one of the values in the tas:KeyStatus enumeration.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:KeyID</para>
                  <para role="text"> No key is stored under the requested KeyID.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">READ_SYSTEM_SECRET</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>GetPrivateKeyStatus (deprecated)</title>
            <para>This operation returns whether a key pair contains a private key.</para>
            <para>Keys are uniquely identified using key IDs. If no key is stored under the requested key ID in the keystore, an invalid key ID fault shall be produced. If a key is stored under the requested key ID in the keystore, but this key is not a key pair, an invalid key type fault shall be produced.</para>
            <para>Otherwise, this operation returns <emphasis>true</emphasis> if the key pair identified by the key ID contains a private key, and <emphasis>false</emphasis> otherwise.</para>
            <para>This command is deprecated. Use GetAllKeys (see Sect. <xref linkend="_Ref415492349" />) instead.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">KeyID - [tas:KeyID]</para>
                  <para role="text"> The ID of the key pair for which to return whether it contains a private key.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">hasPrivateKey - [xs:boolean]</para>
                  <para role="text"> True if and only if the key pair contains a private key.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:KeyID</para>
                  <para role="text"> No key is stored under the requested KeyID.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:InvalidKeyType</para>
                  <para role="text"> The key stored in the keystore under the requested KeyID is of an invalid type.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">READ_SYSTEM_SECRET</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section xml:id="_Ref415492349">
            <title>GetAllKeys</title>
            <para>This operation returns information about all keys that are stored in the device’s keystore.</para>
            <para>This operation may be used, e.g., if a client lost track of which keys are present on the device.</para>
            <para>If no key is stored on the device, an empty list is returned.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="text">This message is empty.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">KeyAttribute - optional, unbounded [tas:KeyAttribute]</para>
                  <para role="text"> List of key attributes.  Each attribute contains information about a key in the keystore.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="text">None</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">READ_SYSTEM_SECRET</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section xml:id="_Ref363540841">
            <title>DeleteKey</title>
            <para>This operation deletes a key from the device’s keystore.</para>
            <para>Keys are uniquely identified using key IDs. If no key is stored under the requested key ID in the keystore, a device shall produce an InvalidArgVal fault. If a reference exists for the specified key, a device shall produce the corresponding fault and shall not delete the key. If there is a key under the requested key ID stored in the keystore and the key could not be deleted, a device shall produce a KeyDeletion fault. If the key has the status <emphasis>generating</emphasis>, a device shall abort the generation of the key and delete from the keystore all data generated for this key.</para>
            <para>After a key is successfully deleted, the device may assign its former ID to other keys.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">KeyID - [tas:KeyID]</para>
                  <para role="text"> The ID of the key that is to be deleted from the keystore.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="text">This message is empty.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">ter:Receiver - ter:Action - ter:KeyDeletionFailed</para>
                  <para role="text"> Deleting the key with the requested KeyID failed.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:KeyID</para>
                  <para role="text"> No key is stored under the requested KeyID.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:ReferenceExists</para>
                  <para role="text"> A reference exists for the object that is to be deleted.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">UNRECOVERABLE</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
        </section>
        <section>
          <title>Certificate Management</title>
          <section>
            <title>CreatePKCS10CSR</title>
            <para>This operation generates a DER-encoded PKCS#10 v1.7 certification request (sometimes also called certificate signing request or CSR) as specified in [RFC 2986] for a public key on the device. </para>
            <para>The key pair that contains the public key for which a certification request shall be produced is specified by its key ID. If no key is stored under the requested KeyID or the key specified by the requested KeyID is not an asymmetric key pair, an invalid key ID fault shall be produced and no CSR shall be generated.</para>
            <para>The subject parameter describes the entity that the public key belongs to. Additional attributes can be included in the attribute parameter.</para>
            <para>Distinguished name attribute values shall be supplied either in UTF-8 or in hexadecimal form as specified in RFC 4514.</para>
            <para>If the distinguished name attribute value is supplied in hexadecimal form, the device shall encode the attribute in the format given in the hexadecimal format.</para>
            <para>If the distinguished name attribute value is supplied in UTF-8 and the attribute value has a uniquely defined encoding (e.g., CountryName is defined as PrintableString), the device shall encode the attribute as the defined encoding. Otherwise, the device shall encode the attribute value as UTF-8.</para>
            <para>The signature algorithm parameter determines which signature algorithm shall be used for signing the certification request with the public key specified by the key ID parameter. If the specified signature algorithm is not supported by the device, an UnsupportedSignatureAlgorithm fault shall be produced and no CSR shall be generated. If the public key identified by the requested Key ID is an invalid input to the specified signature algorithm, a KeySignatureAlgorithmMismatch fault shall be produced and no CSR shall be generated. If the specified subject is invalid or incomplete, a Subject invalid fault shall be produced and no CSR shall be created. If an attribute is invalid or incomplete, an Attribute invalid fault shall be produced and no CSR shall be generated.</para>
            <para>If the key pair does not have status <emphasis>ok</emphasis>, a device shall produce an InvalidKeyStatus fault and no CSR shall be generated.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">Subject - [tas:DistinguishedName]</para>
                  <para role="text"> The subject to be included in the CSR.</para>
                  <para role="param">KeyID - [tas:KeyID]</para>
                  <para role="text"> The ID of the key for which the CSR shall be created.</para>
                  <para role="param">CSRAttribute - optional, unbounded [tas:CSRAttribute]</para>
                  <para role="text"> List of CSR attributes.  Each attribute contains an attribute to be included in the CSR.</para>
                  <para role="param">SignatureAlgorithm - [tas:AlgorithmIdentifier] </para>
                  <para role="text">The signature algorithm to be used to sign the CSR.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">PKCS10CSR - [tas:Base64DERencodedASN1Value]</para>
                  <para role="text"> The DER encoded PKCS#10 certification request.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">ter:Receiver - ter:Action - CSRCreationFailed</para>
                  <para role="text"> The generation of the PKCS#10 certification request failed.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:KeyID</para>
                  <para role="text"> No key is stored under the requested KeyID.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:UnsupportedSignatureAlgorithm</para>
                  <para role="text"> The specified signature algorithm is not supported by the device.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:KeySignatureAlgorithmMismatch</para>
                  <para role="text"> The specified public key is an invalid input to the specified signature algorithm.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:InvalidKeyStatus</para>
                  <para role="text"> The key with the requested KeyID has an inappropriate status.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:InvalidSubject</para>
                  <para role="text"> The specified subject is invalid or incomplete.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:InvalidAttribute</para>
                  <para role="text"> The specified attribute is invalid or incomplete.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">READ_SYSTEM</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>CreateSelfSignedCertificate</title>
            <para>This operation generates for a public key on the device a self-signed X.509 certificate that complies to [RFC 5280]. </para>
            <para>The X509Version parameter specifies the version of X.509 that the generated certificate shall comply to. A device that supports this command shall support the generation of X.509v3 certificates as specified in [RFC 5280] and may additionally be able to handle other X.509 certificate formats as indicated by the X.509Versions capability. If no X509Version is specified in the request, the device shall produce an X.509v3 certificate.</para>
            <para>The key pair that contains the public key for which a self-signed certificate shall be produced is specified by its key pair ID. The subject parameter describes the entity that the public key belongs to.</para>
            <para>If the key pair does not have status <emphasis>ok</emphasis>, a device shall produce an InvalidKeyStatus fault and no certificate shall be generated.</para>
            <para>If the specified subject is invalid or incomplete, an InvalidSubject fault shall be produced and no certificate shall be created.</para>
            <para>The notValidBefore parameter specifies at which point in time the validity period of the generated certificate shall begin. If this parameter is not specified in the request, the device shall use its current time or a time before its current time as starting point of the validity period. The notValidAfter parameter specifies at which point in time the validity period of the generated certificate shall end. If this parameter is not specified in the request, the device shall assign the GeneralizedTime value of 99991231235959Z as specified in [RFC 5280] to the notValidAfter parameter. If the notValidBefore parameter is invalid, an invalid DateTime fault shall be produced and no certificate shall be generated. If the notValidAfter parameter is invalid, an invalid DateTime fault shall be produced and no certificate shall be generated.</para>
            <para>The signature algorithm parameter determines which signature algorithm shall be used for signing the certification request with the public key specified by the key ID parameter.</para>
            <para>The Extensions parameter specifies potential X509v3 extensions that shall be contained in the certificate. A device that supports this command shall support the extensions that are defined in [RFC5280, Sect. 4.2] as mandatory for CAs that issue self-signed certificates.</para>
            <para>Distinguished name attribute values shall be supplied either in UTF-8 or in hexadecimal form as specified in RFC 4514.</para>
            <para>If the distinguished name attribute value is supplied in hexadecimal form, the device shall encode the attribute in the format given in the hexadecimal format.</para>
            <para>If the distinguished name attribute value is supplied in UTF-8 and the attribute value has a uniquely defined encoding (e.g., CountryName is defined as PrintableString), the device shall encode the attribute as the defined encoding. Otherwise, the device shall encode the attribute value as UTF-8.</para>
            <para>[RFC 5280, Sect. 4.1.2.2] mandates that the certificate serial numbers be unique for each certificate issued by a given issuer (a CA). Since the subject is equal to the issuer in a self-signed certificate, the serial number shall be unique for each self-signed certificate that the device issues for a given subject.</para>
            <para>The generated certificate shall not contain a unique identifier as specified in [RFC 5280], Sect. 4.1.2.8. The device shall not mark the generated certificate as trusted.</para>
            <para>Certificates are uniquely identified using certificate IDs. If the command was successful, the device generates a new ID for the generated certificate and returns this ID.</para>
            <para>If the device does not have enough storage capacity for storing the certificate to be created, the maximum number of certificates reached fault shall be produced and no certificate shall be generated.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">X509Version - optional [xs:positiveInteger]</para>
                  <para role="text"> The X.509 version that the generated certificate shall comply to.</para>
                  <para role="param">Subject - [tas:DistinguishedName]</para>
                  <para role="text"> Distinguished name of the entity that the certificate shall belong to.</para>
                  <para role="param">KeyID - [tas:KeyID]</para>
                  <para role="text"> The ID of the key for which the certificate shall be created.</para>
                  <para role="param">Alias - optional [xs:string]</para>
                  <para role="text"> The client-defined alias of the certificate to be created.</para>
                  <para role="param">notValidBefore - optional [xs:dateTime]</para>
                  <para role="text"> The X.509 not valid before information to be included in the certificate.  Defaults to a time equal to or before the device’s current time.</para>
                  <para role="param">notValidAfter - optional [xs:dateTime]</para>
                  <para role="text"> The X.509 not valid after information to be included in the certificate.  Defaults to the time 99991231235959Z as specified in RFC 5280.</para>
                  <para role="param">SignatureAlgorithm - [tas:AlgorithmIdentifier]</para>
                  <para role="text"> The signature algorithm to be used for signing the certificate.</para>
                  <para role="param">Extension - optional, unbounded [tas:X509v3Extension]</para>
                  <para role="text"> List of X.509v3 extensions to be included in the certificate.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">CertificateID - [tas:CertificateID]</para>
                  <para role="text"> The ID of the generated certificate.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">ter:Receiver - ter:Action - ter:CertificateCreationFailed</para>
                  <para role="text"> The generation of the self-signed certificate failed.</para>
                  <para role="param">ter:Receiver - ter:Action - ter:MaximumNumberOfCertificatesReached</para>
                  <para role="text"> The device does not have enough storage space to store the certificate to be created.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:UnsupportedX509Version</para>
                  <para role="text"> The specified X.509 version is not supported by the device.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:KeyID</para>
                  <para role="text"> No key is stored under the requested KeyID.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:UnsupportedSignatureAlgorithm </para>
                  <para role="text">The specified signature algorithm is not supported by the device.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:KeySignatureAlgorithmMismatch</para>
                  <para role="text"> The specified public key is an invalid input to the specified signature algorithm.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:X509VersionExtensionsMismatch</para>
                  <para role="text"> The request contains extensions which are not supported by the X509Version in the request.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:InvalidKeyStatus</para>
                  <para role="text"> The key with the requested KeyID has an inappropriate status.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:InvalidSubject</para>
                  <para role="text"> The specified subject is invalid or incomplete.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:InvalidDateTime</para>
                  <para role="text"> A specified date Time is invalid.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">WRITE_SYSTEM</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>UploadCertificate</title>
            <para>This operation uploads an X.509 certificate as specified by [RFC 5280]in DER encoding and the public key in the certificate to a device’s keystore. A device that supports this command shall be able to handle X.509v3 certificates as specified in [RFC 5280] and may additionally be able to handle other X.509 certificate formats as indicated by the X.509Versions capability. </para>
            <para>Certificates are uniquely identified using certificate IDs, and key pairs are uniquely identified using key IDs. The device shall generate a new certificate ID for the uploaded certificate.</para>
            <para>Certain certificate usages, e.g. TLS server authentication, require the private key that corresponds to the public key in the certificate to be present in the keystore. In such cases, the client may indicate that it expects the device to produce a fault if the matching private key for the uploaded certificate is not present in the keystore by setting the PrivateKeyRequired argument in the upload request to <emphasis>true</emphasis>.</para>
            <para>The uploaded certificate has to be linked to a key pair in the keystore.</para>
            <para>If no private key is required for the public key in the certificate and a key pair exists in the keystore with a public key equal to the public key in the certificate, the uploaded certificate is linked to the key pair identified by the supplied key ID by adding a reference from the certificate to the key pair.</para>
            <para>If no private key is required for the public key in the certificate and no key pair exists with the public key equal to the public key in the certificate, a new key pair with status <emphasis>ok </emphasis>is created with the public key from the certificate, and this key pair is linked to the uploaded certificate by adding a reference from the certificate to the key pair.</para>
            <para>If a private key is required for the public key in the certificate, and a key pair exists in the keystore with a private key that matches the public key in the certificate, the uploaded certificate is linked to this key pair by adding a reference from the certificate to the key pair. If a private key is required for the public key and no such keypair exists in the keystore, the NoMatchingPrivateKey fault shall be produced and the certificate shall not be stored in the keystore.</para>
            <para>The device shall assign the supplied Alias to the uploaded certificate.</para>
            <para>If a new key pair is generated, the device shall assign the supplied KeyAlias to it. Otherwise, the device shall ignore an eventually supplied KeyAlias.</para>
            <para>How the link between the uploaded certificate and a key pair is established is illustrated in <xref linkend="_Ref338934863" />.</para>
            <figure xml:id="_Ref338934863">
              <title>Link establishment between certificate and key pair for Upload Certificate</title>
              <mediaobject>
                <imageobject>
                  <imagedata fileref="media/Security/image3.png" contentwidth="159.70mm" />
                </imageobject>
              </mediaobject>
            </figure>
            <para>If the key pair that the certificate shall be linked to does not have status <emphasis>ok</emphasis>, an InvalidKeyID fault is produced, and the uploaded certificate is not stored in the keystore.</para>
            <para>If the signature algorithm that the signature of the supplied certificate is based on is not supported by the device, the device shall generate an UnsupportedSignatureAlgorithm fault and shall not store the uploaded certificate nor the contained public key in the keystore.</para>
            <para>If the device cannot process the uploaded certificate, a BadCertificate fault is produced and neither the uploaded certificate nor the public key are stored in the device’s keystore. The BadCertificate fault shall not be produced based on the mere fact that the device’s current time lies outside the interval defined by the notBefore and notAfter fields as specified by [RFC 5280], Sect. 4.1.</para>
            <para>The device shall not mark the uploaded certificate as trusted.</para>
            <para>If the device does not have enough storage capacity for storing the certificate to be uploaded, the maximum number of certificates reached fault shall be produced and no certificate shall be uploaded.</para>
            <para>If the device does not have enough storage capacity for storing the key pair that eventually has to be created, the device shall generate a maximum number of keys reached fault. Furthermore the device shall not generate a key pair and no certificate shall be stored.</para>
            <para>If the command was successful, the device returns the ID of the uploaded certificate and the ID of the key pair that contains the public key in the certificate.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">Certificate - [tas:Base64DERencodedASN1Value] </para>
                  <para role="text">The base64-encoded DER representation of the X.509 certificate to be uploaded.</para>
                  <para role="param">Alias - optional [xs:string]</para>
                  <para role="text"> The client-defined alias of the certificate.</para>
                  <para role="param">KeyAlias - optional [xs:string]</para>
                  <para role="text"> The client-defined alias of the key pair.</para>
                  <para role="param">PrivateKeyRequired - optional [xs:boolean]</para>
                  <para role="text"> Indicates if the device shall verify that a matching key pair with a private key exists in the keystore.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">CertificateID - [tas:CertificateID]</para>
                  <para role="text"> The ID of the uploaded certificate.</para>
                  <para role="param">KeyID - [tas:KeyID]</para>
                  <para role="text"> The ID of the key that the uploaded certificate certifies.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">ter:Receiver - tas:Action - ter:MaximumNumberOfCertificatesReached</para>
                  <para role="text"> The device does not have enough storage space to store the certificate to be uploaded.</para>
                  <para role="param">ter:Receiver - tas:Action - ter:MaximumNumberOfKeysReached</para>
                  <para role="text"> The device does not have enough storage space to store the key pair to be uploaded.</para>
                  <para role="param">ter:Receiver - tas:Action - ter:NoMatchingPrivateKey </para>
                  <para role="text">The keystore does not contain a key pair with a private key that matches the public key in the uploaded certificate.</para>
                  <para role="param">ter:Sender - tas:InvalidArgVal - ter:BadCertificate </para>
                  <para role="text">The supplied certificate file cannot be processed by the device.</para>
                  <para role="param">ter:Sender - tas:InvalidArgVal - ter:UnsupportedPublicKeyAlgorithm</para>
                  <para role="text"> The public key algorithm of the public key in the certificate is not supported by the device.</para>
                  <para role="param">ter:Sender - tas:InvalidArgVal - ter:UnsupportedSignatureAlgorithm</para>
                  <para role="text"> The specified signature algorithm is not supported by the device.</para>
                  <para role="param">ter:Sender - tas:InvalidArgVal - ter:InvalidKeyStatus</para>
                  <para role="text"> The key with the requested KeyID has an inappropriate status.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">WRITE_SYSTEM</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>UploadCertificateWithPrivateKeyInPKCS12</title>
            <para>This operation uploads a certification path consisting of X.509 certificates as specified by [RFC 5280] in DER encoding along with a private key to a device’s keystore. Certificates and private key are supplied in the form of a PKCS#12 file as specified in [PKCS#12].</para>
            <para>The device shall support PKCS#12 files that contain the following safe bags:</para>
            <itemizedlist>
              <listitem>
                <para>one or more instances of CertBag [PKCS#12, Sect. 4.2.3]</para>
              </listitem>
              <listitem>
                <para>either exactly one instance of KeyBag [PKCS#12, Sect. 4.3.1] or exactly one instance of PKCS8ShroudedKeyBag [PKCS#12, Sect. 4.2.2].</para>
              </listitem>
            </itemizedlist>
            <para>If the IgnoreAdditionalCertificates parameter has the value <emphasis>true</emphasis>, the device shall behave as if the client had supplied only the first CertBag in the sequence of CertBag instances.</para>
            <para>The device shall support PKCS#12 passphrase integrity mode for integrity protection of the PKCS#12 PFX as specified in [PKCS#12, Sect. 4]. The device shall support PKCS8ShroudedKeyBags that are encrypted with the same passphrase as the CertBag instances.</para>
            <para>If an integrity passphrase ID is supplied, the device shall use the corresponding passphrase in the keystore to check the integrity of the supplied PKCS#12 PFX. If an integrity passphrase ID is supplied, but the supplied PKCS#12 PFX has no integrity protection, the device shall produce a BadPKCS12File fault and shall not store the uploaded certificates nor the uploaded key pair in the keystore.</para>
            <para>If an encryption passphrase ID is supplied, the device shall use the corresponding passphrase in the keystore to decrypt the PKCS8ShroudedKeyBag and the CertBag instances.</para>
            <para>If an EncryptionPassphraseID is supplied, but a CertBag is not encrypted, the device shall ignore the supplied EncryptionPassphraseID when processing this CertBag. If an EncryptionPassphraseID is supplied, but a KeyBag is provided instead of a PKCS8ShroudedKeyBag, the device shall ignore the supplied EncryptionPassphraseID when processing the KeyBag.</para>
            <para>If a passphrase is supplied, the device shall ignore an eventually supplied integrity passphrase ID and an eventually supplied encryption passphrase ID, and the device shall use the supplied passphrase to check the integrity of the PKCS#12 PFX and to decrypt the PKCS8ShroudedKeyBag and the CertBag instances. If a passphrase is supplied, but the supplied PKCS#12 PFX has no integrity protection, the device shall not check the integrity of the PKCS#12 PFX. If a passphrase is supplied, but a CertBag is not encrypted, the device shall ignore the supplied passphrase when processing this CertBag. If a passphrase is supplied, but a KeyBag is supplied instead of a PKCS8ShroudedKeyBag, the device shall ignore the supplied passphrase when processing the KeyBag.</para>
            <para>If decryption of either the PKCS8ShroudedKeyBag or an encrypted CertBag failed, the device shall produce a DecryptionFailed fault and shall not store the uploaded certificates nor key pair in the keystore.</para>
            <para>If the signature algorithm of a supplied certificate is not supported by the device, the device shall produce an UnsupportedSignatureAlgorithm fault and shall not upload a certificate nor key pair.</para>
            <para>If the supplied key pair cannot be processed by the device, the device shall produce an UnsupportedPublicKeyAlgorithm fault and shall not store the uploaded key pair nor the uploaded certificates in the keystore.</para>
            <para>Certificates are uniquely identified using certificate IDs. The device shall store the uploaded certificates in the keystore and generate a new certificate ID for each of the uploaded certificates.</para>
            <para>Certification paths are uniquely identified using certification path IDs. The device shall create a certification path from the uploaded certificates. In this certification path, the certificates shall appear in the same order as in the PKCS#12 file. The device shall generate a new certification path ID for the created certification path and assign the eventually supplied CertificationPathAlias to the created certification path.</para>
            <para>The signature of each certificate in the sequence of uploaded certificates except for the last one shall be verifiable with the public key contained in the next certificate in the sequence. If there is a certificate in the request other than the last certificate for which the signature cannot be verified with the public key in the next certificate, the device shall produce an invalid certification path fault and shall not store the uploaded certificates nor uploaded private key in the keystore.</para>
            <para>If the device cannot process one of the uploaded certificates, it shall produce a BadCertificate fault and neither store the uploaded certificates nor private key in the keystore. The BadCertificate fault shall not be produced based on the mere fact that the device’s current time lies outside the interval defined by the notBefore and notAfter fields as specified by [RFC 5280], Sect. 4.1.</para>
            <para>The device shall not mark the uploaded certificates as trusted.</para>
            <para>The uploaded certificates have to be linked to key pairs in the keystore. Key pairs are uniquely identified using key IDs.</para>
            <para>If a key pair exists in the keystore with the public key equal to the public key in a certificate in the request, the device shall link the uploaded certificate to the key pair in the keystore by adding a reference from the certificate to the key pair. If the key pair in the keystore does not contain a private key and the private key contained in the KeyBag or PKCS8ShroudedKeyBag that matches the public key in the key pair, the device shall add the private key contained in the KeyBag or PKCS8ShroudedKeyBag to the key pair.</para>
            <para>If no key pair exists in the keystore with the public key equal to the public key in a certificate in the request, the device shall create a new key pair with status ok, externally generated attribute set to <emphasis>true</emphasis>, and the public and private keys from the request, and shall link this key pair to the uploaded certificate by adding a reference from the certificate to the key pair.</para>
            <para>If a new key pair is created for the uploaded private key, the device shall assign the supplied KeyAlias to it. Otherwise, the device shall ignore an eventually supplied KeyAlias.</para>
            <para>How the link between an uploaded certificate and a key pair is established is illustrated in <xref linkend="_Ref379899735" />.</para>
            <figure xml:id="_Ref379899735">
              <title>Link establishment between certificates and key pair for Upload Certificate with Private Key in PKCS#12</title>
              <mediaobject>
                <imageobject>
                  <imagedata fileref="media/Security/image4.png" contentwidth="122.16mm" />
                </imageobject>
              </mediaobject>
            </figure>
            <para>If the key pair that a certificate shall be linked to does not have status <emphasis>ok</emphasis>, the device shall produce an invalid key status fault and shall not store the uploaded certificates nor the uploaded key pair in the keystore.</para>
            <para>If the device does not have enough storage capacity for storing the certificates to be uploaded, the device shall produce a maximum number of certificates reached fault and shall not store the uploaded certificates nor the uploaded key pair in the keystore.</para>
            <para>If the device does not have enough storage capacity for storing the key pair that eventually has to be created, the device shall generate a maximum number of keys reached fault. Furthermore the device shall not store a key pair and shall not store the uploaded certificates in the keystore.</para>
            <para>If the device does not have enough storage capacity for storing the certification path to be created, the device shall produce a maximum number of certification paths reached fault and shall not store the uploaded certificates nor the uploaded key pair in the keystore.</para>
            <para>If no passphrase exists under the ID specified by IntegrityPassphraseID, the device shall produce an invalid passphrase ID fault and shall not store the uploaded certificates nor the uploaded key pair in the keystore.</para>
            <para>If no passphrase exists under the ID specified by EncryptionPassphraseID, the device shall produce an invalid passphrase ID fault and shall not store the uploaded certificates nor the uploaded key pair in the keystore.</para>
            <para>If the supplied PKCS#12 data structure cannot be processed by the device, the device shall produce a BadPKCS12File fault and shall not store the uploaded certificates nor the uploaded key pair in the keystore.</para>
            <para>If the public key in the first uploaded certificate does not match the uploaded private key, the device shall produce a PublicPrivateKeyMismatch fault and shall not store the uploaded certificates nor the uploaded key pair in the keystore.</para>
            <para>If the command was successful, the device shall return the ID of the created certification path and the ID of the key pair that contains the public key in the certificate.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">CertWithPrivateKey - [tas:Base64DERencodedASN1Value]</para>
                  <para role="text"> The certifcates and key pair to be uploaded in a PKCS#12 data structure.</para>
                  <para role="param">CertificationPathAlias - optional [xs:string] </para>
                  <para role="text">The client-defined alias of the certification path.</para>
                  <para role="param">KeyAlias - optional [xs:string]</para>
                  <para role="text"> The client-defined alias of the key pair.</para>
                  <para role="param">IgnoreAdditionalCertificates - optional [xs:boolean]</para>
                  <para role="text"> True if and only if the device shall behave as if the client had only supplied the first certificate in the sequence of certificates.</para>
                  <para role="param">IntegrityPassphraseID - optional [tas:PassphraseID]</para>
                  <para role="text"> The ID of the passphrase to use for integrity checking of the uploaded PKCS#12 data structure.</para>
                  <para role="param">EncryptionPassphraseID - optional [tas:PassphraseID]</para>
                  <para role="text"> The ID of the passphrase to use for decrypting the uploaded PKCS#12 data structure.</para>
                  <para role="param">Passphrase - optional [xs:string]</para>
                  <para role="text"> The passphrase to use for integrity checking and decrypting the uploaded PKCS#12 data structure.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">CertificationPathID - [tas:CertificationPathID]</para>
                  <para role="text"> The certification path ID of the uploaded certification path.</para>
                  <para role="param">KeyID - [tas:KeyID]</para>
                  <para role="text"> The key ID of the uploaded key pair.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">ter:Receiver - ter:Action - ter:</para>
                  <para role="text">
                    <emphasis role="bold">MaximumNumberOfCertificatesReached</emphasis> The device does not have enough storage space to store the certificate to be uploaded.</para>
                  <para role="param">ter:Receiver - ter:Action - ter:</para>
                  <para role="text">
                    <emphasis role="bold">MaximumNumberOfKeysReached</emphasis> The device does not have enough storage space to store the key pair that has to be generated.</para>
                  <para role="param">ter:Receiver - ter:Action - ter:</para>
                  <para role="text">
                    <emphasis role="bold">MaximumNumberOfCertificationPathsReached</emphasis> The device does not have enough storage space to store the certification path to be uploaded.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:PassphraseID</para>
                  <para role="text"> No passphrase is stored under the requested PassphraseID.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:DecryptionFailed</para>
                  <para role="text"> The given data could not be decrypted.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:BadCertificate</para>
                  <para role="text"> The supplied certificate file cannot be processed by the device.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:UnsupportedPublicKeyAlgorithm</para>
                  <para role="text"> The public key algorithm of the public key in the certificate is not supported by the device.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:UnsupportedSignatureAlgorithm</para>
                  <para role="text"> The signature algorithm that the signature of the supplied certificate is based on is not supported by the device.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:InvalidKeyStatus</para>
                  <para role="text"> The key with the requested KeyID has an inappropriate status.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:BadPKCS12File</para>
                  <para role="text"> The PKCS#12 data structure cannot be processed by the device.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:PublicPrivateKeyMismatch</para>
                  <para role="text"> The supplied private key does not match the supplied public key.</para>
                  <para role="param">env:Sender - ter: InvalidArgVal - ter:InvalidCertificationPath</para>
                  <para role="text"> At least one certificate in the certification path is not correctly signed with the public key in the next certificate in the path.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">WRITE_SYSTEM</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>GetCertificate</title>
            <para>This operation returns a specific certificate from the device’s keystore.</para>
            <para>Certificates are uniquely identified using certificate IDs. If no certificate is stored under the requested certificate ID in the keystore, an InvalidArgVal fault is produced.</para>
            <para>The certificate shall be returned in DER encoding.</para>
            <para>It shall be noted that this command does not return the private key that is associated with the public key in the certificate.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">Certificateid - [tas:CertificateID]</para>
                  <para role="text"> The ID of the certificate to retrieve.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">Certificate - [tas:X509Certificate]</para>
                  <para role="text"> The DER representation of the certificate.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:CertificateID</para>
                  <para role="text"> No certificate is stored under the requested CertificateID.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">READ_SYSTEM_SECRET</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>GetAllCertificates</title>
            <para>This operation returns all certificates that are stored in the device’s keystore.</para>
            <para>This operation may be used, e.g., if a client lost track of which certificates are present on the device.</para>
            <para>The certificates shall be returned in DER encoding.</para>
            <para>If no certificate is stored in the device’s keystore, an empty list is returned.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="text">This message is empty.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">Certificate - optional, unbounded [tas:X509Certificate]</para>
                  <para role="text"> List of DER representation of certificates stored in the keystore.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="text">None</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">READ_SYSTEM_SECRET</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>DeleteCertificate</title>
            <para>This operation deletes a certificate from the device’s keystore.</para>
            <para>The operation shall not delete the public key that is contained in the certificate from the keystore.</para>
            <para>Certificates are uniquely identified using certificate IDs. If no certificate is stored under the requested certificate ID in the keystore, an InvalidArgVal fault is produced. If there is a certificate under the requested certificate ID stored in the keystore and the certificate could not be deleted, a CertificateDeletion fault is produced.</para>
            <para>If a reference exists for the specified certificate, the certificate shall not be deleted and the corresponding fault shall be produced.</para>
            <para>After a certificate has been successfully deleted, the device may assign its former ID to other certificates.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">CertificateID - [tas:CertificateID]</para>
                  <para role="text"> The ID of the certificate to delete.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="text">This message is empty.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">ter:Receiver - ter:Action - ter:CertificateDeletionFailed</para>
                  <para role="text"> Deleting the certificate with the requested CertificateID failed.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:CertificateID</para>
                  <para role="text"> No certificate is stored under the requested CertificateID.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:ReferenceExists</para>
                  <para role="text"> A reference exists for the specified certificate.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">UNRECOVERABLE</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>CreateCertificationPath</title>
            <para>This operation creates a sequence of certificates that may be used, e.g., for certification path validation or for TLS server authentication.</para>
            <para>Certification paths are uniquely identified using certification path IDs. Certificates are uniquely identified using certificate IDs. A certification path contains a sequence of certificate IDs.</para>
            <para>If there is a certificate ID in the sequence of supplied certificate IDs for which no certificate exists in the device’s keystore, the corresponding fault shall be produced and no certification path shall be created.</para>
            <para>The signature of each certificate in the certification path except for the last one shall be verifiable with the public key contained in the next certificate in the path. If there is a certificate ID in the request other than the last ID for which the corresponding certificate cannot be verified with the public key in the certificate identified by the next certificate ID, an InvalidCertificateChain fault shall be produced and no certification path shall be created.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">CertificateIDs - [tas:CertificateIDs] </para>
                  <para role="text">The IDs of the certificates to include in the certification path, where each certificate signature except for the last one in the path must be verifiable with the public key certified by the next certificate in the path.</para>
                  <para role="param">Alias - optional [xs:string] </para>
                  <para role="text">The client-defined alias of the certification path.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">CertificationPathID - [tas:CertificationPathID] </para>
                  <para role="text">The ID of the generated certification path.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Receiver - ter:Action - ter:MaximumNumberOfCertificationPathsReached</para>
                  <para role="text"> The maximum number of certification paths that may be assigned to the TLS server simultaneously is reached.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:CertificateID </para>
                  <para role="text">No certificate is stored under the requested CertificateID.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:InvalidCertificationPath </para>
                  <para role="text">At least one certificate in the certification path is not correctly signed with the public key in the next certificate in the path.</para>
                  <para role="param">env:Receiver - ter:Action - ter:CertificationPathCreationFailed </para>
                  <para role="text">Creating the certification path failed.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">WRITE_SYSTEM</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>GetCertificationPath</title>
            <para>This operation returns a specific certification path from the device’s keystore.</para>
            <para>Certification paths are uniquely identified using certification path IDs. If no certification path is stored under the requested ID in the keystore, an InvalidArgVal fault is produced.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">CertificationPathID - [tas:CertificationPathID] </para>
                  <para role="text">The ID of the certification path to retrieve.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">CertificationPath - [tas:CertificationPath] </para>
                  <para role="text">The certification path that is stored under the given ID in the keystore.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:CertificationPathID </para>
                  <para role="text">No certification path is stored under the requested certification path ID.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">READ_SYSTEM_SECRET</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>GetAllCertificationPaths</title>
            <para>This operation returns the IDs of all certification paths that are stored in the device’s keystore.</para>
            <para>This operation may be used, e.g., if a client lost track of which certificates are present on the device.</para>
            <para>If no certification path is stored on the device, an empty list is returned.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="text">This message is empty.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">CertificationPathID - optional, unbounded [tas:CertificationPathID]</para>
                  <para role="text"> List of IDs of certification paths stored in the keystore.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="text">None</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">READ_SYSTEM_SECRET</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>DeleteCertificationPath</title>
            <para>This operation deletes a certification path from the device’s keystore.</para>
            <para>This operation shall not delete the certificates that are referenced by the certification path.</para>
            <para>Certification paths are uniquely identified using certification path IDs. If no certification path is stored under the requested certification path ID in the keystore, an InvalidArgVal fault is produced. If there is a certification path under the requested certification path ID stored in the keystore and the certification path could not be deleted, a CertificationPathDeletion fault is produced.</para>
            <para>If a reference exists for the specified certification path, the certification path shall not be deleted and the corresponding fault shall be produced.</para>
            <para>After a certification path is successfully deleted, the device may assign its former ID to other certification paths.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">CertificationPathID - [tas:CertificationPathID]</para>
                  <para role="text"> The ID of the certification path to delete.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="text">This message is empty.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">ter:Receiver - ter:Action - ter:CertificationPathDeletionFailed</para>
                  <para role="text"> Deleting the certification path with the requested certification path ID failed.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:CertificationPathID</para>
                  <para role="text"> No certification path is stored under the requested certification path ID.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:ReferenceExists</para>
                  <para role="text"> A reference exists for the object that is to be deleted.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">UNRECOVERABLE</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
        </section>
        <section>
          <title>CRL Management</title>
          <section>
            <title>UploadCRL</title>
            <para>This operation uploads a certificate revocation list (CRL) as specified in [RFC 5280] to the keystore on the device.</para>
            <para>If the device does not have enough storage space to store the CRL to be uploaded, the device shall produce a MaximumNumberOfCRLsReached fault and shall not store the supplied CRL.</para>
            <para>If the device is not able to process the supplied CRL, the device shall produce a BadCRL fault and shall not store the supplied CRL.</para>
            <para>If the device does not support the signature algorithm that was used to sign the supplied CRL, the device shall produce an UnsupportedSignatureAlgorithm fault and shall not store the supplied CRL.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">Crl - [tas:Base64DERencodedASN1Value]</para>
                  <para role="text"> The CRL to be uploaded to the device.</para>
                  <para role="param">Alias - optional [xs:string] </para>
                  <para role="text">The alias to assign to the uploaded CRL.</para>
                  <para role="param">anyParameters - optional, unbounded [xs:any]</para>
                  <para role="text">
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">CrlID - [tas:CRLID] </para>
                  <para role="text">The ID of the uploaded CRL.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Receiver - ter:Action - ter:MaximumNumberOfCRLsReached</para>
                  <para role="text">The device does not have enough storage space to store the CRL to be uploaded.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:BadCRL</para>
                  <para role="text">The supplied CRL cannot be processed by the device.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:UnsupportedSignatureAlgorithm </para>
                  <para role="text">
                    <phrase>The specified signature algorithm is not supported by the device.</phrase>
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">WRITE_SYSTEM</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>GetCRL</title>
            <para>This operation returns a specific certificate revocation list (CRL) from the keystore on the device.</para>
            <para>Certification revocation lists are uniquely identified using CRLIDs. If no CRL is stored under the requested CRLID, the device shall produce a CRLID fault.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">CrlID - [tas:CRLID]</para>
                  <para role="text"> The ID of the CRL to be returned.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">Crl - [tas:CRL] </para>
                  <para role="text">The CRL with the requested ID.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:CRLID </para>
                  <para role="text">
                    <phrase>No CRL is stored under the requested CRL ID.</phrase>
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">READ_SYSTEM_SECRET</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>GetAllCRLs</title>
            <para>This operation returns all certificate revocation lists (CRLs) that are stored in the keystore on the device.</para>
            <para>If no certificate revocation list is stored in the device’s keystore, an empty list is returned.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="text">This message is empty.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">Crl - optional, unbounded [tas:CRL]</para>
                  <para role="text"> A list of all CRLs that are stored in the keystore on the device.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="text">None</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">READ_SYSTEM_SECRET</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>DeleteCRL</title>
            <para>This operation deletes a certificate revocation list (CRL) from the keystore on the device.</para>
            <para>Certification revocation lists are uniquely identified using CRLIDs. If no CRL is stored under the requested CRLID, the device shall produce a CRLID fault.</para>
            <para>If a reference exists for the specified CRL, the device shall produce a ReferenceExists fault and shall not delete the CRL.</para>
            <para>After a CRL has been successfully deleted, a device may assign its former ID to other CRLs.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">CrlID - [tas:CRLID]</para>
                  <para role="text"> The ID of the CRL to be deleted.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="text">This message is empty.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:CRLID</para>
                  <para role="text"> No CRL is stored under the requested CRL ID.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:ReferenceExists</para>
                  <para role="text"> A reference exists for the object that is to be deleted.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">UNRECOVERABLE</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
        </section>
        <section>
          <title>Certification Path Validation Policy Management</title>
          <section>
            <title>CreateCertPathValidationPolicy</title>
            <para>This operation creates a certification path validation policy.</para>
            <para>Certification path validation policies are uniquely identified using certification path validation policy IDs. The device shall generate a new certification path validation policy ID for the created certification path validation policy.</para>
            <para>For the certification path validation parameters that are not represented in the certPathValidationParameters data type, the device shall use the default values specified in Sect. <xref linkend="_Ref392600111" />.</para>
            <para>If the device does not have enough storage capacity for storing the certification path validation policy to be created, the device shall produce a maximum number of certification path validation policies reached fault and shall not create a certification path validation policy.</para>
            <para>If there is at least one trust anchor certificate ID in the request for which there exists no certificate in the device’s keystore, the device shall produce a CertificateID fault and shall not create a certification path validation policy.</para>
            <para>If the device cannot process the supplied certification path validation parameters, the device shall produce a CertPathValidationParameters fault and shall not create a certification path validation policy.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">Alias - optional [xs:string] </para>
                  <para role="text">The alias to assign to the created certification path validation policy.</para>
                  <para role="param">Parameters - [tas:CertPathValidationParameters] </para>
                  <para role="text">The parameters of the certification path validation policy to be created.</para>
                  <para role="param">TrustAnchor - unbounded [tas:TrustAnchor] </para>
                  <para role="text">The trust anchors of the certification path validation policy to be created.</para>
                  <para role="param">anyParameters - optional [xs:any]</para>
                  <para role="text">
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">CertPathValidationPolicyID - [tas:CertPathValidationPolicyID] </para>
                  <para role="text">The ID of the created certification path validation policy.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Receiver - ter:Action - ter:MaximumNumberOfCertPathValidationPoliciesReached </para>
                  <para role="text">The device does not have enough storage to store the certification path validation policy to be created.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:CertificateID </para>
                  <para role="text">No certificate is stored under the requested CertificateID.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:CertPathValidationParameters </para>
                  <para role="text">The specified certification path validation parameters are invalid.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">WRITE_SYSTEM</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>GetCertPathValidationPolicy</title>
            <para>This operation returns a certification path validation policy from the keystore on the device.</para>
            <para>Certification path validation policies are uniquely identified using certification path validation policy IDs. If no certification path validation policy is stored under the requested certification path validation policy ID, the device shall produce a CertPathValidationPolicyID fault.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">CertPathValidationPolicyID - [tas:CertPathValidationPolicyID] </para>
                  <para role="text">The ID of the certification path validation policy to be created.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">CertPathValidationPolicy - [tas:CertPathValidationPolicy] </para>
                  <para role="text">The certification path validation policy that is stored under the requested ID.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:CertPathValidationPolicyID </para>
                  <para role="text">No certification path validation policy is stored under the requested certification path validation policy ID.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">READ_SYSTEM_SECRET</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>GetAllCertPathValidationPolicies</title>
            <para>This operation returns all certification path validation policies that are stored in the keystore on the device.</para>
            <para>If no certification path validation policy is stored in the device’s keystore, an empty list is returned.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="text">This message is empty.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">CertPathValidationPolicy - optional, unbounded - [tas:CertPathValidationPolicy] </para>
                  <para role="text">A list of all certification path validation policies that are stored in the keystore on the device.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="text">None</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">READ_SYSTEM_SECRET</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>DeleteCertPathValidationPolicy</title>
            <para>This operation deletes a certification path validation policy from the keystore on the device.</para>
            <para>Certification path validation policies are uniquely identified using certification path validation policy IDs. If no certification path validation policy is stored under the requested certification path validation policy ID, the device shall produce an CertPathValidationPolicyID fault.</para>
            <para>If a reference exists for the requested certification path validation policy, the device shall produce a ReferenceExists fault and shall not delete the certification path validation policy.</para>
            <para>After the certification path validation policy has been deleted, the device may assign its former ID to other certification path validation policies.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">CertPathValidationPolicyID - [tas:CertPathValidationPolicyID] </para>
                  <para role="text">The ID of the certification path validation policy to be deleted.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="text">This message is empty.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:CertPathValidationPolicyID </para>
                  <para role="text">No certification path validation policy is stored under the requested certification path validation policy ID.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:ReferenceExists</para>
                  <para role="text"> A reference exists for the object that is to be deleted.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">UNRECOVERABLE</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
        </section>
      </section>
    </section>
    <section>
      <title>TLS Server</title>
      <section>
        <title>Elements of the TLS Server</title>
        <para>The TLS server security feature implements a TLS server as specified in [RFC 2246] and subsequent specifications.</para>
        <para>This specification defines how to manage the associations between certification paths and the TLS server. All other TLS server configuration actions are outside the scope of this specification. In particular, enabling and disabling the TLS server on the device shall be performed using the device management service specified in the [ONVIF Core Specification].</para>
      </section>
      <section>
        <title>Authorization of TLS authenticated connections</title>
        <para>If TLS client authentication is enabled, connections shall be authenticated as specified in [RFC 2246], and the device shall before all validate the client TLS certificate. In case of invalid certificate the TLS connection shall be terminated and the device shall ignore any other credentials received on HTTP or WS layer.</para>
        <para>Once a service request is authenticated on the TLS layer, the device shall decide based on its  access policy whether the requestor is authorized to receive the service. In order to authorize the requestor, additional information for the device is required.</para>
        <para>If CnMapsToUser is true, the name of the user requiring access to the device shall be presented in the Common Name (CN) attribute of the certificate presented by the client to the device. The device shall validate the provided username against its set of credentials, and grant access to the requested function in case of success. If the user is not allowed to access the function, the device shall return a 403 Forbidden.</para>
        <para>If CnMapsToUser is false, from this point forward the authorization procedure follows what is specified in the [ONVIF Core Specification] as part of the security service.</para>
        <para>The authentication  and authorization process and falling back to the  [ONVIF Core Specification] is illustrated in <xref linkend="image5"/>.</para>
        <figure xml:id="image5">
          <title>Authentication and authorization flow chart and fallback mechanism to the [ONVIF Core Specification].</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="media/Security/image5.svg" contentwidth="160mm" />
            </imageobject>
          </mediaobject>
        </figure>
      </section>
      <section>
        <title>TLS Server Operations</title>
        <section>
          <title>AddServerCertificateAssignment</title>
          <para>This operation assigns a key pair and certificate along with a certification path (certificate chain) to the TLS server on the device. The TLS server shall use this information for key exchange during the TLS handshake, particularly for constructing server certificate messages as specified in [RFC 4346, RFC 2246].</para>
          <para>Certification paths are identified by their certification path IDs in the keystore. The first certificate in the certification path shall be the TLS server certificate.</para>
          <para>Since each certificate has exactly one associated key pair, a reference to the key pair that is associated with the server certificate is not supplied explicitly. Devices shall obtain the private key or results of operations under the private key by suitable internal interaction with the keystore.</para>
          <para>If a device chooses to perform a TLS key exchange based on the supplied certification path,  it shall use the key pair that is associated with the server certificate for key exchange and transmit the certification path to TLS clients as-is, i.e., the device shall not check conformance of the certification path to [RFC 4346, RFC 2246].</para>
          <para>In order to use the server certificate during the TLS handshake, the corresponding private key is required. Therefore, if the key pair that is associated with the server certificate, i.e., the first certificate in the certification path, does not have an associated private key, the NoPrivateKey fault is produced and the certification path is not associated with the TLS server.</para>
          <para>A TLS server may present different certification paths to different clients during the TLS handshake instead of presenting the same certification path to all clients. Therefore more than one certification path may be assigned to the TLS server. If the maximum number of certification paths that may be assigned to the TLS server simultaneously is reached, the device shall generate a MaximumNumberOfTLSCertificationPathsReached fault and the requested certification path shall not be assigned to the TLS server.</para>
          <para>If the certification path identified by the supplied certification path ID is already assigned to the TLS server, this command shall have no effect.</para>
          <variablelist role="op">
            <varlistentry>
              <term>request</term>
              <listitem>
                <para role="param">CertificationPathID - [tas:CertificationPathID] The ID of the certification path to assign to the TLS server.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>response</term>
              <listitem>
                <para role="text">This message is empty.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>faults</term>
              <listitem>
                <para role="param">env:Sender - ter:InvalidArgVal - ter:CertificationPathID No certification path is stored in the keystore under the given certification path ID.</para>
                <para role="param">env:Sender - ter:InvalidArgVal - ter:NoPrivateKey The key pair that is associated with the first certificate in the certificate chain does not have an associated private key.</para>
                <para role="param">env: Receiver - ter: Action - ter:MaximumNumberOfTLSCertificationPathsReached The maximum number of certification paths that may be assigned to the TLS server simultaneously is reached.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>access class</term>
              <listitem>
                <para role="access">WRITE_SYSTEM</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>RemoveServerCertificateAssignment</title>
          <para>This operation removes a key pair and certificate assignment (including certification path) to the TLS server on the device.</para>
          <para>Certification paths are identified using certification path IDs. If the supplied certification path ID is not associated with the TLS server, an InvalidArgVal fault is produced.</para>
          <para>If the TLS server on the device is enabled, the device shall produce a ReferenceExists fault and shall not remove the server certificate assignment.</para>
          <variablelist role="op">
            <varlistentry>
              <term>request</term>
              <listitem>
                <para role="param">CertificationPathID - [tas:CertificationPathID] The ID of the certification path to remove from the TLS server.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>response</term>
              <listitem>
                <para role="text">This message is empty.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>faults</term>
              <listitem>
                <para role="param">env:Sender - ter:InvalidArgVal - ter:OldCertificationPathID</para>
                <para role="text"> No certification path under the given certification path ID is associated with the TLS server.</para>
                <para role="param">env:Sender - ter:InvalidArgVal - ter:ReferenceExists</para>
                <para role="text"> A reference exists for the object that is to be deleted.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>access class</term>
              <listitem>
                <para role="access">WRITE_SYSTEM</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>ReplaceServerCertificateAssignment</title>
          <para>This operation replaces an existing key pair and certificate assignment to the TLS server on the device by a new key pair and certificate assignment (including certification paths).</para>
          <para>After the replacement, the TLS server shall use the new certificate and certification path exactly in those cases in which it would have used the old certificate and certification path. Therefore, especially in the case that several server certificates are assigned to the TLS server, clients that wish to replace an old certificate assignment by a new assignment should use this operation instead of a combination of the Add TLS Server Certificate Assignment and the Remove TLS Server Certificate Assignment operations.</para>
          <para>Certification paths are identified using certification path IDs. If the supplied old certification path ID is not associated with the TLS server, or no certification path exists under the new certification path ID, the corresponding InvalidArgVal faults are produced and the associations are unchanged.</para>
          <para>The first certificate in the new certification path shall be the TLS server certificate.</para>
          <para>Since each certificate has exactly one associated key pair, a reference to the key pair that is associated with the new server certificate is not supplied explicitly. Devices shall obtain the private key or results of operations under the private key by suitable internal interaction with the keystore.</para>
          <para>If a device chooses to perform a TLS key exchange based on the new certification path, it shall use the key pair that is associated with the server certificate for key exchange and transmit the certification path to TLS clients as-is, i.e., the device shall not check conformance of the certification path to [RFC 4346, RFC 2246].</para>
          <para>In order to use the server certificate during the TLS handshake, the corresponding private key is required. Therefore, if the key pair that is associated with the server certificate, i.e., the first certificate in the certification path, does not have an associated private key, the NoPrivateKey fault is produced and the certification path is not associated with the TLS server.</para>
          <variablelist role="op">
            <varlistentry>
              <term>request</term>
              <listitem>
                <para role="param">OldCertificationPathID - [tas:CertificationPathID] </para>
                <para role="text">The ID of the certification path to remove from the TLS server.</para>
                <para role="param">NewCertificationPathID - [tas:CertificationPathID] </para>
                <para role="text">The ID of the certification path to assign to the TLS server.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>response</term>
              <listitem>
                <para role="text">This message is empty.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>faults</term>
              <listitem>
                <para role="param">env:Sender - ter:InvalidArgVal - ter:OldCertificationPathID </para>
                <para role="text">No certification path under the given certification path ID is associated with the TLS server.</para>
                <para role="param">env:Sender - ter:InvalidArgVal - ter:NewCertificationPathID </para>
                <para role="text">No certification path is stored in the keystore under the given certification path ID.</para>
                <para role="param">env:Sender - ter:InvalidArgVal - ter:NoPrivateKey </para>
                <para role="text">The key pair that is associated with the first certificate in the certificate chain does not have an associated private key.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>access class</term>
              <listitem>
                <para role="access">WRITE_SYSTEM</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>GetAssignedServerCertificates</title>
          <para>This operation returns the IDs of all certification paths that are assigned to the TLS server on the device.</para>
          <para>This operation may be used, e.g., if a client lost track of the certification path assignments on the device.</para>
          <para>If no certification path is assigned to the TLS server, an empty list is returned.</para>
          <variablelist role="op">
            <varlistentry>
              <term>request</term>
              <listitem>
                <para role="text">This message is empty.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>response</term>
              <listitem>
                <para role="param">CertificationPathID - optional, unbounded [tas:CertificationPathID] </para>
                <para role="text">List of certification path IDs assigned to the TLS server.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>faults</term>
              <listitem>
                <para role="text">None</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>access class</term>
              <listitem>
                <para role="access">READ_SYSTEM_SECRET</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>SetClientAuthenticationRequired</title>
          <para>This operation activates or deactivates TLS client authentication for the TLS server on the device.</para>
          <para>The TLS server on the device shall require client authentication if and only if clientAuthenticationRequired is set to <emphasis>true</emphasis>.</para>
          <para>If TLS client authentication is requested to be enabled and no certification path validation policy is assigned to the TLS server, the device shall return an EnablingClientAuthenticationFailed fault and shall not enable TLS client authentication.</para>
          <para>The device shall execute this command regardless of the TLS enabled/disabled state configured in the [ONVIF Device Management Service].</para>
          <variablelist role="op">
            <varlistentry>
              <term>request</term>
              <listitem>
                <para role="param">clientAuthenticationRequired - [xs:boolean] </para>
                <para role="text">Define whether TLS client authentication is active on the device.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>response</term>
              <listitem>
                <para role="text">This message is empty.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>faults</term>
              <listitem>
                <para role="param">env:Receiver - ter:ActionNotSupported - ter:EnablingClientAuthenticationFailed </para>
                <para role="text">The device does not support TLS client authentication, or TLS client authentication is not configured appropriately.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>access class</term>
              <listitem>
                <para role="access">WRITE_SYSTEM</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>GetClientAuthenticationRequired</title>
          <para>This operation returns whether TLS client authentication is active.</para>
          <variablelist role="op">
            <varlistentry>
              <term>request</term>
              <listitem>
                <para role="text">This message is empty.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>response</term>
              <listitem>
                <para role="param">clientAuthenticationRequired - [xs:boolean] </para>
                <para role="text">Report whether TLS client authentication is active on the device.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>faults</term>
              <listitem>
                <para role="text">None</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>access class</term>
              <listitem>
                <para role="access">READ_SYSTEM</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>SetCnMapsToUser</title>
          <para>This operation enables or disables mapping of the Common Name present in the TLS client certificate to an existing user name in the device.</para>
          <para>The TLS server on the device shall perform mapping if parameter clientAuthenticationRequired is set to <emphasis>true</emphasis>.</para>
          <variablelist role="op">
            <varlistentry>
              <term>request</term>
              <listitem>
                <para role="param">cnMapsToUser - [xs:boolean] A request for the device to enable or disable Common Name Mapping to User.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>response</term>
              <listitem>
                <para role="text">This message is empty.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>faults</term>
              <listitem>
                <para role="param">env:Receiver - ter:ActionNotSupported - ter:CnMapsToUserFailed The device does not support TLS client authentication, or TLS client authentication is not configured appropriately.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>access class</term>
              <listitem>
                <para role="access">WRITE_SYSTEM</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>GetCnMapsToUser</title>
          <para>This operation returns whether the Common Name Mapping to User is enabled.</para>
          <variablelist role="op">
            <varlistentry>
              <term>request</term>
              <listitem>
                <para role="param">This message is empty.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>response</term>
              <listitem>
                <para role="text">cnMapsToUser - [xs:boolean] Whether cnMapsToUser is enabled.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>faults</term>
              <listitem>
                <para role="param">None</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>access class</term>
              <listitem>
                <para role="access">READ_SYSTEM</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>AddCertPathValidationPolicyAssignment</title>
          <para>This operation assigns a certification path validation policy to the TLS server on the device. The TLS server shall enforce the policy when authenticating TLS clients and consider a client authentic if and only if the algorithm defined in Sect. <xref linkend="_Ref395181338" /> returns <emphasis>valid</emphasis>.</para>
          <para>If no certification path validation policy is stored under the requested CertPathValidationPolicyID, the device shall produce a CertPathValidationPolicyID fault.</para>
          <para>A TLS server may use different certification path validation policies to authenticate clients. Therefore more than one certification path validation policy may be assigned to the TLS server. If the maximum number of certification path validation policies that may be assigned to the TLS server simultaneously is reached, the device shall produce a MaximumNumberOfTLSCertPathValidationPoliciesReached fault and shall not assign the requested certification path validation policy to the TLS server.</para>
          <variablelist role="op">
            <varlistentry>
              <term>request</term>
              <listitem>
                <para role="param">CertPathValidationPolicyID - [tas:CertPathValidationPolicyID] The ID of the certification path validation policy to assign to the TLS server.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>response</term>
              <listitem>
                <para role="text">This message is empty.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>faults</term>
              <listitem>
                <para role="param">env:Sender - ter:InvalidArgVal - ter:CertPathValidationPolicyID No certification path validation policy is stored under the requested CertPathValidationPolicyID.</para>
                <para role="param">env:Receiver - ter:Action - ter:MaximumNumberOfTLSCertPathValidationPoliciesReached The maximum number of certification path validation policies that may be assigned to the TLS server simultaneously is reached.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>access class</term>
              <listitem>
                <para role="access">WRITE_SYSTEM</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>RemoveCertPathValidationPolicyAssignment</title>
          <para>This operation removes a certification path validation policy assignment from the TLS server on the device.</para>
          <para>If the certification path validation policy identified by the requested CertPathValidationPolicyID is not associated to the TLS server, the device shall produce a CertPathValidationPolicyID fault.</para>
          <variablelist role="op">
            <varlistentry>
              <term>request</term>
              <listitem>
                <para role="param">CertPathValidationPolicyID - [tas:CertPathValidationPolicyID] The ID of the certification path validation policy to remove from the TLS server.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>response</term>
              <listitem>
                <para role="text">This message is empty.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>faults</term>
              <listitem>
                <para role="param">env:Sender - ter:InvalidArgVal - ter:CertPathValidationPolicyID No certification path validation policy is stored under the requested CertPathValidationPolicyID.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>access class</term>
              <listitem>
                <para role="access">WRITE_SYSTEM</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>ReplaceCertPathValidationPolicyAssignment</title>
          <para>This operation replaces a certification path validation policy assignment to the TLS server on the device with another certification path validation policy assignment.</para>
          <para>If the certification path validation policy identified by the requested OldCertPathValidationPolicyID is not associated to the TLS server, the device shall produce an OldCertPathValidationPolicyID fault and shall not associate the certification path validation policy identified by the NewCertPathValidationPolicyID to the TLS server.</para>
          <para>If no certification path validation policy exists under the requested NewCertPathValidationPolicyID in the device’s keystore, the device shall produce a NewCertPathValidationPolicyID fault and shall not remove the association of the old certification path validation policy to the TLS server.</para>
          <variablelist role="op">
            <varlistentry>
              <term>request</term>
              <listitem>
                <para role="param">OldCertPathValidationPolicyID - [tas:CertPathValidationPolicyID] </para>
                <para role="text">The ID of the certification path validation policy to remove from the TLS server.</para>
                <para role="param">NewCertPathValidationPolicyID - [tas:CertPathValidationPolicyID] </para>
                <para role="text">The ID of the certification path validation policy to assign to the TLS server.</para>
                <para role="param">RESPONSE:</para>
                <para role="text">This message is empty.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>faults</term>
              <listitem>
                <para role="param">env:Sender - ter:InvalidArgVal - ter:OldCertPathValidationPolicyID </para>
                <para role="text">No certification path validation policy under the given OldCertPathValidationPolicyID is associated with the TLS server.</para>
                <para role="param">env:Sender - ter:InvalidArgVal - ter:NewCertPathValidationPolicyID </para>
                <para role="text">No certification path validation policy under the given NewCertPathValidationPolicyID is stored in the device’s keystore.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>access class</term>
              <listitem>
                <para role="access">WRITE_SYSTEM</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>GetAssignedCertPathValidationPolicies</title>
          <para>This operation returns the IDs of all certification path validation policies that are assigned to the TLS server on the device.</para>
          <variablelist role="op">
            <varlistentry>
              <term>request</term>
              <listitem>
                <para role="text">This message is empty.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>response</term>
              <listitem>
                <para role="param">CertPathValidationPolicyID - optional, unbounded [tas:CertPathValidationPolicyID] </para>
                <para role="text">List of certification path validation policy IDs assigned to the TLS server.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>faults</term>
              <listitem>
                <para role="text">None</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>access class</term>
              <listitem>
                <para role="access">READ_SYSTEM_SECRET</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>SetEnabledTLSVersions</title>
          <para>This operation sets the version(s) of TLS which the device shall use. Valid values are taken from the TLSServerSupported capability.</para>
          <para>A client initiates a TLS session by sending a ClientHello with the highest TLS version it supports. This suggests to the server that the client can accept any TLS version up to and including that version.</para>
          <para>The server then chooses the TLS version to use. This is generally the highest TLS version the server supports that is within the range of the client. For example, if a ClientHello indicates TLS version 1.1, the server can proceed with TLS 1.0 or TLS 1.1.</para>
          <para>In the event that an ONVIF installation wishes to disable certain version(s) of TLS, it may do so with this operation. For example, to disable TLS 1.0 on a device signaling support for TLS versions 1.0, 1.1, and 1.2, the enabled version list may be set to "1.1 1.2", omitting 1.0. If a client then attempts to connect with a ClientHello containing TLS 1.0, the server shall send a "protocol_version" alert message and close the connection. This handshake indicates to the client that TLS 1.0 is not supported by the server. The client must try again with a higher TLS version suggestion.</para>
          <para>An empty version list is not permitted. Disabling all versions of TLS is not the intent of this operation. See AddServerCertificateAssignment and RemoveServerCertificateAssignment.</para>
          <para>A device signalling support for TLS version enabling with the EnabledVersionsSupported capability shall support this command.</para>
          <variablelist role="op">
            <varlistentry>
              <term>request</term>
              <listitem>
                <para role="param">Versions - [tas:TLSVersions] </para>
                <para role="text">Space-delimited list of TLS versions to allow.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>response</term>
              <listitem>
                <para role="text">This is an empty message.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>faults</term>
              <listitem>
                <para role="param">env:Sender - ter:InvalidArgVal - ter:EmptyList </para>
                <para role="text">The version list is empty.</para>
                <para role="param">env:Sender - ter:InvalidArgVal - ter:TLSVersion </para>
                <para role="text">A version is not recognized.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>access class</term>
              <listitem>
                <para role="access">WRITE_SYSTEM</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>GetEnabledTLSVersions</title>
          <para>This operation retrieves the version(s) of TLS which are currently enabled on the device. A device signalling support for TLS version enabling with the EnabledVersionsSupported capability shall support this command.</para>
          <variablelist role="op">
            <varlistentry>
              <term>request</term>
              <listitem>
                <para role="text">This is an empty message.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>response</term>
              <listitem>
                <para role="param">Versions - [tas:TLSVersions] </para>
                <para role="text">Space-delimited list of enabled TLS versions.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>faults</term>
              <listitem>
                <para role="text">None</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>access class</term>
              <listitem>
                <para role="access">READ_SYSTEM</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
      </section>
    </section>
    <section>
      <title>IEEE 802.1X</title>
      <section>
        <title>AddDot1XConfiguration</title>
        <para>This operation adds an IEEE 802.1X configuration to the device.</para>
        <para>Configurations are uniquely identified using IEEE 802.1X configuration IDs. The device shall ignore Dot1XID in the request, if present, and shall generate a unique configuration ID for the added configuration.</para>
        <para>If the command was successful, the device shall return the ID of the configuration.</para>
        <para>If the device does not have capacity for the configuration, the device shall produce a MaximumNumberOfDot1XConfigurationsReached fault and shall not add the configuration.</para>
        <para>If Identity is used as an anonymous identity for the corresponding authentication method, the device shall ignore an eventually supplied passphrase ID in the same Dot1XStage. Otherwise, if the device cannot process a passphrase ID included in the configuration to be added, the device shall produce a PassphraseID fault and shall not add the configuration.</para>
        <para>If the device cannot process a certification path ID included in the configuration to be added, the device shall produce a CertificationPathID fault and shall not add the configuration.</para>
        <para>If the device cannot process an authentication method included in the configuration to be added (e.g., unrecognized method or missing configuration parameter), the device shall produce a Dot1XMethod fault and shall not add the configuration.</para>
        <para>If the device cannot process the authentication method combination in the configuration to be added, the device shall produce a Dot1XMethodCombination fault and shall not add the configuration.</para>
        <para>A device signalling support for IEEE 802.1X configuration with the MaximumNumberOfDot1XConfigurations capability shall support this command.</para>
        <variablelist role="op">
          <varlistentry>
            <term>request</term>
            <listitem>
              <para role="param">Dot1XConfiguration - [tas:Dot1XConfiguration] </para>
              <para role="text">The desired 802.1X configuration.</para>
              <para role="param">Alias - optional [xs:string] </para>
              <para role="text">The client-defined alias of the 802.1X configuration.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>response</term>
            <listitem>
              <para role="param">Dot1XID - [tas:Dot1XID] </para>
              <para role="text">The unique identifier of the created 802.1X configuration.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>faults</term>
            <listitem>
              <para role="param">foo env:Receiver - ter:Action - ter:MaximumNumberOfDot1XConfigurationsReached </para>
              <para role="text">The device already has the number of configurations specified by MaximumNumberOfDot1XConfigurations.</para>
              <para role="param">env:Sender - ter:InvalidArgVal - ter:PassphraseID </para>
              <para role="text">A supplied passphrase ID cannot be processed by the device.</para>
              <para role="param">env:Sender - ter:InvalidArgVal - ter:CertificationPathID </para>
              <para role="text">A supplied certification path ID cannot be processed by the device.</para>
              <para role="param">env:Sender - ter:InvalidArgVal - ter: Dot1XMethod </para>
              <para role="text">A supplied IEEE 802.1X authentication method cannot be processed by the device.</para>
              <para role="param">env:Sender - ter:InvalidArgVal - ter: Dot1XMethodCombination </para>
              <para role="text">The combination of IEEE 802.1X authentication methods cannot be processed by the device.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>access class</term>
            <listitem>
              <para role="access">WRITE_SYSTEM</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section>
        <title>GetAllDot1XConfigurations</title>
        <para>This operation returns details of all IEEE 802.1X configurations that are on the device.  This operation may be used, e.g., if a client lost track of which IEEE 802.1X configurations are present on the device.</para>
        <para>If no IEEE 802.1X configurations exist on the device, an empty list is returned.</para>
        <para>A device signalling support for IEEE 802.1X configuration with the MaximumNumberOfDot1XConfigurations capability shall support this command.</para>
        <variablelist role="op">
          <varlistentry>
            <term>request</term>
            <listitem>
              <para role="text">This is an empty message.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>response</term>
            <listitem>
              <para role="param">Configuration - optional, unbounded [tas:Dot1XConfiguration] </para>
              <para role="text">The list of 802.1X configurations on the device.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>faults</term>
            <listitem>
              <para role="text">None</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>access class</term>
            <listitem>
              <para role="access">READ_SYSTEM_SECRET</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section>
        <title>GetDot1XConfiguration</title>
        <para>This operation returns details of a specific IEEE 802.1X configuration on the device.</para>
        <para>If the device cannot process the provided IEEE 802.1X configuration ID, the device shall produce a Dot1XConfigurationID fault.</para>
        <para>A device signalling support for IEEE 802.1X configuration with the MaximumNumberOfDot1XConfigurations capability shall support this command.</para>
        <variablelist role="op">
          <varlistentry>
            <term>request</term>
            <listitem>
              <para role="param">Dot1XID - [tas:Dot1XID] </para>
              <para role="text">The unique identifier of the desired 802.1X configuration.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>response</term>
            <listitem>
              <para role="param">Dot1XConfiguration - [tas:Dot1XConfiguration] </para>
              <para role="text">The 802.1X configuration, without password information.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>faults</term>
            <listitem>
              <para role="param">env:Sender - ter:InvalidArgVal - ter:Dot1XConfigurationID </para>
              <para role="text">The supplied IEEE 802.1X configuration ID cannot be processed by the device.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>access class</term>
            <listitem>
              <para role="access">READ_SYSTEM_SECRET</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section>
        <title>DeleteDot1XConfiguration</title>
        <para>This operation deletes an IEEE 802.1X configuration from the device.</para>
        <para>If the device cannot process the provided IEEE 802.1X configuration ID, the device shall produce a Dot1XConfigurationID fault.</para>
        <para>If a reference exists for the specified IEEE 802.1X configuration, the device shall produce a ReferenceExists fault and shall not delete the configuration.</para>
        <para>After an IEEE 802.1X configuration has been successfully deleted, the device may assign its former ID to a new configuration.</para>
        <para>A device signalling support for IEEE 802.1X configuration with the MaximumNumberOfDot1XConfigurations capability shall support this command.</para>
        <variablelist role="op">
          <varlistentry>
            <term>request</term>
            <listitem>
              <para role="param">Dot1XID - [tas:Dot1XID] </para>
              <para role="text">The unique identifier of the 802.1X configuration to be deleted.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>response</term>
            <listitem>
              <para role="text">This is an empty message.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>faults</term>
            <listitem>
              <para role="param">env:Sender - ter:InvalidArgVal - ter:Dot1XConfigurationID </para>
              <para role="text">The supplied IEEE 802.1X configuration ID cannot be processed by the device.</para>
              <para role="param">env:Sender - ter:InvalidArgVal - ter:ReferenceExists </para>
              <para role="text">A network interface reference exists for the specified IEEE 802.1X configuration.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>access class</term>
            <listitem>
              <para role="access">UNRECOVERABLE</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section>
        <title>SetNetworkInterfaceDot1XConfiguration</title>
        <para>This operation binds an IEEE 802.1X configuration to a network interface on the device.  This operation shall either create a new binding or replace an existing binding.  On failure when an existing binding already exists, the existing binding shall remain.</para>
        <para>The Device Management SetNetworkInterface operation provides a method of binding an IEEE 802.1X configuration to an IEEE 802.11 (wireless) interface, and that operation may still be used.  But there is no ability for SetNetworkInterface to bind an IEEE 802.1X configuration to a hardwired interface.  This operation is provided to bind an IEEE 802.1X configuration to either type of interface.</para>
        <para>If SetNetworkInterfaceDot1XConfiguration is used to bind an IEEE 802.1X configuration to an IEEE 802.11 (wireless) interface, then the DeviceManagement GetNetworkInterfaces operation shall return the IEEE 802.1X configuration ID along with the rest of that interface’s configuration information.</para>
        <para>If the device cannot process the provided network interface token, the device shall produce an InvalidNetworkInterface fault.</para>
        <para>If the device cannot process the provided IEEE 802.1X configuration ID, the device shall produce a Dot1XConfigurationID fault.</para>
        <para>A device signalling support for IEEE 802.1X configuration with the MaximumNumberOfDot1XConfigurations capability shall support this command.</para>
        <variablelist role="op">
          <varlistentry>
            <term>request</term>
            <listitem>
              <para role="param">token - [xs:string] </para>
              <para role="text">The unique identifier of the Network Interface on which the 802.1X configuration is to be set. (NOTE: the network interface token is defined in devicemgmt.wsdl as tt:ReferenceToken, which is a derived type of xs:string.  To avoid importing all of common.xsd for this single type, the base type is used here.)</para>
              <para role="param">Dot1XID - [tas:Dot1XID] </para>
              <para role="text">The unique identifier of the 802.1X configuration to be set.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>response</term>
            <listitem>
              <para role="param">RebootNeeded - [xs:boolean] </para>
              <para role="text">Indicates whether or not a reboot is required after configuration updates.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>faults</term>
            <listitem>
              <para role="param">env:Sender - ter:InvalidArgVal - ter:InvalidNetworkInterface </para>
              <para role="text">The supplied network interface token does not exist.</para>
              <para role="param">env:Sender - ter:InvalidArgVal - ter:Dot1XConfigurationID </para>
              <para role="text">The supplied IEEE 802.1X configuration ID cannot be processed by the device.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>access class</term>
            <listitem>
              <para role="access">WRITE_SYSTEM</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section>
        <title>GetNetworkInterfaceDot1XConfiguration</title>
        <para>This operation returns the IEEE 802.1X ID and configuration associated with a network interface on the device.  If there is no IEEE 802.1X configuration associated with the specified network interface, then the response shall be empty.</para>
        <para>If the Device Management SetNetworkInterface operation was used to bind an IEEE 802.1X configuration to an IEEE 802.11 (wireless) interface, then this operation shall return the IEEE 802.1X configuration information as if the SetNetworkInterfaceDot1XConfiguration operation had been used.</para>
        <para>If the device cannot process the provided network interface token, the device shall produce an InvalidNetworkInterface fault.</para>
        <para>A device signalling support for IEEE 802.1X configuration with the MaximumNumberOfDot1XConfigurations capability shall support this command.</para>
        <variablelist role="op">
          <varlistentry>
            <term>request</term>
            <listitem>
              <para role="param">token - [xs:string] </para>
              <para role="text">The unique identifier of the Network Interface for which the 802.1X configuration is to be retrieved.  (NOTE: the network interface token is defined in devicemgmt.wsdl as tt:ReferenceToken, which is a derived type of xs:string.  To avoid importing all of common.xsd for this single type, the base type is used here.)</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>response</term>
            <listitem>
              <para role="param">Dot1XID - optional [tas:Dot1XID] </para>
              <para role="text">The unique identifier of 802.1X configuration assigned to the Network Interface.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>faults</term>
            <listitem>
              <para role="param">env:Sender - ter:InvalidArgVal - ter:InvalidNetworkInterface </para>
              <para role="text">The supplied network interface token does not exist.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>access class</term>
            <listitem>
              <para role="access">READ_SYSTEM_SECRET</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section>
        <title>DeleteNetworkInterfaceDot1XConfiguration</title>
        <para>This operation unbinds the IEEE 802.1X configuration associated with a network interface on the device.  If there is no IEEE 802.1X configuration associated with the specified network interface, then the operation does nothing.</para>
        <para>The Device Management SetNetworkInterface operation provides a method of unbinding an IEEE 802.1X configuration from an IEEE 802.11 (wireless) interface by omitting the configuration ID, and that operation may still be used.  But there is no ability for SetNetworkInterface to unbind an IEEE 802.1X configuration from a hardwired interface.  This operation is provided to unbind an IEEE 802.1X configuration from either type of interface.</para>
        <para>If the Device Management SetNetworkInterface operation was used to bind an IEEE 802.1X configuration to an IEEE 802.11 (wireless) interface, then this operation shall unbind the IEEE 802.1X configuration information as if the SetNetworkInterfaceDot1XConfiguration operation had been used.</para>
        <para>If the device cannot process the provided network interface token, the device shall produce an InvalidNetworkInterface fault.</para>
        <para>A device signalling support for IEEE 802.1X configuration with the MaximumNumberOfDot1XConfigurations capability shall support this command.</para>
        <variablelist role="op">
          <varlistentry>
            <term>request</term>
            <listitem>
              <para role="param">token - [xs:string] </para>
              <para role="text">The unique identifier of the Network Interface for which the 802.1X configuration is to be deleted.  (NOTE: the network interface token is defined in devicemgmt.wsdl as tt:ReferenceToken, which is a derived type of xs:string.  To avoid importing all of common.xsd for this single type, the base type is used here.)</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>response</term>
            <listitem>
              <para role="param">RebootNeeded - [xs:boolean] </para>
              <para role="text">Indicates whether or not a reboot is required after configuration updates.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>faults</term>
            <listitem>
              <para role="param">env:Sender - ter:InvalidArgVal - ter:InvalidNetworkInterface </para>
              <para role="text">The supplied network interface token does not exist.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>access class</term>
            <listitem>
              <para role="access">WRITE_SYSTEM</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
    </section>
    <section>
      <title>Capabilities</title>
      <section>
        <title>GetServiceCapabilities</title>
        <para>The capabilities reflect optional functions and functionality of the different features in the security configuration service. The service capabilities consist of keystore capabilities and TLS server capabilities. The information is static and does not change during device operation.</para>
        <para>A device shall support this command.</para>
        <variablelist role="op">
          <varlistentry>
            <term>request</term>
            <listitem>
              <para role="text">This is an empty message.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>response</term>
            <listitem>
              <para role="param">Capabilities - [tas:Capabilities] </para>
              <para role="text">The capabilities for the security configuration service.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>faults</term>
            <listitem>
              <para role="text">None</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>access class</term>
            <listitem>
              <para role="access">PRE_AUTH</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section>
        <title>Keystore Capabilities</title>
        <para>The keystore capabilities reflect optional functions and functionality of the keystore on a device. The following capabilites are available: </para>
        <table>
          <title>Keystore Capabilities</title>
          <tgroup cols="2">
            <colspec colname="c1" colwidth="59*" />
            <colspec colname="c2" colwidth="41*" />
            <thead>
              <row>
                <entry>
                  <para>
                    <emphasis role="bold">Capability Name</emphasis>
                  </para>
                </entry>
                <entry>
                  <para>
                    <emphasis role="bold">Capability Semantics</emphasis>
                  </para>
                </entry>
              </row>
            </thead>
            <tbody valign="top">
              <row>
                <entry>
                  <para>MaximumNumberOfPassphrases</para>
                </entry>
                <entry>
                  <para>Indicates the maximum number of passphrases that the device is able to store simultaneously.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfKeys</para>
                </entry>
                <entry>
                  <para>Indicates the maximum number of keys that the device is able store simultaneously.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfCertificates</para>
                </entry>
                <entry>
                  <para>Indicates the maximum number of certificates that the device is able to store simultaneously.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfCertificationPaths</para>
                </entry>
                <entry>
                  <para>Indicates the maximum number of certificate paths that the device is able to store simultaneously.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>RSAKeyPairGeneration</para>
                </entry>
                <entry>
                  <para>Indicates support for on-board RSA key pair generation.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>RSAKeyLengths</para>
                </entry>
                <entry>
                  <para>Indicates which RSA key lengths are supported by the device.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>PKCS8RSAKeyPairUpload</para>
                </entry>
                <entry>
                  <para>Indicates support for uploading an RSA key pair in a PKCS#8 data structure.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>PKCS12CertificateWithRSAPrivateKeyUpload</para>
                </entry>
                <entry>
                  <para>Indicates support for uploading a certificate along with an RSA private key in a PKCS#12 data structure.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>PKCS10ExternalCertificationWithRSA</para>
                </entry>
                <entry>
                  <para>Indicates support for creating PKCS#10 requests for RSA keys and uploading the certificate obtained from a CA.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SelfSignedCertificateCreationWithRSA</para>
                </entry>
                <entry>
                  <para>Indicates support for creating self-signed certificates for RSA keys.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SignatureAlgorithms</para>
                </entry>
                <entry>
                  <para>Indicates which signature algorithms are supported by the device.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>PasswordBasedEncryptionAlgorithms</para>
                </entry>
                <entry>
                  <para>Indicates which password-based encryption algorithms are supported by the device.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>PasswordBasedMACAlgorithms</para>
                </entry>
                <entry>
                  <para>Indicates which password-based MAC algorithms are supported by the device.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>X.509Versions</para>
                </entry>
                <entry>
                  <para>Indicates which X.509 versions are supported by the device.<footnote xml:id="__FN2__"><para>If a device supports X.509v3 certificates, this fact shall also be signalled by this capability.</para></footnote> X.509 versions shall be encoded as version numbers, e.g., 1, 2, 3.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfCRLs</para>
                </entry>
                <entry>
                  <para>Indicates the maximum number of CRLs that the device is able to store simultaneously.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfCertificationPathValidationPolicies</para>
                </entry>
                <entry>
                  <para>Indicates the maximum number of certification path validation policies that the device is able to store simultaneously.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>EnforceTLSWebClientAuthExtKeyUsage</para>
                </entry>
                <entry>
                  <para>Indicates whether a device supports checking for the TLS WWW client auth extended key usage extension while validating certification paths.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>NoPrivateKeySharing</para>
                </entry>
                <entry>
                  <para>Indicates the device requires that each certificate with private key has its own unique key.</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>TLS Server Capabilities</title>
        <para>The TLS server capabilities reflect optional functions and functionality of the TLS server. The information is static and does not change during device operation. The following capabilites are available: </para>
        <table>
          <title>TLS Server Capabilities</title>
          <tgroup cols="2">
            <colspec colname="c1" colwidth="63*" />
            <colspec colname="c2" colwidth="37*" />
            <tbody valign="top">
              <row>
                <entry>
                  <para>TLSServerSupported</para>
                </entry>
                <entry>
                  <para>Indicates which TLS server versions are supported by the device. Server versions shall be encoded as version numbers, e.g., “1.0 1.1 1.2”.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfTLSCertificationPaths</para>
                </entry>
                <entry>
                  <para>Indicates the maximum number of certification paths that may be assigned to the TLS server simultaneously.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>TLSClientAuthSupported</para>
                </entry>
                <entry>
                  <para>Indicates whether the device supports TLS client authentication as defined in this specification.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CnMapsToUserSupported</para>
                </entry>
                <entry>
                  <para>Indicates whether the device supports TLS client authorization using common name to local user mapping as defined in this specification</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfTLSCertificationPathValidationPolicies</para>
                </entry>
                <entry>
                  <para>Indicates the maximum number of certification path validation policies that may be assigned to the TLS server simultaneously</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>EnabledVersionsSupported</para>
                </entry>
                <entry>
                  <para>Indicates whether the device supports enabling and disabling specific TLS versions.</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>IEEE 802.1X Capabilities</title>
        <para>The IEEE 802.1X configuration capabilities reflect optional functions and functionality of IEEE 802.1X configuration on a device. The following additional capabilites are defined: </para>
        <table>
          <title>Additional IEEE 802.1X Configuration Capabilities</title>
          <tgroup cols="2">
            <colspec colname="c1" colwidth="50*" />
            <colspec colname="c2" colwidth="50*" />
            <thead>
              <row>
                <entry>
                  <para>Capability Name</para>
                </entry>
                <entry>
                  <para>Capability Semantics</para>
                </entry>
              </row>
            </thead>
            <tbody valign="top">
              <row>
                <entry>
                  <para>MaximumNumberOfDot1XConfigurations</para>
                </entry>
                <entry>
                  <para>Indicates the maximum number of IEEE 802.1X configurations that the device is able to configure simultaneously.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Dot1XMethods</para>
                </entry>
                <entry>
                  <para>A list of authentication method outer/inner (phase1/phase2) combinations supported by the device.</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>Capability-implied Requirements</title>
        <para>
          <xref linkend="_Ref406569780" /> summarizes for each capability the minimum requirements that a device signaling this capability shall satisfy; it should not be seen as a recommendation.</para>
        <table xml:id="_Ref406569780">
          <title>Requirements implied by Capabilities</title>
          <tgroup cols="2">
            <colspec colname="c1" colwidth="32*" />
            <colspec colname="c2" colwidth="68*" />
            <thead>
              <row>
                <entry>
                  <para>Capability</para>
                </entry>
                <entry>
                  <para>Implied Requirements</para>
                </entry>
              </row>
            </thead>
            <tbody valign="top">
              <row>
                <entry>
                  <para>MaximumNumberOfPassphrases</para>
                </entry>
                <entry>
                  <para>If greater than zero, the following commands shall be supported:</para>
                  <itemizedlist>
                    <listitem>
                      <para>UploadPassphrase</para>
                    </listitem>
                    <listitem>
                      <para>GetAllPassphrases</para>
                    </listitem>
                    <listitem>
                      <para>DeletePassphrase</para>
                    </listitem>
                  </itemizedlist>
                  <para>If greater than zero, the device shall support passphrases that consist of characters from the ASCII character set and that have a length of up to 40 characters.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfKeys</para>
                </entry>
                <entry>
                  <para>If greater than zero, then the following commands shall be supported:</para>
                  <itemizedlist>
                    <listitem>
                      <para>GetKeyStatus</para>
                    </listitem>
                    <listitem>
                      <para>GetAllKeys</para>
                    </listitem>
                    <listitem>
                      <para>DeleteKey</para>
                    </listitem>
                  </itemizedlist>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfCertificates</para>
                </entry>
                <entry>
                  <para>If greater than zero, then MaximumNumberOfKeys&gt;0 shall hold.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfCertificationPaths</para>
                </entry>
                <entry>
                  <para>If greater than zero, MaximumNumberOfCertificates&gt;=2 shall hold.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>RSAKeyPairGeneration</para>
                </entry>
                <entry>
                  <para>If true, the following commands shall be supported:</para>
                  <itemizedlist>
                    <listitem>
                      <para>CreateRSAKeyPair</para>
                    </listitem>
                  </itemizedlist>
                  <para>If true, the list of supported RSA key lengths as indicated by the RSAKeyLenghts capability shall not be empty.</para>
                  <para>If true, MaximumNumberOfKeys&gt;0 shall hold.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>PKCS8RSAKeyPairUpload</para>
                </entry>
                <entry>
                  <para>If true, the following commands shall be supported:</para>
                  <itemizedlist>
                    <listitem>
                      <para>UploadKeyPairInPKCS8</para>
                    </listitem>
                  </itemizedlist>
                  <para>If true, MaximumNumberOfPassphrases &gt;0 shall hold.</para>
                  <para>If true, MaximumNumberOfKeys &gt; 0 shall hold.</para>
                  <para>If true, the list of supported RSA key lengths as indicated by the RSAKeyLenghts capability shall not be empty.</para>
                  <para>If true, the list of supported password-based encryption algorithms as indicated by the PasswordBasedEncryptionAlgorithms capability shall contain at least the algorithm <phrase>pbeWithSHAAnd3-KeyTripleDES-CBC</phrase>.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>PKCS12CertificateWithRSAPrivateKeyUpload</para>
                </entry>
                <entry>
                  <para>If true, the following commands shall be supported:</para>
                  <itemizedlist>
                    <listitem>
                      <para>UploadCertificateWithPrivateKeyInPKCS12</para>
                    </listitem>
                    <listitem>
                      <para>GetCertificate</para>
                    </listitem>
                    <listitem>
                      <para>GetAllCertificates</para>
                    </listitem>
                    <listitem>
                      <para>DeleteCertificate</para>
                    </listitem>
                    <listitem>
                      <para>GetCertificationPath</para>
                    </listitem>
                    <listitem>
                      <para>GetAllCertificationPaths</para>
                    </listitem>
                    <listitem>
                      <para>DeleteCertificationPath</para>
                    </listitem>
                  </itemizedlist>
                  <para>If true, MaximumNumberOfPassphrases &gt;0 shall hold.</para>
                  <para>If true, MaximumNumberOfKeys &gt;=2 shall hold.</para>
                  <para>If true, MaximumNumberOfCertificates &gt;=2 shall hold.</para>
                  <para>If true, MaximumNumberOfCertificattionPaths &gt;0 shall hold.</para>
                  <para>If true, the list of supported RSA key lengths as indicated by the RSAKeyLenghts capability shall not be empty.</para>
                  <para>If true, the list of supported password-based encryption algorithms as indicated by the PasswordBasedEncryptionAlgorithms capability shall contain at least the algorithm <phrase>pbeWithSHAAnd3-KeyTripleDES-CBC</phrase>.</para>
                  <para>If true, the list of supported password-based MAC algorithms as indicated by the PasswordBasedMACAlgorithms capability shall contain at least the algorithm <phrase>hmacWithSHA256</phrase>.</para>
                  <para>If true, the list of supported X.509 versions as indicated by the X.509Versions capability shall contain at least the value 3.</para>
                  <para>If true, the list of supported signature algorithms as indicated by the SignatureAlgorithms capability shall contain at least the algorithms sha1-WithRSAEncryption and sha256WithRSAEncryption.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>PKCS10ExternalCertificationWithRSA</para>
                </entry>
                <entry>
                  <para>If true, the following operations shall be supported:</para>
                  <itemizedlist>
                    <listitem>
                      <para>RSA key pair generation as signaled by the RSAKeyPairGeneration capability or RSA key pair upload as signaled by the PKCS8RSAKeyPairUpload capability or RSA key pair upload as signaled by the PKCS12CertificateWithRSAPrivateKeyUpload capability</para>
                    </listitem>
                    <listitem>
                      <para>Creating a CSR with the CreatePKCS10CSR command.</para>
                    </listitem>
                    <listitem>
                      <para>GetCertificate</para>
                    </listitem>
                    <listitem>
                      <para>GetAllCertificates</para>
                    </listitem>
                    <listitem>
                      <para>DeleteCertificate</para>
                    </listitem>
                    <listitem>
                      <para>Uploading the certificate created for the CSR as well as the certificate of the created certificate’s signer with the UploadCertificate command.</para>
                    </listitem>
                  </itemizedlist>
                  <para>If true, MaximumNumberOfCertificates&gt;=2 and MaximumNumberOfCertificationPaths&gt;0 shall hold.</para>
                  <para>If true, MaximumNumberOfKeys&gt;=2 shall hold.</para>
                  <para>If true, the list of supported signature algorithms as indicated by the SignatureAlgorithms capability shall contain at least the algorithms sha1-WithRSAEncryption and sha256WithRSAEncryption.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SelfSignedCertificateCreationWithRSA</para>
                </entry>
                <entry>
                  <para>If true, the following commands shall be supported:</para>
                  <itemizedlist>
                    <listitem>
                      <para>CreateSelfSignedCertificate</para>
                    </listitem>
                    <listitem>
                      <para>GetCertificate</para>
                    </listitem>
                    <listitem>
                      <para>GetAllCertificates</para>
                    </listitem>
                    <listitem>
                      <para>DeleteCertificate</para>
                    </listitem>
                  </itemizedlist>
                  <para>If true, the following operations shall be supported:</para>
                  <itemizedlist>
                    <listitem>
                      <para>RSA key pair generation as signaled by the RSAKeyPairGeneration capability or RSA key pair upload as signaled by the PKCS8RSAKeyPairUpload capability or RSA key pair upload as signaled by the PKCS12CertificateWithRSAPrivateKeyUpload capability</para>
                    </listitem>
                  </itemizedlist>
                  <para>If true, MaximumNumberOfCertificates&gt; 0 shall hold.</para>
                  <para>If true, the list of supported signature algorithms as indicated by the SignatureAlgorithms capability shall contain at least the algorithms sha1-WithRSAEncryption and sha256WithRSAEncryption.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>TLSServerSupported</para>
                </entry>
                <entry>
                  <para>If not empty, PKCS10ExternalCertificationWithRSA shall be true or SelfSignedCertificateCreationWithRSA shall be true.</para>
                  <para>If not empty, the following commands shall be supported:</para>
                  <itemizedlist>
                    <listitem>
                      <para>CreateCertificationPath</para>
                    </listitem>
                    <listitem>
                      <para>GetCertificationPath</para>
                    </listitem>
                    <listitem>
                      <para>GetAllCertificationPaths</para>
                    </listitem>
                    <listitem>
                      <para>DeleteCertificationPath</para>
                    </listitem>
                    <listitem>
                      <para>AddServerCertificateAssignment</para>
                    </listitem>
                    <listitem>
                      <para>RemoveServerCertificateAssignment</para>
                    </listitem>
                    <listitem>
                      <para>ReplaceServerCertificateAssignment</para>
                    </listitem>
                    <listitem>
                      <para>GetAssignedServerCertificates</para>
                    </listitem>
                  </itemizedlist>
                  <para>If not empty, MaximumNumberOfCertificationPaths&gt;=2 and MaximumNumberOfTLSCertificationPaths&gt;0 shall hold.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>TLSServerSupported and PKCS10ExternalCertificationWithRSA</para>
                </entry>
                <entry>
                  <para>If TLSServerSupported is non-empty and PKCS10ExternalCertificationWithRSA is true, MaximumNumberOfCertificates&gt;=3 shall hold.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfTLSCertificationPaths</para>
                </entry>
                <entry>
                  <para>If greater than zero, MaximumNumberOfCertificationPaths&gt;0 shall hold.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>EnabledVersionsSupported</para>
                </entry>
                <entry>
                  <para>If true, the following commands are supported:</para>
                  <itemizedlist>
                    <listitem>
                      <para>SetEnabledTLSVersions</para>
                    </listitem>
                    <listitem>
                      <para>GetEnabledTLSVersions</para>
                    </listitem>
                  </itemizedlist>
                </entry>
              </row>
              <row>
                <entry>
                  <para>X.509Versions</para>
                </entry>
                <entry>
                  <para>
                    <phrase>If X.509v3 is supported, the device shall support the distinguished name attribute types </phrase>
                    <emphasis>country</emphasis>, <emphasis>organization</emphasis>, <emphasis>organizational unit</emphasis>, <emphasis>distinguished name qualifier</emphasis>, <emphasis>state or province name</emphasis>, <emphasis>common name</emphasis>, and <emphasis>serial number</emphasis>.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfCRLs</para>
                </entry>
                <entry>
                  <para>If greater than zero, then the following commands shall be supported</para>
                  <itemizedlist>
                    <listitem>
                      <para>UploadCRL</para>
                    </listitem>
                    <listitem>
                      <para>GetCRL</para>
                    </listitem>
                    <listitem>
                      <para>GetAllCRLs</para>
                    </listitem>
                    <listitem>
                      <para>DeleteCRL</para>
                    </listitem>
                  </itemizedlist>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfCertificationPathValidationPolicies</para>
                </entry>
                <entry>
                  <para>If greater than zero, then the following command shall be supported</para>
                  <itemizedlist>
                    <listitem>
                      <para>CreateCertPathValidationPolicy</para>
                    </listitem>
                    <listitem>
                      <para>GetCertPathValidationPolicy</para>
                    </listitem>
                    <listitem>
                      <para>GetAllCertPathValidationPolicies</para>
                    </listitem>
                    <listitem>
                      <para>DeleteCertPathValidationPolicy</para>
                    </listitem>
                  </itemizedlist>
                  <para>If greater than zero, PKCS12CertificateWithRSAPrivateKeyUpload, PKCS10ExternalCertificationWithRSA or SelfSignedCertificateCreationWithRSA shall be true.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>TLSClientAuthSupported</para>
                </entry>
                <entry>
                  <para>If true, the following commands shall be supported</para>
                  <itemizedlist>
                    <listitem>
                      <para>SetClientAuthenticationRequired</para>
                    </listitem>
                    <listitem>
                      <para>GetClientAuthenticationRequired</para>
                    </listitem>
                    <listitem>
                      <para>AddCertPathValidationPolicyAssignment</para>
                    </listitem>
                    <listitem>
                      <para>RemoveCertPathValidationPolicyAssignment</para>
                    </listitem>
                    <listitem>
                      <para>ReplaceCertPathValidationPolicyAssignment</para>
                    </listitem>
                    <listitem>
                      <para>GetAssignedCertPathValidationPolicies</para>
                    </listitem>
                  </itemizedlist>
                  <para>If true, TLSServerSupported shall not be empty.</para>
                  <para>If true, MaximumNumberOfCertificationPathValidationPolicies&gt;=2 and MaximumNumberOfTLSCertificationPathValidationPolicies&gt;0 shall hold.</para>
                  <para>If true, MaximumNumberOfCRLs&gt;0 shall hold.</para>
                  <para>If true, the device shall support</para>
                  <itemizedlist>
                    <listitem>
                      <para>validating certification paths containing X.509v3 certificates that are signed with signatures of type sha1-WithRSAEncryption or with sha256WithRSAEncrpytion</para>
                    </listitem>
                    <listitem>
                      <para>processing X.509 CRLs that are compliant to the CRL profile defined in [RFC 5280], Sect. 5 and that</para>
                      <itemizedlist>
                        <listitem>
                          <para>are signed with signatures of type sha1-WithRSAEncryption or sha256WithRSAEncryption and</para>
                        </listitem>
                        <listitem>
                          <para>are complete direct CRLs as defined in [RFC 5280] that that are signed with the same signature key as the signature key that the CA uses to sign issued certificates</para>
                        </listitem>
                      </itemizedlist>
                    </listitem>
                  </itemizedlist>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfTLSCertificationPathValidationPolicies</para>
                </entry>
                <entry>
                  <para>If greater than zero, MaximumNumberOfCertificationPathValidationPolicies &gt;0 shall hold.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfDot1XConfigurations</para>
                </entry>
                <entry>
                  <para>If greater than zero, the following commands shall be supported:</para>
                  <itemizedlist>
                    <listitem>
                      <para>AddDot1XConfiguration</para>
                    </listitem>
                    <listitem>
                      <para>GetDot1XConfigurations</para>
                    </listitem>
                    <listitem>
                      <para>GetDot1XConfiguration</para>
                    </listitem>
                    <listitem>
                      <para>DeleteDot1XConfiguration</para>
                    </listitem>
                    <listitem>
                      <para>SetNetworkInterfaceDot1XConfiguration</para>
                    </listitem>
                    <listitem>
                      <para>GetNetworkInterfaceDot1XConfiguration</para>
                    </listitem>
                    <listitem>
                      <para>DeleteNetworkInterfaceDot1XConfiguration</para>
                    </listitem>
                  </itemizedlist>
                  <para>If greater than zero, the Dot1XMethods capability shall be present and shall contain at least the EAP-PEAP MSCHAPv2 method.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Dot1XMethods</para>
                </entry>
                <entry>
                  <para>If not empty, shall contain at least the “EAP-PEAP/MSCHAPv2” method, and MaximumNumberOfDot1XConfigurations shall be greater than zero.</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
    </section>
    <section>
      <title>Events</title>
      <section xml:id="_Ref353780603">
        <title>Key Status</title>
        <para>A device that indicates support for key handling via the MaximumNumberOfKeys capability shall provide information about key status changes through key status events.</para>
        <para>A device shall include an OldStatus value unless NewStatus is generating.</para>
        <programlisting><![CDATA[Topic: tns1:Advancedsecurity/Keystore/KeyStatus
<tt:MessageDescription>
  <tt:Source>
    <tt:SimpleItemDescription Name="KeyID" Type="tas:KeyID"/>
  </tt:Source>
  <tt:Data>
    <tt:SimpleItemDescriptionminOccurs=”0” Name="OldStatus" Type="tas:KeyStatus"/>
    <tt:SimpleItemDescription Name="NewStatus" Type="tas:KeyStatus"/>
  </tt:Data>
</tt:MessageDescription>
]]></programlisting>
      </section>
    </section>
    <section>
      <title>Service specific data types</title>
      <para>The service specific data types are defined in security.wsdl.</para>
    </section>
  </chapter>
  <chapter>
    <title>Security Considerations</title>
    <para>This section is informative.</para>
    <itemizedlist>
      <listitem>
        <para>Faults and their types shall not disclose sensitive information to an attacker that he could not obtain otherwise.</para>
      </listitem>
      <listitem>
        <para>For interoperability reasons, sha1WithRSAEncryption as specified in [RFC3279] is mandated as default signature algorithm. However, since the security of the SHA-1 algorithm is under question, this specification mandates that a signature algorithm based on SHA-256, particularly sha256WithRSAEncryption as specified in [RFC 4055], be supported in addition.</para>
      </listitem>
      <listitem>
        <para>Operations with arguments that need protection against eavesdropping or manipulation shall only be executed over sufficiently protected communication channels. </para>
      </listitem>
      <listitem>
        <para>It is good practice not to use the same key for different purposes. In order to prevent the device from using the same key for different purposes unnoticedly, this specification mandates that all keys in the keystore be distinct.</para>
      </listitem>
      <listitem>
        <para>Private keys must be protected against disclosure to unauthorized parties. If a private key is uploaded in an encrypted PKCS#8 or PKCS#12 structure, the passphrase that is used to encrypt the structure must be uploaded to the device over a communication channel that is protected against eavesdropping in order to preserve the confidentiality of the private key. Moreover, the confidentiality of the uploaded private key depends on the strength of the encryption passphrase. It is therefore strongly recommended to use random passwords with sufficient length.</para>
      </listitem>
      <listitem>
        <para>In general, externally generated keys must be regarded less trustworthy than keys that are generated by the device because the probability of being disclosed to an attacker is higher for an externally generated key than for an internally generated key. A client may determine whether a key was generated by the device from the <emphasis>externallyGenerated</emphasis> attribute of the key.</para>
      </listitem>
      <listitem>
        <para>While new specifications should be based on [PKCS#5 v2.0] or higher, adoption of this standard is still limited. Therefore, this specification intends to balance security and interoperability by mandating cryptographic algorithms based on [PKCS#5 v1.5] as interoperability baseline while strongly encouraging the use of [PKCS#5 v2.0] or higher. Future versions of this specification or specifications referring to this specification may mandate additional cryptographic algorithms.</para>
      </listitem>
      <listitem>
        <para>Although PKCS#8 [RFC 5208] is widely used for exchanging cryptographic keys, this specification is based on the successor standard [RFC 5958], particularly in order to incorporate both private key and public key in the same data structure.</para>
      </listitem>
      <listitem>
        <para>The default certification path validation policy is designed as a permissive interoperability baseline based on the certification path validation algorithm defined in [RFC 5280]. </para>
      </listitem>
      <listitem>
        <para>CRLs can be expected to be available from virtually any CA as a source of revocation information. The benefit of OCSP [RFC 6960] as a means to obtain revocation information is increasingly under question, since a man-in-the-middle attacker blocking OCSP traffic combined with a permissive validator that silently accepts certificates for which no revocation is available limits the effective security gain of using OCSP. Therefore, this specification mandates support for CRLs as interoperability baseline and leaves other revocation information sources to future versions.</para>
      </listitem>
      <listitem>
        <para>Devices may be required to use different trust anchors for different security features. Therefore, trust in a certificate is indicated as part of a certification path validation policy rather than globally, e.g., with an attribute of the X509Certificate data type. </para>
      </listitem>
      <listitem>
        <para>[RFC 5280], Sect. 6.1.4 (k) mandates that every certificate in a certification path except for the end entity certificate must be verified to be a CA certificate. For X.509 version 3 certificates, this is verified through the CA attribute in the basic constraints extension. For X.509 version 1 and 2 certificates, this information must be supplied by out-of-band mechanisms. Within the scope of this specification, the only means to obtain this information is the trust anchor information contained in the certification path validation algorithm. Therefore, the default certification path validation policy mandates that the certification path validation algorithm defined in Sect. <xref linkend="_Ref392600142" /> consider all certificates that are not marked as trust anchor as non-CA certificates.</para>
      </listitem>
      <listitem>
        <para>When configuring IEEE 802.1X, it is usually necessary to upload a password to the device’s keystore.  This should be done either on a private network (e.g., using a direct network connection between a laptop and a device) or using TLS (SSL) on the device to encrypt client / device traffic.</para>
      </listitem>
    </itemizedlist>
  </chapter>
  <chapter>
    <title>Design Rationale</title>
    <para>This section is informative.</para>
    <section>
      <title>General Design Goals</title>
      <para>The Security Configuration Service is designed for modularity and extensibility. Therefore, each security feature is encapsulated in a separate port type within the service. Later revisions of this specification may add port types to enhance the Security Configuration Service by additional security features.</para>
      <para>Within a security feature, capabilities indicate support for sub-features and configuration options. Later revisions of this specification may add additional sub-features to existing features and identify them by additional capabilities.</para>
      <para>Port types and capabilities enable devices to support well-defined subsets of this specification and to communicate this information to clients effectively.</para>
    </section>
    <section>
      <title>Keystore</title>
      <para>The keystore design assumes that passphrases are chosen by clients. Therefore, an operation for retrieving passphrases from a device is deliberately omitted. If client loses a previously uploaded passphrase, the client should create a new passphrase, upload the new passphrase to the device, and delete the old passphrase from the device.</para>
      <para>This specification deliberately deviates from the terminology in PKCS#8 and PKCS#12 by using the term ‘passphrase’ instead of ‘password’ in order to avoid confusion with the password that is assigned to ONVIF device users and the corresponding API in the ONVIF Device Management Service.</para>
      <para>The keystore design is based on the rationale that an RSA key pair is a special type of key pair and a key pair is a special type of key. Therefore, key-related operations in the keystore deliberately refer to the most generic possible type in this hierarchy. For example, the DeleteKey operation (see Sect. <xref linkend="_Ref363540841" />) refers to a key instead of a key pair or even an RSAKeyPair because it is applicable to all keys. On the other hand, the GetPrivateKeyStatus command refers to a key pair instead of a key, since this command is not meaningful for a key that is not a key pair, e.g., a symmetric key.</para>
      <para>While this revision of the keystore specification only supports RSA key pairs as key pairs, later revisions of this specification may add other types of key pairs or symmetric keys as special types of keys.</para>
      <para>Some interactions with the keystore, e.g., retrieving the private key for a public key that is contained in a certificate, are required device-internally, but need not be accessible to clients and may even, as in the above example, imply a security risk when made available outside the device. Such operations are therefore deliberately omitted from this specification.</para>
      <para>The certificate-based client authentication specification intends to balance security concerns, interoperability, and implementation effort in order to facilitate adoption. Therefore, the certification path validation algorithm defined in [RFC 5280] serves as interoperability baseline. The parameter values in the default certification path validation policy have been selected such that widely used implementations of the certification path validation algorithm can be used in their default configurations as much as permitted by the objective to provide an acceptable security baseline.</para>
      <para>At the same time, more fine grained customization of the default certification path validation behavior in future versions of this specification is enabled by an extensible CertValidationPolicyParameters data type and capabilities that indicate which configuration options a device supports. As an example, checking for the TLS WWW client authentication key usage extension in client certificates is included in this specification, which can be implemented with moderate effort on the device side (e.g., with the OpenSSL option –purpose sslclient). Customization options for other parameters of the certification path validation algorithm are deliberately left to future versions of this specification in order to limit the required initial implementation effort.</para>
      <para>In order to facilitate future extensions of this specification, the number of certification path validation policies that may be assigned to the TLS server simultaneously is not limited, but the certification path validation behavior is unspecified if more than one policy is assigned to the TLS server at the same time. Therefore, devices implementing this specification should limit the number of simultaneously assigned policies to one.</para>
    </section>
    <section>
      <title>TLS Server</title>
      <para>This revision of the Security Configuration Service Specification allows to manage assignments of certification paths to the TLS server on a device. It is permitted that a TLS server presents different certification paths to different clients, therefore more than one certification path may be assigned simultaneously to the TLS server to use as a server certificate.</para>
      <para>All other configuration of the TLS server on a device is outside the scope of this specification revision and may be addressed by later revisions of this document.</para>
    </section>
  </chapter>
  <appendix role="revhistory">
    <title>Revision History</title>
    <para />
  </appendix>
</book>
