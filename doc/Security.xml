<?xml version="1.0"?>
<?xml-stylesheet href="docbook.xsl" type="text/xsl" ?>
<book xmlns="http://docbook.org/ns/docbook" version="5.0">
  <info>
    <title>Security Service Specification</title>
    <titleabbrev>Security Configuration</titleabbrev>
    <releaseinfo>24.06</releaseinfo>
    <author>
      <orgname>ONVIF™</orgname>
      <uri>www.onvif.org</uri>
    </author>
    <pubdate>June 2024</pubdate>
    <mediaobject>
      <imageobject>
        <imagedata fileref="media/logo.png" contentwidth="60mm"/>
      </imageobject>
    </mediaobject>
    <copyright>
      <year>2008-2024</year>
      <holder>ONVIF™ All rights reserved.</holder>
    </copyright>
    <legalnotice>
      <para>Recipients of this document may copy, distribute, publish, or display this document so long as this copyright notice, license and disclaimer are retained with all copies of the document. No license is granted to modify this document.</para>
      <para>THIS DOCUMENT IS PROVIDED "AS IS," AND THE CORPORATION AND ITS MEMBERS AND THEIR AFFILIATES, MAKE NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, OR TITLE; THAT THE CONTENTS OF THIS DOCUMENT ARE SUITABLE FOR ANY PURPOSE; OR THAT THE IMPLEMENTATION OF SUCH CONTENTS WILL NOT INFRINGE ANY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS.</para>
      <para>IN NO EVENT WILL THE CORPORATION OR ITS MEMBERS OR THEIR AFFILIATES BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE OR CONSEQUENTIAL DAMAGES, ARISING OUT OF OR RELATING TO ANY USE OR DISTRIBUTION OF THIS DOCUMENT, WHETHER OR NOT (1) THE CORPORATION, MEMBERS OR THEIR AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES, OR (2) SUCH DAMAGES WERE REASONABLY FORESEEABLE, AND ARISING OUT OF OR RELATING TO ANY USE OR DISTRIBUTION OF THIS DOCUMENT.  THE FOREGOING DISCLAIMER AND LIMITATION ON LIABILITY DO NOT APPLY TO, INVALIDATE, OR LIMIT REPRESENTATIONS AND WARRANTIES MADE BY THE MEMBERS AND THEIR RESPECTIVE AFFILIATES TO THE CORPORATION AND OTHER MEMBERS IN CERTAIN WRITTEN POLICIES OF THE CORPORATION.</para>
    </legalnotice>
    <revhistory>
      <revision>
        <revnumber>1.0</revnumber>
        <date>Aug - 2013</date>
        <author>
          <personname>Dirk Stegemann</personname>
        </author>
        <revremark>Initial version</revremark>
      </revision>
      <revision>
        <revnumber>1.0.1</revnumber>
        <date>Dec - 2013</date>
        <author>
          <personname>Michio Hirai, </personname>
        </author>
        <author>
          <personname>Dirk Stegemann</personname>
        </author>
        <revremark>Change Request 1219, 1220, 1222, 1267, 1271, 1272, 1277</revremark>
      </revision>
      <revision>
        <revnumber>1.0.2</revnumber>
        <date>June - 2014</date>
        <author>
          <personname>Dirk Stegemann, Stefan Andersson</personname>
        </author>
        <revremark>Change Request 1268, 1276, 1349, 1350, 1351, 1352, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1390</revremark>
      </revision>
      <revision>
        <revnumber>1.1</revnumber>
        <date>Dec - 2014</date>
        <author>
          <personname>Dirk Stegemann</personname>
        </author>
        <revremark>Change Request 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1543, 1554</revremark>
      </revision>
      <revision>
        <revnumber>1.2</revnumber>
        <date>Jun - 2015</date>
        <author>
          <personname>Dirk Stegemann</personname>
        </author>
        <revremark>Change Request 1552, 1555, 1565, 1580, 1583, 1590, 1615, 1616, 1617, 1618, 1619. Added certificate-based client authentication</revremark>
      </revision>
      <revision>
        <revnumber>1.3</revnumber>
        <date>Feb-2016</date>
        <author>
          <personname>Stefan Andersson Steve Wolf</personname>
        </author>
        <revremark>Added IEEE 802.1X configuration</revremark>
      </revision>
      <revision>
        <revnumber> </revnumber>
        <date>Mar-2017</date>
        <author>
          <personname>Hans Busch</personname>
        </author>
        <revremark>Change Request 1843</revremark>
      </revision>
      <revision>
        <revnumber>18.06</revnumber>
        <date>Jun-2018</date>
        <author>
          <personname>Hiroyuki Sano</personname>
        </author>
        <revremark>Change Request 2240, 2259</revremark>
      </revision>
      <revision>
        <revnumber>18.12</revnumber>
        <date>Dec-2018</date>
        <author>
          <personname>Steve Wolf</personname>
        </author>
        <revremark>Change Request 2262, 2308</revremark>
      </revision>
      <revision>
        <revnumber>19.12</revnumber>
        <date>Dec-2019</date>
        <author>
          <personname>Davide Cristanelli</personname>
        </author>
        <revremark>Added Authorization of TLS authenticated connections</revremark>
      </revision>
      <revision>
        <revnumber>21.12</revnumber>
        <date>Dec-2021</date>
        <author>
          <personname>Oksana Tyushkina, Rick Boer</personname>
        </author>
        <revremark>Fix typo in commands names. Fix inconsistency in Security NoMatchingPrivateKey</revremark>
      </revision>
      <revision>
        <revnumber>22.06</revnumber>
        <date>June-2022</date>
        <author>
          <personname>Hans Busch</personname>
        </author>
        <revremark>Fix fault namespace prefix and remove requirement to accept missing MAC when passphrase is present.</revremark>
      </revision>
      <revision>
        <revnumber>22.12</revnumber>
        <date>Dec-2022</date>
        <author>
          <personname>Hans Busch</personname>
        </author>
        <revremark>Do not require to support multiple identical pathes. Remove CRL requirement on client authentication.</revremark>
      </revision>
      <revision>
        <revnumber>23.06</revnumber>
        <date>June-2023</date>
        <author>
          <personname>Hans Busch</personname>
        </author>
        <revremark>Remove requirement on passphrase support.</revremark>
      </revision>
      <revision>
        <revnumber>23.12</revnumber>
        <date>Dec-2023</date>
        <author>
          <personname>Ottavio Campana, Fredrik Svensson</personname>
        </author>
        <revremark>Added support for ECC cryptography, JSON Web Tokens, Authorization Servers using OAuth2 and OpenID Connect.</revremark>
      </revision>
      <revision>
        <revnumber>24.06</revnumber>
        <date>June-2024</date>
        <author>
          <personname>Sriram Bhetanabottla, Hans Busch</personname>
        </author>
        <revremark>Improve readability of section on authorization server. Move JWT example to annex.</revremark>
      </revision>
    </revhistory>
  </info>
  <chapter>
    <title>Scope</title>
    <para>This document defines the web service interface for ONVIF security configuration features such as a keystore and a TLS server on an ONVIF device.</para>
    <para>Web service usage is outside of the scope of this document. Please refer to the ONVIF core specification.</para>
  </chapter>
  <chapter>
    <title>Normative References</title>
    <para>Basic Security Profile Version 1.1 Committee Specification 01, OASIS Standard, 22 October 2004</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://docs.oasis-open.org/ws-brsp/BasicSecurityProfile/v1.1/cs01/BasicSecurityProfile-v1.1-cs01.pdf">https://docs.oasis-open.org/ws-brsp/BasicSecurityProfile/v1.1/cs01/BasicSecurityProfile-v1.1-cs01.pdf</link>&gt;</para>
    <para>IANA TLS Supported Groups, Elliptic curve groups</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-8"/>&gt;</para>
    <para>IEEE 802.1X, Port-Based Network Access Control</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://standards.ieee.org/getieee802/download/802.1X-2004.pdf">http://standards.ieee.org/getieee802/download/802.1X-2004.pdf</link>&gt;</para>
    <para>ONVIF Core Specification</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.onvif.org/specs/core/ONVIF-Core-Specification.pdf">http://www.onvif.org/specs/core/ONVIF-Core-Specification.pdf</link>&gt;</para>
    <para>IETF RFC 2246 The TLS Protocol Version 1.0</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc2246.txt">http://www.ietf.org/rfc/rfc2246.txt</link>&gt;</para>
    <para>IETF RFC 2898 PKCS#5 Password-based Cryptography Specification v2.0</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc2898.txt">http://www.ietf.org/rfc/rfc2898.txt</link>&gt;</para>
    <para>IETF RFC 2986 PKCS #10: Certification RequestSyntaxSpecification Version 1.7</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc2986.txt">http://www.ietf.org/rfc/rfc2986.txt</link>&gt;</para>
    <para>IETF RFC 3279 Algorithms and Identifiers for the Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc3279.txt">http://www.ietf.org/rfc/rfc3279.txt</link>&gt;</para>
    <para>IETF RFC 3447 Public Key Cryptography Standards #1: RSA Cryptography Specifications Version 2.1</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc3447.txt">http://www.ietf.org/rfc/rfc3447.txt</link>&gt;</para>
    <para>IETF RFC 4055 Additional Algorithms and Identifiers for RSA Cryptography for use in the Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc4055.txt">http://www.ietf.org/rfc/rfc4055.txt</link>&gt;</para>
    <para>IETF RFC 4346 The Transport Layer Security (TLS) Protocol Version 1.1</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc4346.txt">http://www.ietf.org/rfc/rfc4346.txt</link>&gt;</para>
    <para>IETF RFC 5208 Public-Key Cryptography Standards (PKCS) #8: Private-Key Information Syntax Specification v1.2</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc5208.txt">http://www.ietf.org/rfc/rfc5208.txt</link>&gt;</para>
    <para>IETF RFC 5246 The Transport Layer Security (TLS) Protocol Version 1.2</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc5246.txt">http://www.ietf.org/rfc/rfc5246.txt</link>&gt;</para>
    <para>IETF RFC 8422 Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS) Versions 1.2 and Earlier</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://www.ietf.org/rfc/rfc8422.txt">https://www.ietf.org/rfc/rfc8422.txt</link>&gt;</para>
    <para>IETF RFC 5280 Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc5280.txt">http://www.ietf.org/rfc/rfc5280.txt</link>&gt;</para>
    <para>IETF RFC 5958 Asymmetric Key Packages</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc5958.txt">http://www.ietf.org/rfc/rfc5958.txt</link>&gt;</para>
    <para>IETF RFC 5959 Algorithms for Asymmetric Key Package Content Type</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc5959.txt">http://www.ietf.org/rfc/rfc5959.txt</link>&gt;</para>
    <para>IETF RFC 6749 The OAuth 2.0 Authorization Framework</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc6749.txt">http://www.ietf.org/rfc/rfc6749.txt</link>&gt;</para>
    <para>IETF RFC 6750 The OAuth 2.0 Authorization Framework: Bearer Token Usage</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc6750.txt">http://www.ietf.org/rfc/rfc6750.txt</link>&gt;</para>
    <para>IETF RFC 7517 JSON Web Key (JWK)</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc7517.txt">http://www.ietf.org/rfc/rfc7517.txt</link>&gt;</para>
    <para>IETF RFC 7518 JSON Web Algorithms (JWA)</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc7518.txt">http://www.ietf.org/rfc/rfc7518.txt</link>&gt;</para>
    <para>IETF RFC 7519 JSON Web Token (JWT)</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc7519.txt">http://www.ietf.org/rfc/rfc7519.txt</link>&gt;</para>
    <para>IETF RFC 7643 System for Cross-domain Identity Management: Core Schema</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc7643.txt">http://www.ietf.org/rfc/rfc7643.txt</link>&gt;</para>
    <para>IETF RFC 8414 OAuth 2.0 Authorization Server Metadata</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc8414.txt">http://www.ietf.org/rfc/rfc8414.txt</link>&gt;</para>
    <para>IETF RFC 8705 OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc8705.txt">http://www.ietf.org/rfc/rfc8705.txt</link>&gt;</para>
    <para>Unified Modeling Language (UML) </para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.omg.org/spec/UML">http://www.omg.org/spec/UML</link>&gt;</para>
    <para>OpenID Connect Core</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://openid.net/specs/openid-connect-core-1_0.html">https://openid.net/specs/openid-connect-core-1_0.html</link>&gt;</para>
    <para>OpenID Connect Discovery</para>
    <para>&lt;<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://openid.net/specs/openid-connect-discovery-1_0.html">https://openid.net/specs/openid-connect-discovery-1_0.html</link>&gt;</para>
    <para>PKCS#5 Password-based Encryption Standard v1.5, RSA Laboratories, 1993</para>
    <para>PKCS#12: Personal Information Exchange Syntax v1.0, RSA Laboratories, 1999</para>
  </chapter>
  <chapter>
    <title>Terms and Definitions</title>
    <section>
      <title>Definitions</title>
      <informaltable>
        <tgroup cols="2">
          <colspec colname="c1" colwidth="17*"/>
          <colspec colname="c3" colwidth="79*"/>
          <tbody valign="top">
            <row>
              <entry>
                <para>Alias</para>
              </entry>
              <entry>
                <para>An alias is a name for an object on the device that is chosen by the client
                  and treated transparently by the device.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Certificate</para>
              </entry>
              <entry>
                <para>A certificate as used in this specification binds a public key to a subject
                  entity. The certificate is digitally signed by the certificate issuer (the
                  certification authority) to allow for verifying its authenticity.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Certification Authority</para>
              </entry>
              <entry>
                <para>A certification authority is an entity that issues certificates to subject
                  entities.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Certification Path</para>
              </entry>
              <entry>
                <para>A certification path is a sequence of certificates in which the signature of
                  each certificate except for the last certificate can be verified with the subject
                  public key in the next certificate in the sequence.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Certificate Revocation List</para>
              </entry>
              <entry>
                <para>A certificate revocation list is a digitally signed list of IDs of
                  certificates that have been revoked by the issuing CA.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Digital Signature</para>
              </entry>
              <entry>
                <para>A digital signature for an object allows to verify the object’s authenticity,
                  i.e., to check whether the object has in fact been created by the signer and has
                  not been modified afterwards. A digital signature is based on a key pair, where
                  the private key is used to create the signature and the public key is used for
                  verification of the signature.</para>
              </entry>
            </row>
            <row>
              <entry>ECC key pair</entry>
              <entry>A key pair that is accepted as input by the ECC algorithm.</entry>
            </row>
            <row>
              <entry>
                <para>Inner</para>
              </entry>
              <entry>
                <para>The authentication protocol used after having established a secure connection
                  using the outer authentication protocol. Also called Stage 2.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Key</para>
              </entry>
              <entry>
                <para>A key is an input to a cryptographic algorithm. Sufficient randomness of the
                  key is usually a necessary condition for the security of the algorithm. This
                  specification supports RSA key pairs as keys.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Key Pair</para>
              </entry>
              <entry>
                <para>A key that consists of a public key and (optionally) a private key.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Outer</para>
              </entry>
              <entry>
                <para>The initial authentication protocol used to establish a secure connection
                  between the device and the IEEE 802.1X authentication server. Also called Stage
                  1.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>Passphrase</para>
              </entry>
              <entry>
                <para>A secret string that is shared between two or more parties. A passphrase may
                  be used to derive keys.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>RSA key pair</para>
              </entry>
              <entry>
                <para>A key pair that is accepted as input by the RSA algorithm.</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>TLS Server</para>
              </entry>
              <entry>
                <para>TLS-enabled HTTP Server (HTTPS)</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
    <section>
      <title>Abbreviations</title>
      <variablelist>
        <varlistentry>
          <term>CA</term>
          <listitem><para>Certification Authority</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>CN</term>
          <listitem><para>Common Name</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>CRL</term>
          <listitem><para>Certificate Revocation List</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>CSR</term>
          <listitem><para>Certificate Signing Request (also called Certification Request)</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>EAP</term>
          <listitem><para>Extensible Authentication Protocol</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>ECC</term>
          <listitem>
            <para>Elliptic Curve Cryptography</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>HTTP</term>
          <listitem><para>Hypertext Transfer Protocol</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>IEEE</term>
          <listitem><para>Institute of Electrical and Electronics Engineers</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>JWS</term>
          <listitem><para>JSON Web Signature</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>JWT</term>
          <listitem><para>JSON Web Token</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>MAC</term>
          <listitem><para>Message Authentication Code</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>MD5</term>
          <listitem><para>Message Digest Algorithm 5</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>MSCHAPv2</term>
          <listitem><para>Microsoft’s Challenge Handshake Authentication Protocol version 2</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>PEAP</term>
          <listitem><para>Protected EAP</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>SCTP</term>
          <listitem><para>Stream Control Transmission Protocol</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>SHA</term>
          <listitem><para>Secure Hashing Algorithm</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>SSL</term>
          <listitem><para>Secure Socket Layer</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>TLS</term>
          <listitem><para>Transport Layer Security</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>TTLS</term>
          <listitem><para>Tunneled TLS</para></listitem>
        </varlistentry>
        <varlistentry>
          <term>WS</term>
          <listitem><para>Web Services</para></listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section>
      <title>Namespace</title>
      <para><xref linkend="namespaces"/> lists the namespaces references by this document.</para>
      <table xml:id="namespaces">
        <title>Referenced namespaces (with prefix)</title>
        <tgroup cols="2">
          <colspec colname="c1" colwidth="13*"/>
          <colspec colname="c2" colwidth="87*"/>
          <thead>
            <row>
              <entry>
                <para>Prefix</para>
              </entry>
              <entry>
                <para>Namespace URI</para>
              </entry>
            </row>
          </thead>
          <tbody valign="top">
            <row>
              <entry>
                <para>env</para>
              </entry>
              <entry>
                <para>http://www.w3.org/2003/05/soap-envelope</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>tas</para>
              </entry>
              <entry>
                <para>http://www.onvif.org/ver10/advancedsecurity/wsdl</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>ter</para>
              </entry>
              <entry>
                <para>http://www.onvif.org/ver10/error</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>tt</para>
              </entry>
              <entry>
                <para>http://www.onvif.org/ver10/schema</para>
              </entry>
            </row>
            <row>
              <entry>
                <para>xs </para>
              </entry>
              <entry>
                <para>http://www.w3.org/2001/XMLSchema</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </chapter>
  <chapter>
    <title>Overview</title>
    <section>
      <title>General Structure</title>
      <para>This specification covers the following security configuration features:</para>
      <itemizedlist>
        <listitem>
          <para>Keys and certificates management interface (keystore)</para>
        </listitem>
        <listitem>
          <para>TLS server configuration interface</para>
        </listitem>
        <listitem>
          <para>IEEE 802.1X</para>
        </listitem>
      </itemizedlist>
      <para>Basic security features such as user authentication based on WS UsernameToken and HTTP
        Authentication as well as a default access policy are specified in the ONVIF Core
        Specification as part of the device management service.</para>
      <para>WSDL for the Security Configuration Service is specified in &lt;<link
          xmlns:xlink="http://www.w3.org/1999/xlink"
          xlink:href="http://www.onvif.org/ver10/advancedsecurity/wsdl/security.wsdl"
          >http://www.onvif.org/ver10/advancedsecurity/wsdl/security.wsdl</link>&gt;.</para>
      <para>All sections in this specification are normative unless explicitly marked as
        informative.</para>
    </section>
    <section>
      <title>Certificate-based Client Authentication</title>
      <para>Devices can request the connecting client to include a so called client certificate by
        providing a list of accepted certificate issuers. During the initial TLS handshake the
        client proves with a signature that it posesses the private key of the certificate. The TLS
        server needs to verify the authenticity of the certificate by using certification path
        validation according to RFC 5280 as detailed out in the next sections.</para>
    </section>
    <section>
      <title>Certificate Path Verification</title>
        <section>
          <title>Certification Path Validation Algorithm Parameters</title>
          <para>By default, a device shall use the values defined in <xref linkend="_Ref395170314"/> for the algorithm parameters defined in RFC 5280, Sect. 6.1.1.</para>
          <table xml:id="_Ref395170314">
            <title>Default parameter values for the certification path validation algorithm</title>
            <tgroup cols="3">
              <colspec colname="c1" colwidth="25*"/>
              <colspec colname="c2" colwidth="14*"/>
              <colspec colname="c3" colwidth="61*"/>
              <thead>
                <row>
                  <entry>
                    <para>Parameter</para>
                  </entry>
                  <entry>
                    <para>Default </para>
                  </entry>
                  <entry>
                    <para>Default Value Semantics</para>
                  </entry>
                </row>
              </thead>
              <tbody valign="top">
                <row>
                  <entry>
                    <para>User-initial-policy-set</para>
                  </entry>
                  <entry>
                    <para>Any-policy</para>
                  </entry>
                  <entry>
                    <para>The device is not concerned about certificate policy.</para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>Initial-policy-mapping-inhibit</para>
                  </entry>
                  <entry>
                    <para>0</para>
                  </entry>
                  <entry>
                    <para>Policy mapping is not inhibited.</para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>Initial-explicit-policy</para>
                  </entry>
                  <entry>
                    <para>0</para>
                  </entry>
                  <entry>
                    <para>The prospective certification path does not have to be valid for at least one certificate policy in the user-initial-policy-set</para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>Initial-any-policy-inhibit</para>
                  </entry>
                  <entry>
                    <para>0</para>
                  </entry>
                  <entry>
                    <para>The any-policy identifier, if asserted in a certificate, does not have to be ignored</para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>Initial-permitted-subtrees</para>
                  </entry>
                  <entry>
                    <para>(not specified)</para>
                  </entry>
                  <entry>
                    <para>No restrictions on the subtree within which all subject names in every certificate in the prospective certification path must fall.</para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>Initial-excluded-subtrees</para>
                  </entry>
                  <entry>
                    <para>(not specified)</para>
                  </entry>
                  <entry>
                    <para>No restrictions on the subtree within which no subject names in any certificate in the prospective certification path may fall.</para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>CA-information-source-for-v1-and-v2</para>
                  </entry>
                  <entry>
                    <para>None</para>
                  </entry>
                  <entry>
                    <para>The device shall consider X.509 version 1 and version 2 certificates as non-CA certificates.</para>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </section>
        <section>
          <title> Revocation Status Checking </title>
          <para>By default, a device shall use the parameter values defined in <xref
            linkend="_Ref395170420"/> for the parameters specified in RFC 5280, section 6.3.1. For
          CRL processing see section 6.3.3 of RFC 5280.</para>
          <table xml:id="_Ref395170420">
            <title>Default parameter values for the revocation status checking algorithm</title>
            <tgroup cols="3">
              <colspec colname="c1" colwidth="33*"/>
              <colspec colname="c2" colwidth="14*"/>
              <colspec colname="c3" colwidth="53*"/>
              <thead>
                <row>
                  <entry>
                    <para>Parameter</para>
                  </entry>
                  <entry>
                    <para>Default </para>
                  </entry>
                  <entry>
                    <para>Default Value Semantics</para>
                  </entry>
                </row>
              </thead>
              <tbody valign="top">
                <row>
                  <entry>
                    <para>Use-deltas</para>
                  </entry>
                  <entry>
                    <para>False</para>
                  </entry>
                  <entry>
                    <para>Delta CRLs, if available, are applied to CRLs.</para>
                  </entry>
                </row>
                <row>
                  <entry>
                    <para>Relevant-reason-codes</para>
                  </entry>
                  <entry>
                    <para>All-reasons</para>
                  </entry>
                  <entry>
                    <para>The device considers a certificate revoked if it has been revoked for any reason defined in RFC 5280.</para>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </table>
          <para>By default, a device shall consider all trusted sources of revocation information that it has access to when determining the revocation status of a certificate. The device shall consider the certificate in question revoked if and only if at least one such source indicates that the certificate in question is revoked. If one such source is unavailable, the device shall behave as if this source had provided the reply UNDETERMINED.</para>
          <para>A device shall consider at least the CRLs that are present in the keystore of the device.</para>
          <para>By default, certificates that are considered revoked shall not be included in prospective certification paths.</para>
        </section>
        <section>
          <title>Trust Anchors</title>
          <para>The trust anchors assigned to the certification path validation policy shall be used as trust anchor input to the certification path validation algorithm specified in RFC 5280.</para>
        </section>
        <section>
          <title>Certificate Repository for constructing Certification Paths</title>
          <para>By default, the certification path validation shall consider all certificates in the
          keystore on the device when constructing prospective certification paths.</para>
        </section>
        <section>
          <title>Specific certification path validation parameters</title>
          <para>
            <xref linkend="_Ref395173040"/> defines additional certification path validation parameters.</para>
          <table xml:id="_Ref395173040">
            <title>Specific certification path validation parameters</title>
            <tgroup cols="3">
              <colspec colname="c1" colwidth="52*"/>
              <colspec colname="c2" colwidth="12*"/>
              <colspec colname="c3" colwidth="35*"/>
              <thead>
                <row>
                  <entry>
                    <para>Parameter</para>
                  </entry>
                  <entry>
                    <para>Default </para>
                  </entry>
                  <entry>
                    <para>Default Value Semantics</para>
                  </entry>
                </row>
              </thead>
              <tbody valign="top">
                <row>
                  <entry>
                    <para>RequireTLSWWWClientAuthExtendedKeyUsage</para>
                  </entry>
                  <entry>
                    <para>False</para>
                  </entry>
                  <entry>
                    <para>If true, a TLS server shall only allow TLS clients to connect that present a client certificate containing the Require WWW client auth extended key usage extension as specified in RFC 5280, Sect. 4.2.1.12.</para>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </section>
      </section>
    <section xml:id="_Ref395181339">
      <title>JWT-based client authorization</title>
      <section>
        <title>General</title>
      <para>Unlike with HTTP Digest and WS-UsernameToken authentication, this specification defines how to associate clients with the different User Levels as defined in the ONVIF Core Specification. Devices are not expected to have the user credentials stored in their memory, instead they will verify that the user has been correctly authenticated by a trusted service based on OpenID Connect and authorize accessing different functions, based on the claims presented in the supplied JWT. JWTs can be presented as headers in case of HTTPS or RTSP, or they can be embedded in SOAP messages, in the form of binary security tokens. In case JWTs are embedded in binary security tokens, their content is base64url-encoded according to RFC 7519.</para>
      <para>JWTs consists of three elements:</para>
      <para>
        <itemizedlist>
          <listitem>
            <para>JOSE header</para>
          </listitem>
          <listitem>
            <para>Payload</para>
          </listitem>
          <listitem>
            <para>Signature</para>
          </listitem>
        </itemizedlist>
      </para>
      <para>The JOSE header shall declare that the encoded object is a JSON Web Token by setting the <emphasis>typ</emphasis> parameter to <emphasis>JWT</emphasis>, and the JWT is a JWS that is signed using the algorithm identified by the <emphasis>alg</emphasis> claim with a value defined in RFC7518. Since the keystore does not support symmetric encryption, this specification only mandates asymmetric encryption.</para>
      <para>The JWT payload shall include the following standard claims:</para>
      <para>
        <itemizedlist>
          <listitem>
            <para><emphasis>iss</emphasis>: Issuer, the URI of the server that generated the JWT.</para>
          </listitem>
          <listitem>
            <para><emphasis>aud</emphasis>: Audience, a list of strings representing the recipients that the JWT is intended for. Each principal intended to process the JWT shall identify itself with a value in the audience claim. If the principal processing the claim does not identify itself with a value in the audience claim when this claim is present, then the JWT shall be rejected.</para>
          </listitem>
          <listitem>
            <para><emphasis>exp</emphasis>: Expiration Time.</para>
          </listitem>
          <listitem>
            <para><emphasis>nbf</emphasis>: Not before.</para>
          </listitem>
        </itemizedlist>
      </para>
      <para>For the <emphasis>exp</emphasis>, <emphasis>nbf</emphasis> claims, a device shall reject a token when the current time is not within the range of claims nbf and exp. It shall reject a token when at least one of the claims is missing.</para>
      <para>The JWT payload shall include the <emphasis>roles</emphasis> claim, as defined within RFC 7643:</para>
      <para>
        <itemizedlist>
          <listitem>
            <para><emphasis>roles</emphasis>: Access class. One of the authenticated classes of the default access policy prefixed with the string <emphasis>onvif:</emphasis>, i.e. "onvif:Administrator", "onvif:Operator" or "onvif:User" as defined also within the ONVIF Core Specification. This access level will be used to authorize access to the required function.</para>
          </listitem>
        </itemizedlist>
      </para>
      <para>The signature is evaluated by applying ECDSA using secp256r1 and SHA-256 hashing to the base64url-encoded header and payload, concatenated by a '.'</para>
      <programlisting>ECDSA-SHA256 (base64UrlEncode(header) + "." +
              base64UrlEncode(payload),
              secp256r1))</programlisting>
      <para>The evaluated signature is further appended to the encoded header and payload with a '.' separator, to get the final JWT. Appendix <xref linkend="_Ref460769599"/> demonstrates the construction or a JWT.</para>
      <para>The signature is used to protect the JWT data integrity and JWT source authenticity.</para>
      </section>
      <section>
        <title>Configuration</title>
        <para>The folowing parameters are defined:</para>
        <variablelist>
          <varlistentry>
            <term>Audiences</term>
            <listitem><para>One or more audience strings. A device shall reject a token if none of the provided strings matches.</para></listitem>
          </varlistentry>
          <varlistentry>
            <term>TrustedIssuer</term>
            <listitem><para>Optional list of trusted issuer metadata URIs. A device shall reject a token if the list is
                non-empty and the token does not match the information provided via one of the
                issuer metadata URIs.</para></listitem>
          </varlistentry>
          <varlistentry>
            <term>KeyID</term>
            <listitem><para>Optional list of  keys. A device shall reject a token if this list is non-empty and none of
                the provided keys can verify the signature.</para></listitem>
          </varlistentry>
          <varlistentry>
            <term>ValidationPolicy</term>
            <listitem><para>Optional cert path validation policies to verify trusted issuers. If this list is non-empty a
                device shall only accept trusted issuers with matching TLS server
                certificates.</para></listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section>
        <title>Usage of JWT-based client authentication over HTTP</title>
        <para>Since authentication tokens contain sensitive information that could be easily used to perform replay attacks, JWT-based client authentication shall not be used over unencrypted HTTP connections.</para>
      </section>
      <section>
        <title>Usage of JWT-based client authentication over HTTPS</title>
        <para>Usage JWT-based client authentication over HTTPS shall adhere to the Authorization Request header Field, as specified by RFC 6750. In case of authentication failure, ONVIF-compliant devices shall respond with the error codes specified by RFC 6750.</para>
      </section>
      <section>
        <title>Usage of JWT-based client authentication over SCTP</title>
        <para>In scenarios where a SCTP channel is used to exchange commands and responses between the device and the client, it is not possible to embed a JWT within a header. In this case, the JWT can be embedded in the Security Token of the SOAP message, as defined in the WS-Security Basic Security Profile.</para>
        <para>A client shall use both ValueType and EncodingType. The device shall reject any Binary Security Token not using both <emphasis>ValueType</emphasis> and <emphasis>EncodingType</emphasis>.</para>
        <para>The EncodingType attribute shall have the value of</para>
        <programlisting>http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#BinarySecurityToken</programlisting>
        <para>The ValueType attribute shall have the value of</para>
        <programlisting>urn:ietf:params:oauth:token-type:jwt</programlisting>
      </section>
      <section>
        <title>Usage of JWT-based client authentication over RTSP</title>
        <para>Since authentication tokens contain sensitive information that could be easily used to perform replay attacks, JWT-based client authentication shall be used with RTSP connections only when HTTPS transport is selected.</para>
      </section>
      <section>
        <title>Usage of JWT-based client authentication over RTSPS</title>
        <para>Since the RTSPS protocol is similar to HTTPS, JWT-based client authentication over RTSPS behaves in the same way as JWT-based client authentication over HTTPS.</para>
      </section>
    </section>
    <section>
      <title>IEEE 802.1X</title>
      <para>IEEE 802.1X is an IEEE standard for port based network access control for the purpose of providing authentication and authorization of the devices attached to LAN ports. It allows access to the LAN port to devices that are configured for access, and prevents access to the LAN port to devices that are not correctly configured.</para>
      <para>This specification recommends the adoption of IEEE 802.1X for port based authentication for wireless networks.</para>
      <para>This specification defines a set of commands to configure and manage a device’s IEEE 802.1X configurations, both for wireless and hardwired network interfaces.  It assumes that IEEE 802.1X configuration and reconfiguration is performed outside of the IEEE 802.1X-secured network.</para>
      <para>Many schema elements in this specification include Dot1X as shorthand for IEEE 802.1X.  This convention increases the readability of source code generated from the WSDL.</para>
    </section>
    <section xml:id="section_b4m_rs4_rwb">
      <title>Authorization Servers</title>
      <para>This section describes use of external authorization servers for authenticating users
        and controlling access to resources. It can be used for granting access to both the device
        itself and to external services, like cloud storage.</para>
      <para>Different approaches are explained for granting access to human users and for machine to
        machine authorization. Both approaches base on OAuth 2.0 as defined in RFC6749. OpenID
        Connect has been developed as an extension of OAuth 2.0 especially for granting access to
        human users.</para>
      <para>OAuth 2.0 defines a web API called "authorization endpoint" to retrieve tokens. Clients
        control the purpose via <emphasis>scope</emphasis> parameters.</para>
      <section xml:id="section_bcl_4zq_swb">
        <title>Device authentication and authorization</title>
        <para>Devices typically use the Oauth2 Client Credentials Grant Flow as specified by RFC6749
          to gain access to resources. The device (called a client in the OAuth2 Spec) authenticates
          itself at the authorization server according to one of the methods listed in <xref
            xmlns:xlink="http://www.w3.org/1999/xlink" linkend="table_smg_rzq_swb"/>. In case of
          success the authorization server responds to the request with an access token that
          authorizes access to the actual resource.</para>
        <para>The Client Credentials Flow is summarized in <xref linkend="_Ref350769589"/>.</para>
        <figure xml:id="_Ref350769589">
          <title>OpenID Connect client credentials flow for devices</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="media/Security/image7.svg" contentwidth="130mm"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>OAuth 2.0 client registration requires configuration of ClientId, ClientSecret, an
          authentication method according to <xref xmlns:xlink="http://www.w3.org/1999/xlink"
            linkend="table_smg_rzq_swb"/>plus server dependent supplemental parameters before the
          client can use the OAuth2.0 and OpenID Connect flow.</para>
      </section>
      <section xml:id="section_acl_4zq_swb">
        <title>User authentication and authorization</title>
        <para>This flow separates retrieval of access token in two steps to allow separation of
          authentication and authorization. Users can retrieve JWTs from an OpenID Connect server by
          authenticating and authorizing access to resources by following the OAuth2 Authorization
          Code Flow.</para>
        <para>The Authorization Code Flow is summarized in <xref linkend="_Ref350769588"/>.</para>
        <figure xml:id="_Ref350769588">
          <title>OpenID Connect authorization code flow for users</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="media/Security/image6.svg" contentwidth="130mm"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>A device can be setup to use JWTs obtained with this flow to allow access to its web
          interface for externally authenticated users. In that case an authorization server
          configuration with type OAuthAuthorizationCode or OIDC2AuthorizationCode should be
          created.</para>
        <para>Access to the device can be granted to users bearing either an ID Token or an Access
          Token, as long as the claims specified in <xref linkend="_Ref395181339"/> are
          present.</para>
        <para>Any request for ID tokens must include <emphasis>openid</emphasis> in the
            <emphasis>scope</emphasis> request parameter.</para>
      </section>
      <section xml:id="section_ccl_4zq_swb">
        <title>Authorization server configuration</title>
        <para>The following parameters are used when creating a configuration for an external
          authorization server.</para>
        <table xml:id="table_acv_rzq_swb">
          <title>Authorization server settings</title>
          <tgroup cols="2">
            <colspec colname="c1" colwidth="20*"/>
            <colspec colname="c2" colwidth="80*"/>
            <thead>
              <row>
                <entry>
                  <para>Setting</para>
                </entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody valign="top">
              <row>
                <entry>
                  <para>ServerUri</para>
                </entry>
                <entry>
                  <para>Authorization server address</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>ClientId</para>
                </entry>
                <entry>
                  <para>Client identifier issued by the authorization server</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>ClientSecret</para>
                </entry>
                <entry>
                  <para>Client secret used to authenticate with the authorization server</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Scope</para>
                </entry>
                <entry>
                  <para>The requested access scope(s)</para>
                </entry>
              </row>
              <row>
                <entry><para>KeyID</para></entry>
                <entry><para>Key identifier for the <emphasis>private_key_jwt</emphasis> authentication
                  method</para></entry>
              </row>
              <row>
                <entry><para>CertificateID</para></entry>
                <entry><para>Certificate identifier for the
                  <emphasis>self_signed_tls_client_auth</emphasis> and <emphasis>tls_client_auth</emphasis> authentication methods.</para></entry>
              </row>
              <row>
                <entry>
                  <para>Type</para>
                </entry>
                <entry>
                  <para>The type of configuration, see <xref
                      xmlns:xlink="http://www.w3.org/1999/xlink" linkend="table_ry3_fbr_swb"/> for
                    possible values.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>ClientAuth</para>
                </entry>
                <entry>
                  <para>The type of client authentication method to use, see <xref
                      xmlns:xlink="http://www.w3.org/1999/xlink" linkend="table_smg_rzq_swb"/> for
                    possible values.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CertPathValidationPolicyID</para>
                </entry>
                <entry>
                  <para>The unique identifier of the certification path validation policy to be
                    used for validating the server certificate</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <para>The following types of authorization server configurations are defined.</para>
        <table xml:id="table_ry3_fbr_swb">
          <title>Authorization server configuration types</title>
          <tgroup cols="2">
            <colspec colname="c1" colwidth="30*"/>
            <colspec colname="c2" colwidth="70*"/>
            <thead>
              <row>
                <entry>
                  <para>Method</para>
                </entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody valign="top">
              <row>
                <entry>
                  <para>OAuthAuthorizationCode</para>
                </entry>
                <entry>
                  <para>OAuth2 authorization code flow per RFC 6749.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>OAuthClientCredentials</para>
                </entry>
                <entry>
                  <para>OAuth2 client credentials grant flow per RFC 6749.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>OIDC2AuthorizationCode</para>
                </entry>
                <entry>
                  <para>OpenID Connect authorization code flow per Open ID Connect Core.</para>
                  <para>The ServerUri is used as metadata URI, where you can retrieve the endpoint
                    URIs for authorization, token and JWKS.</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <para>The following client authentication methods are defined.</para>
        <table xml:id="table_smg_rzq_swb">
          <title>Client authentication methods</title>
          <tgroup cols="2">
            <colspec colname="c1" colwidth="30*"/>
            <colspec colname="c2" colwidth="70*"/>
            <thead>
              <row>
                <entry>
                  <para>Method</para>
                </entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody valign="top">
              <row>
                <entry>
                  <para>client_secret_basic</para>
                </entry>
                <entry>
                  <para>Use HTTP Authorization header to specify client_secret, see RFC 6749</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>client_secret_post</para>
                </entry>
                <entry>
                  <para>Use HTTP POST body to specify client_secret, see RFC 6749</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>client_secret_jwt</para>
                </entry>
                <entry>
                  <para>Use a HMAC signed JWT using client_secret as shared secret during client
                    registration, see OpenID Connect Core</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>private_key_jwt</para>
                </entry>
                <entry>
                  <para>Use PKI signed JWT using private key, see OpenID Connect Core, public key
                    shared with authorization server during client registration</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>tls_client_auth</para>
                </entry>
                <entry>
                  <para>Use PKI certificate to authenticate, public key shared with authorization
                    server during client registration and X.509 certificate used to setup mTLS with
                    authorization server, see RFC 8705</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>self_signed_tls_client_auth</para>
                </entry>
                <entry>
                  <para>Use self-signed certificate to authenticate, public key shared with
                    authorization server during client registration and self signed certificate used
                    to setup mTLS with authorization server,see RFC 8705</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
    </section>
  </chapter>
  <chapter>
    <title>Security Configuration Service</title>
    <section>
      <title>General Structure</title>
      <para>This section covers the security features</para>
      <itemizedlist>
        <listitem>
          <para>Keystore</para>
        </listitem>
        <listitem>
          <para>TLS server</para>
        </listitem>
        <listitem>
          <para>IEEE 802.1X</para>
        </listitem>
      </itemizedlist>
      <para>The design and data model of the ONVIF Security Configuration Service is reflected in <xref linkend="_Ref350769587"/>.</para>
      <figure xml:id="_Ref350769587">
        <title>ONVIF Security Configuration Service UML Class Diagram</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="media/Security/image2.png" contentwidth="159.97mm"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
    <section>
      <title>Keystore</title>
      <section>
        <title>Elements of the Keystore</title>
        <para>The keystore security feature handles the storage and management of passphrases, keys, and certificates on an ONVIF device.</para>
        <para>The keystore specified in this document supports passphrases, keys, key pairs, RSA and ECC key pairs, which are particular types of key pairs, certificates, certification paths, certificate revocation lists, and certification path validation policies.</para>
        <para>The boolean attribute <emphasis>externallyGenerated</emphasis> of a key shall be true if and only if the key was generated outside the device.</para>
        <para>The boolean attribute <emphasis>securelyStored</emphasis> of a key shall be true if and only if the key is stored in a specially protected hardware component (e.g., a trusted platform module) inside the device.</para>
      </section>
      <section>
        <title>Unique Identifiers</title>
        <para>An ID is used to uniquely identify objects of a particular type in the keystore on a device, i.e., no two objects of the same type shall have the same ID at any time.</para>
        <para>Passphrases in the keystore shall be uniquely identified by passphrase IDs, keys shall be uniquely identified by key IDs, certificates shall be uniquely identified by certificate IDs, certification paths in the keystore shall be uniquely identified by certification path IDs, certificate revocation lists shall be uniquely identified by certificate revocation list IDs, certification path validation policies shall be uniquely identified by certification path validation policy IDs, and IEEE 802.1X configurations shall be uniquely identified by IEEE 802.1X configuration IDs.</para>
        <para>It shall be noted that while IDs within a specific type shall be unique, no requirement exists for the uniqueness of IDs across different types. For example, there may be a key and a certificate in the keystore that share the same ID.</para>
        <para>Devices may assign the ID of a deleted identified object to another, subsequently generated object. However, devices should avoid re-using IDs as long as possible to avoid race conditions on the client side.</para>
        <para>A client may supply an alias for passphrases, keys, certificates, certification paths, certificate revocation lists, certification path validation policies and IEEE 802.1X configurations upon creation, e.g., to facilitate recognizing the created object at a later time. The device shall treat such aliases as unstructured data.</para>
      </section>
      <section>
        <title>Uniqueness of Objects in the Keystore</title>
        <para>A device shall allow multiple copies of the same passphrase to be present in the keystore under different IDs simultaneously.</para>
        <para>A device shall allow multiple copies of the same certificate revocation list to be present in the keystore under different IDs, respectively.</para>
        <para>A device shall allow multiple copies of the same certification path validation policy to be present in the keystore under different IDs, respectively.</para>
        <para>A device shall allow multiple copies of the same IEEE 802.1X configuration to be present in the keystore under different IDs simultaneously.</para>
        <para>A device shall not allow multiple copies of the same key to be present in the keystore simultaneously.</para>
      </section>
      <section>
        <title>Referential Integrity</title>
        <para>The keystore design relies on associations between</para>
        <itemizedlist>
          <listitem>
            <para>Keys, especially key pairs, and certificates</para>
          </listitem>
          <listitem>
            <para>Public keys and private keys in key pairs</para>
          </listitem>
          <listitem>
            <para>Certificates and certification paths</para>
          </listitem>
          <listitem>
            <para>Keys and security features</para>
          </listitem>
          <listitem>
            <para>Certification paths and IEEE 802.1X configurations</para>
          </listitem>
          <listitem>
            <para>Passphrases and IEEE 802.1X configurations</para>
          </listitem>
          <listitem>
            <para>IEEE 802.1X configurations and security features</para>
          </listitem>
          <listitem>
            <para>Certificates and security features</para>
          </listitem>
          <listitem>
            <para>Certification path validation policies and certificates</para>
          </listitem>
          <listitem>
            <para>Certificate revocation lists and certificates</para>
          </listitem>
          <listitem>
            <para>Certification path validation policies and security features</para>
          </listitem>
        </itemizedlist>
        <para>A device shall enforce the following referential integrity rules for delete operations:</para>
        <itemizedlist>
          <listitem>
            <para>A key shall not be deleted if it is referenced by a certificate or a security feature.</para>
          </listitem>
          <listitem>
            <para>A certificate shall not be deleted if it is referenced by a certification path, a certificate revocation list, a certification path validation policy, or a security feature.</para>
          </listitem>
          <listitem>
            <para>A certification path shall not be deleted if it is referenced by an IEEE 802.1X configuration or a security feature.</para>
          </listitem>
          <listitem>
            <para>A passphrase shall not be deleted if it is referenced by an IEEE 802.1X configuration.</para>
          </listitem>
          <listitem>
            <para>A certification path validation policy shall not be deleted if it is referenced by a security feature.</para>
          </listitem>
          <listitem>
            <para>An IEEE 802.1X configuration shall not be deleted if it is referenced by a security feature.</para>
          </listitem>
        </itemizedlist>
        <para>This integrity rule may be enforced by the following mechanism. Reference counters are maintained for keys, certificates, certification paths, passphrases, and IEEE 802.1X configurations. Each time a reference to an object of these types is added, e.g., by associating a certificate to a key pair or assigning a key pair or certificate to a security feature, the reference counter of the object is incremented. Conversely, if a reference to an object is deleted, the reference counter of the referenced object is decremented. Deleting a key, certificate, or certification path is only permitted if the corresponding reference counter is equal to zero.</para>
        <para>A device shall enforce the following referential integrity rules for update operations:</para>
        <itemizedlist>
          <listitem>
            <para>
              <phrase>A key shall not be updated if it is referenced by a certificate or a security feature. However, </phrase>a private key may be added to an existing key pair if the private key matches the public key in the key pair. If a private key is about to be added to a key pair that already contains the private key to be added, the adding operation shall have no effect.</para>
          </listitem>
          <listitem>
            <para>A certificate shall not be updated if it is referenced by a certification path, a certificate revocation list, a certification path validation policy, or a security feature.</para>
          </listitem>
          <listitem>
            <para>A certification path validation policy shall not be updated if it is referenced by a security feature.</para>
          </listitem>
        </itemizedlist>
        <para>This specification omits APIs for modifying keys or certificates. If a key or certificate is to be updated, it has to be deleted and newly generated with the updated information. If other API exists that allows for modification of keys or certificates, special care shall be taken in order not to break the referential integrity rule.</para>
        <para>A device shall enforce the following invariants:</para>
        <itemizedlist>
          <listitem>
            <para>The private key and the public key in an asymmetric key pair in the keystore shall always match, i.e., the asymmetric operation under the public key is the inverse of the corresponding operation under the private key.</para>
          </listitem>
          <listitem>
            <para>The public key in a certificate in the keystore and the public key in an associated key pair in the keystore shall always be equal for all associated key pairs.</para>
          </listitem>
        </itemizedlist>
      </section>
      <section xml:id="_Ref353728108">
        <title>Key Status</title>
        <para>A key in the keystore is always in exactly one of the following states:</para>
        <itemizedlist>
          <listitem>
            <para>
              <emphasis>ok</emphasis> (The key is ready to be used)</para>
          </listitem>
          <listitem>
            <para>
              <emphasis>generating</emphasis> (The key is being generated and not yet ready for use)</para>
          </listitem>
          <listitem>
            <para>
              <emphasis>corrupt</emphasis> (The key is corrupt and shall not be used, e.g., because it was not properly generated or a hardware fault corrupted a key that was ready to be used)</para>
          </listitem>
        </itemizedlist>
      </section>
      <section>
        <title>Keystore Operations</title>
        <section>
          <title>Passphrase Management</title>
          <section>
            <title>UploadPassphrase</title>
            <para>This operation uploads a passphrase to the keystore of the device.</para>
            <para>Passphrases are uniquely identified using passphrase IDs. The device shall generate a new passphrase ID for the uploaded passphrase.</para>
            <para>If the command was successful, the device shall return the ID of the uploaded passphrase.</para>
            <para>If the device does not have enough storage capacity for storing the passphrase to be uploaded, the device shall produce a maximum number of passphrases reached fault and shall not upload the supplied passphrase.</para>
            <para>If the device cannot process the passphrase to be uploaded, the device shall produce a BadPassphrase fault and shall not upload a passphrase.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">Passphrase - [xs:string] </para>
                  <para role="text">The passphrase to upload.</para>
                  <para role="param">PassphraseAlias - optional [xs:string]</para>
                  <para role="text"> The alias for the passphrase to upload.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">PassphraseID - [tas:PassphraseID]</para>
                  <para role="text"> The PassphraseID of the uploaded passphrase.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Receiver - ter:Action - ter:MaximumNumberOfPassphrasesReached</para>
                  <para role="text"> The device does not have enough storage space to store the passphrase to be uploaded.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:BadPassphrase</para>
                  <para role="text"> The provided passphrase cannot be processed by the device.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">WRITE_SYSTEM</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>GetAllPassphrases</title>
            <para>This operation returns information about all passphrases that are stored in the keystore of the device.</para>
            <para>This operation may be used, e.g., if a client lost track of which passphrases are present on the device.</para>
            <para>If no passphrase is stored on the device, the device shall return an empty list.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="text">This message is empty.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">PassphraseAttribute - optional, unbounded [tas:PassphraseAttribute]</para>
                  <para role="text"> List of passphrase attributes.  Each attribute contains information about a passphrase in the keystore.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="text">None</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">READ_SYSTEM_SECRET</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>DeletePassphrase</title>
            <para>This operation deletes a passphrase from the keystore of the device.</para>
            <para>Passphrases are uniquely identified using passphrase IDs. If no passphrase is stored under the requested passphrase ID in the keystore, a device shall produce an invalid passphrase ID fault. If there is a passphrase under the requested passphrase ID stored in the keystore and the passphrase could not be deleted, a device shall produce a passphrase deletion failed fault.</para>
            <para>After a passphrase is successfully deleted, the device may assign its former ID to other passphrases.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">PassphraseID - [tas:PassphraseID]</para>
                  <para role="text"> The ID of the passphrase that is to be deleted from the keystore.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="text">This message is empty.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Receiver - ter:Action - ter:PassphraseDeletionFailed</para>
                  <para role="text"> Deleting the passphrase with the requested PassphraseID failed.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:PassphraseID</para>
                  <para role="text"> No passphrase is stored under the requested PassphraseID.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">UNRECOVERABLE</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
        </section>
        <section>
          <title>Key Management</title>
          <section>
            <title>CreateRSAKeyPair</title>
            <para>This operation triggers the asynchronous generation of an RSA key pair of a particular keylength (specified as the number of bits) as specified in RFC 3447, with a suitable key generation mechanism on the device. Keys, especially RSA key pairs, are uniquely identified using key IDs. </para>
            <para>If the device does not have enough storage capacity for storing the key pair to be created, the maximum number of keys reached fault shall be produced and no key pair shall be generated. Otherwise, the operation generates a keyID for the new key and associates the <emphasis>generating</emphasis> status to it. Immediately after key generation has started, the device shall return the keyID to the client and continue to generate the key pair. The client may query the device with the GetKeyStatus operation (see Sect. <xref linkend="_Ref361388129"/>) whether the generation has finished. The client may also subscribe to Key Status events (see Sect. <xref linkend="_Ref353780603"/>) to be notified about key status changes.</para>
            <para>The device also returns a best-effort estimate of how much time it requires to create the key pair.<footnote xml:id="__FN1__"><para>Implementors may estimate the key generation time for a fixed key length as the average elapsed time of a number of key generation operations for this key length.</para></footnote> A client may use this information as an indication how long to wait before querying the device whether key generation is completed.</para>
            <para>After the key has been successfully created, the device shall assign it the <emphasis>ok</emphasis> status. If the key generation fails, the device shall assign the key the <emphasis>corrupt</emphasis> status.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">KeyLength - [xs:nonNegativeInteger]</para>
                  <para role="text"> The length of the key to be created.</para>
                  <para role="param">Alias - optional [xs:string] </para>
                  <para role="text">The client-defined alias of the key.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">KeyID - [tas:KeyID]</para>
                  <para role="text"> The key ID of the key pair being generated.</para>
                  <para role="param">EstimatedCreationTime - [xs:duration]</para>
                  <para role="text"> Best-effort estimation of how long the key generation will take.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Receiver - ter:Action - ter:MaximumNumberOfKeysReached</para>
                  <para role="text"> The keystore does not have enough storage space to store the key pair that has to be generated.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:KeyLength</para>
                  <para role="text"> The specified key length is not supported by the device.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">WRITE_SYSTEM</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>CreateECCKeyPair</title>
            <para>This operation triggers the asynchronous generation of an ECC key pair using a particular elliptic curve as specified in RFC 8422, with a suitable key generation mechanism on the device. Keys, especially ECC key pairs, are uniquely identified using key IDs. </para>
            <para>If the device does not have enough storage capacity for storing the key pair to be created, the maximum number of keys reached fault shall be produced and no key pair shall be generated. Otherwise, the operation generates a keyID for the new key and associates the <emphasis>generating</emphasis> status to it. Immediately after key generation has started, the device shall return the keyID to the client and continue to generate the key pair. The client may query the device with the GetKeyStatus operation (see Sect. <xref linkend="_Ref361388129"/>) whether the generation has finished. The client may also subscribe to Key Status events (see Sect. <xref linkend="_Ref353780603"/>) to be notified about key status changes.</para>
            <para>The device also returns a best-effort estimate of how much time it requires to create the key pair.<footnote xml:id="__FN3__"><para>Implementors may estimate the key generation time for a fixed key length as the average elapsed time of a number of key generation operations for this key length.</para></footnote> A client may use this information as an indication how long to wait before querying the device whether key generation is completed.</para>
            <para>After the key has been successfully created, the device shall assign it the <emphasis>ok</emphasis> status. If the key generation fails, the device shall assign the key the <emphasis>corrupt</emphasis> status.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">EllipticCurve - [xs:string]</para>
                  <para role="text"> The name of the elliptic curve to be used for generating the ECC keypair. Supported curve names can be found in the IANA TLS Supported Groups section, under the <emphasis>Description</emphasis> field.</para>
                  <para role="param">Alias - optional [xs:string] </para>
                  <para role="text">The client-defined alias of the key.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">KeyID - [tas:KeyID]</para>
                  <para role="text"> The key ID of the key pair being generated.</para>
                  <para role="param">EstimatedCreationTime - [xs:duration]</para>
                  <para role="text"> Best-effort estimation of how long the key generation will take.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Receiver - ter:Action - ter:MaximumNumberOfKeysReached</para>
                  <para role="text"> The keystore does not have enough storage space to store the key pair that has to be generated.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:UnsupportedEllipticCurve</para>
                  <para role="text"> The specified elliptic curve is not supported by the device.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">WRITE_SYSTEM</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>UploadKeyPairInPKCS8</title>
            <para>This operation uploads a key pair in a PKCS#8 data structure as specified in [RFC 5958, RFC 5959]. </para>
            <para>If a passphrase is either directly provided or as ID reference to a previously
              uploaded passphrase, the device shall assume that the KeyPair parameter contains an
              EncryptedPrivateKeyInfo ASN.1 structure that is encrypted with the given passphrase.
              In case neither a passphrase nor a passphrase ID is provided the device shall assume
              that the KeyPair parameter contains a OneAsymmetricKey ASN.1 structure which contains
              both the private key and the corresponding public key. </para>
            <para>If the supplied key pair cannot be processed by the device, the device shall produce an UnsupportedPublicKeyAlgorithm fault and shall not store the uploaded key pair in the keystore.</para>
            <para>Key pairs are uniquely identified using key IDs. If a key pair exists in the keystore with the public key equal to the public key in the request and this key pair does not contain a private key, the device shall add the supplied private key to the existing key pair and return the ID of this key pair.</para>
            <para>If a key pair exists in the keystore with the public key equal to the public key in the request and this key pair contains a private key, the device shall leave the key pair unchanged and return the ID of this key pair.</para>
            <para>If the existing key pair does not have status <emphasis>ok</emphasis>, the device shall produce an InvalidKeyStatus fault and shall not modify the existing key pair.</para>
            <para>If no key pair exists in the keystore with the public key equal to the public key in the request, the device shall generate a new key pair with the supplied private key and the supplied public key, status <emphasis>ok</emphasis> and the externally generated attribute set to <emphasis>true</emphasis>. Furthermore, the device shall return the ID of this key pair.</para>
            <para>If a new key pair is created, the device shall assign the supplied alias to it. Otherwise, the device shall ignore an eventually supplied alias.</para>
            <para>If decryption of the EncryptedPrivateKeyInfo failed, the device shall produce a DecryptionFailed fault and shall not store the uploaded key pair in the keystore.</para>
            <para>If the device does not have enough storage capacity for storing the key pair that eventually has to be created, the device shall generate a maximum number of keys reached fault. Furthermore the device shall not generate a key pair.</para>
            <para>If no passphrase exists under the ID specified by EncryptionPassphraseID, the device shall produce an invalid passphrase ID fault and shall not store the uploaded key pair in the keystore.</para>
            <para>If the supplied PKCS#8 data structure cannot be processed by the device, the device shall produce a BadPKCS8File fault and shall not store the uploaded key pair in the keystore.</para>
            <para>If the public key in the uploaded key pair does not match the uploaded private key, the device shall produce a PublicPrivateKeyMismatch fault and shall not store the uploaded key pair in the keystore.</para>
            <para>If the command was successful, the device shall return the ID of the key pair in the keystore that contains the supplied public and private key.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">KeyPair - [tas:Base64DERencodedASN1Value]</para>
                  <para role="text"> The key pair to be uploaded in a PKCS#8 data structure.</para>
                  <para role="param">Alias - optional [xs:string]</para>
                  <para role="text"> The client-defined alias of the key pair.</para>
                  <para role="param">EncryptionPassphraseID - optional [tas:PassphraseID]</para>
                  <para role="text"> The ID of the passphrase to use for decrypting the uploaded key pair.</para>
                  <para role="param">EncryptionPassphrase - optional [xs:string]</para>
                  <para role="text"> The passphrase to use for decrypting the uploaded key pair.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">KeyID - [tas:KeyID]</para>
                  <para role="text"> The key ID of the uploaded key pair.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Receiver - ter:Action - ter:MaximumNumberOfKeysReached</para>
                  <para role="text"> The device does not have enough storage space to store the key pair to be uploaded.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:PassphraseID</para>
                  <para role="text"> No passphrase is stored under the requested PassphraseID.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:DecryptionFailed</para>
                  <para role="text"> The given date could not be decrypted.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:UnsupportedPublicKeyAlgorithm</para>
                  <para role="text"> The public key algorithm of the supplied key pair is not supported by the device.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:InvalidKeyStatus</para>
                  <para role="text"> The key with the requested KeyID has an inappropriate status.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:BadPKCS8File</para>
                  <para role="text"> The PKCS#8 data structure cannot be processed by the device.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:PublicPrivateKeyMismatch</para>
                  <para role="text"> The supplied private key does not match the supplied public key.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">WRITE_SYSTEM</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section xml:id="_Ref361388129">
            <title>GetKeyStatus</title>
            <para>This operation returns the status of a key as defined in Sect. <xref linkend="_Ref353728108"/>.</para>
            <para>Keys are uniquely identified using key IDs. If no key is stored under the requested key ID in the keystore, an InvalidKeyID fault is produced. Otherwise, the status of the key is returned.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">KeyID - [tas:KeyID]</para>
                  <para role="text"> The ID of the key for which to return the status.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">KeyStatus - [xs:string]</para>
                  <para role="text"> Status of the requested key.  The value should be one of the values in the tas:KeyStatus enumeration.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:KeyID</para>
                  <para role="text"> No key is stored under the requested KeyID.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">READ_SYSTEM_SECRET</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>GetPrivateKeyStatus (deprecated)</title>
            <para>This operation returns whether a key pair contains a private key.</para>
            <para>Keys are uniquely identified using key IDs. If no key is stored under the requested key ID in the keystore, an invalid key ID fault shall be produced. If a key is stored under the requested key ID in the keystore, but this key is not a key pair, an invalid key type fault shall be produced.</para>
            <para>Otherwise, this operation returns <emphasis>true</emphasis> if the key pair identified by the key ID contains a private key, and <emphasis>false</emphasis> otherwise.</para>
            <para>This command is deprecated. Use GetAllKeys (see Sect. <xref linkend="_Ref415492349"/>) instead.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">KeyID - [tas:KeyID]</para>
                  <para role="text"> The ID of the key pair for which to return whether it contains a private key.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">hasPrivateKey - [xs:boolean]</para>
                  <para role="text"> True if and only if the key pair contains a private key.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:KeyID</para>
                  <para role="text"> No key is stored under the requested KeyID.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:InvalidKeyType</para>
                  <para role="text"> The key stored in the keystore under the requested KeyID is of an invalid type.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">READ_SYSTEM_SECRET</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section xml:id="_Ref415492349">
            <title>GetAllKeys</title>
            <para>This operation returns information about all keys that are stored in the device’s keystore.</para>
            <para>This operation may be used, e.g., if a client lost track of which keys are present on the device.</para>
            <para>If no key is stored on the device, an empty list is returned.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="text">This message is empty.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">KeyAttribute - optional, unbounded [tas:KeyAttribute]</para>
                  <para role="text"> List of key attributes.  Each attribute contains information about a key in the keystore.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="text">None</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">READ_SYSTEM_SECRET</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section xml:id="_Ref363540841">
            <title>DeleteKey</title>
            <para>This operation deletes a key from the device’s keystore.</para>
            <para>Keys are uniquely identified using key IDs. If no key is stored under the requested key ID in the keystore, a device shall produce an InvalidArgVal fault. If a reference exists for the specified key, a device shall produce the corresponding fault and shall not delete the key. If there is a key under the requested key ID stored in the keystore and the key could not be deleted, a device shall produce a KeyDeletion fault. If the key has the status <emphasis>generating</emphasis>, a device shall abort the generation of the key and delete from the keystore all data generated for this key.</para>
            <para>After a key is successfully deleted, the device may assign its former ID to other keys.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">KeyID - [tas:KeyID]</para>
                  <para role="text"> The ID of the key that is to be deleted from the keystore.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="text">This message is empty.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">ter:Receiver - ter:Action - ter:KeyDeletionFailed</para>
                  <para role="text"> Deleting the key with the requested KeyID failed.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:KeyID</para>
                  <para role="text"> No key is stored under the requested KeyID.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:ReferenceExists</para>
                  <para role="text"> A reference exists for the object that is to be deleted.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">UNRECOVERABLE</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
        </section>
        <section>
          <title>Certificate Management</title>
          <section>
            <title>CreatePKCS10CSR</title>
            <para>This operation generates a DER-encoded PKCS#10 v1.7 certification request (sometimes also called certificate signing request or CSR) as specified in RFC 2986 for a public key on the device. </para>
            <para>The key pair that contains the public key for which a certification request shall be produced is specified by its key ID. If no key is stored under the requested KeyID or the key specified by the requested KeyID is not an asymmetric key pair, an invalid key ID fault shall be produced and no CSR shall be generated.</para>
            <para>The subject parameter describes the entity that the public key belongs to. Additional attributes can be included in the attribute parameter.</para>
            <para>Distinguished name attribute values shall be supplied either in UTF-8 or in hexadecimal form as specified in RFC 4514.</para>
            <para>If the distinguished name attribute value is supplied in hexadecimal form, the device shall encode the attribute in the format given in the hexadecimal format.</para>
            <para>If the distinguished name attribute value is supplied in UTF-8 and the attribute value has a uniquely defined encoding (e.g., CountryName is defined as PrintableString), the device shall encode the attribute as the defined encoding. Otherwise, the device shall encode the attribute value as UTF-8.</para>
            <para>The signature algorithm parameter determines which signature algorithm shall be used for signing the certification request with the public key specified by the key ID parameter. If the specified signature algorithm is not supported by the device, an UnsupportedSignatureAlgorithm fault shall be produced and no CSR shall be generated. If the public key identified by the requested Key ID is an invalid input to the specified signature algorithm, a KeySignatureAlgorithmMismatch fault shall be produced and no CSR shall be generated. If the specified subject is invalid or incomplete, a Subject invalid fault shall be produced and no CSR shall be created. If an attribute is invalid or incomplete, an Attribute invalid fault shall be produced and no CSR shall be generated.</para>
            <para>If the key pair does not have status <emphasis>ok</emphasis>, a device shall produce an InvalidKeyStatus fault and no CSR shall be generated.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">Subject - [tas:DistinguishedName]</para>
                  <para role="text"> The subject to be included in the CSR.</para>
                  <para role="param">KeyID - [tas:KeyID]</para>
                  <para role="text"> The ID of the key for which the CSR shall be created.</para>
                  <para role="param">CSRAttribute - optional, unbounded [tas:CSRAttribute]</para>
                  <para role="text"> List of CSR attributes.  Each attribute contains an attribute to be included in the CSR.</para>
                  <para role="param">SignatureAlgorithm - [tas:AlgorithmIdentifier] </para>
                  <para role="text">The signature algorithm to be used to sign the CSR.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">PKCS10CSR - [tas:Base64DERencodedASN1Value]</para>
                  <para role="text"> The DER encoded PKCS#10 certification request.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">ter:Receiver - ter:Action - CSRCreationFailed</para>
                  <para role="text"> The generation of the PKCS#10 certification request failed.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:KeyID</para>
                  <para role="text"> No key is stored under the requested KeyID.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:UnsupportedSignatureAlgorithm</para>
                  <para role="text"> The specified signature algorithm is not supported by the device.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:KeySignatureAlgorithmMismatch</para>
                  <para role="text"> The specified public key is an invalid input to the specified signature algorithm.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:InvalidKeyStatus</para>
                  <para role="text"> The key with the requested KeyID has an inappropriate status.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:InvalidSubject</para>
                  <para role="text"> The specified subject is invalid or incomplete.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:InvalidAttribute</para>
                  <para role="text"> The specified attribute is invalid or incomplete.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">READ_SYSTEM</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>CreateSelfSignedCertificate</title>
            <para>This operation generates for a public key on the device a self-signed X.509 certificate that complies to RFC 5280. </para>
            <para>The X509Version parameter specifies the version of X.509 that the generated certificate shall comply to. A device that supports this command shall support the generation of X.509v3 certificates as specified in RFC 5280 and may additionally be able to handle other X.509 certificate formats as indicated by the X.509Versions capability. If no X509Version is specified in the request, the device shall produce an X.509v3 certificate.</para>
            <para>The key pair that contains the public key for which a self-signed certificate shall be produced is specified by its key pair ID. The subject parameter describes the entity that the public key belongs to.</para>
            <para>If the key pair does not have status <emphasis>ok</emphasis>, a device shall produce an InvalidKeyStatus fault and no certificate shall be generated.</para>
            <para>If the specified subject is invalid or incomplete, an InvalidSubject fault shall be produced and no certificate shall be created.</para>
            <para>The notValidBefore parameter specifies at which point in time the validity period of the generated certificate shall begin. If this parameter is not specified in the request, the device shall use its current time or a time before its current time as starting point of the validity period. The notValidAfter parameter specifies at which point in time the validity period of the generated certificate shall end. If this parameter is not specified in the request, the device shall assign the GeneralizedTime value of 99991231235959Z as specified in RFC 5280 to the notValidAfter parameter. If the notValidBefore parameter is invalid, an invalid DateTime fault shall be produced and no certificate shall be generated. If the notValidAfter parameter is invalid, an invalid DateTime fault shall be produced and no certificate shall be generated.</para>
            <para>The signature algorithm parameter determines which signature algorithm shall be used for signing the certification request with the public key specified by the key ID parameter.</para>
            <para>The Extensions parameter specifies potential X509v3 extensions that shall be contained in the certificate. A device that supports this command shall support the extensions that are defined in RFC5280, Sect. 4.2 as mandatory for CAs that issue self-signed certificates.</para>
            <para>Distinguished name attribute values shall be supplied either in UTF-8 or in hexadecimal form as specified in RFC 4514.</para>
            <para>If the distinguished name attribute value is supplied in hexadecimal form, the device shall encode the attribute in the format given in the hexadecimal format.</para>
            <para>If the distinguished name attribute value is supplied in UTF-8 and the attribute value has a uniquely defined encoding (e.g., CountryName is defined as PrintableString), the device shall encode the attribute as the defined encoding. Otherwise, the device shall encode the attribute value as UTF-8.</para>
            <para>RFC 5280, Sect. 4.1.2.2 mandates that the certificate serial numbers be unique for each certificate issued by a given issuer (a CA). Since the subject is equal to the issuer in a self-signed certificate, the serial number shall be unique for each self-signed certificate that the device issues for a given subject.</para>
            <para>The generated certificate shall not contain a unique identifier as specified in RFC 5280, Sect. 4.1.2.8. The device shall not mark the generated certificate as trusted.</para>
            <para>Certificates are uniquely identified using certificate IDs. If the command was successful, the device generates a new ID for the generated certificate and returns this ID.</para>
            <para>If the device does not have enough storage capacity for storing the certificate to be created, the maximum number of certificates reached fault shall be produced and no certificate shall be generated.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">X509Version - optional [xs:positiveInteger]</para>
                  <para role="text"> The X.509 version that the generated certificate shall comply to.</para>
                  <para role="param">Subject - [tas:DistinguishedName]</para>
                  <para role="text"> Distinguished name of the entity that the certificate shall belong to.</para>
                  <para role="param">KeyID - [tas:KeyID]</para>
                  <para role="text"> The ID of the key for which the certificate shall be created.</para>
                  <para role="param">Alias - optional [xs:string]</para>
                  <para role="text"> The client-defined alias of the certificate to be created.</para>
                  <para role="param">notValidBefore - optional [xs:dateTime]</para>
                  <para role="text"> The X.509 not valid before information to be included in the certificate.  Defaults to a time equal to or before the device’s current time.</para>
                  <para role="param">notValidAfter - optional [xs:dateTime]</para>
                  <para role="text"> The X.509 not valid after information to be included in the certificate.  Defaults to the time 99991231235959Z as specified in RFC 5280.</para>
                  <para role="param">SignatureAlgorithm - [tas:AlgorithmIdentifier]</para>
                  <para role="text"> The signature algorithm to be used for signing the certificate.</para>
                  <para role="param">Extension - optional, unbounded [tas:X509v3Extension]</para>
                  <para role="text"> List of X.509v3 extensions to be included in the certificate.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">CertificateID - [tas:CertificateID]</para>
                  <para role="text"> The ID of the generated certificate.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">ter:Receiver - ter:Action - ter:CertificateCreationFailed</para>
                  <para role="text"> The generation of the self-signed certificate failed.</para>
                  <para role="param">ter:Receiver - ter:Action - ter:MaximumNumberOfCertificatesReached</para>
                  <para role="text"> The device does not have enough storage space to store the certificate to be created.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:UnsupportedX509Version</para>
                  <para role="text"> The specified X.509 version is not supported by the device.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:KeyID</para>
                  <para role="text"> No key is stored under the requested KeyID.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:UnsupportedSignatureAlgorithm</para>
                  <para role="text">The specified signature algorithm is not supported by the device.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:KeySignatureAlgorithmMismatch</para>
                  <para role="text"> The specified public key is an invalid input to the specified signature algorithm.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:X509VersionExtensionsMismatch</para>
                  <para role="text"> The request contains extensions which are not supported by the X509Version in the request.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:InvalidKeyStatus</para>
                  <para role="text"> The key with the requested KeyID has an inappropriate status.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:InvalidSubject</para>
                  <para role="text"> The specified subject is invalid or incomplete.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:InvalidDateTime</para>
                  <para role="text"> A specified date Time is invalid.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">WRITE_SYSTEM</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>UploadCertificate</title>
            <para>This operation uploads an X.509 certificate as specified by RFC 5280 in DER encoding and the public key in the certificate to a device’s keystore. A device that supports this command shall be able to handle X.509v3 certificates as specified in RFC 5280 and may additionally be able to handle other X.509 certificate formats as indicated by the X.509Versions capability. </para>
            <para>Certificates are uniquely identified using certificate IDs, and key pairs are uniquely identified using key IDs. The device shall generate a new certificate ID for the uploaded certificate.</para>
            <para>Certain certificate usages, e.g. TLS server authentication, require the private key that corresponds to the public key in the certificate to be present in the keystore. In such cases, the client may indicate that it expects the device to produce a fault if the matching private key for the uploaded certificate is not present in the keystore by setting the PrivateKeyRequired argument in the upload request to <emphasis>true</emphasis>.</para>
            <para>The uploaded certificate has to be linked to a key pair in the keystore.</para>
            <para>If no private key is required for the public key in the certificate and a key pair exists in the keystore with a public key equal to the public key in the certificate, the uploaded certificate is linked to the key pair identified by the supplied key ID by adding a reference from the certificate to the key pair.</para>
            <para>If no private key is required for the public key in the certificate and no key pair exists with the public key equal to the public key in the certificate, a new key pair with status <emphasis>ok </emphasis>is created with the public key from the certificate, and this key pair is linked to the uploaded certificate by adding a reference from the certificate to the key pair.</para>
            <para>If a private key is required for the public key in the certificate, and a key pair exists in the keystore with a private key that matches the public key in the certificate, the uploaded certificate is linked to this key pair by adding a reference from the certificate to the key pair. If a private key is required for the public key and no such keypair exists in the keystore, then NoMatchingPrivateKey fault shall be produced and the certificate shall not be stored in the keystore.</para>
            <para>The device shall assign the supplied Alias to the uploaded certificate.</para>
            <para>If a new key pair is generated, the device shall assign the supplied KeyAlias to it. Otherwise, the device shall ignore an eventually supplied KeyAlias.</para>
            <para>How the link between the uploaded certificate and a key pair is established is illustrated in <xref linkend="_Ref338934863"/>.</para>
            <figure xml:id="_Ref338934863">
              <title>Link establishment between certificate and key pair for Upload Certificate</title>
              <mediaobject>
                <imageobject>
                  <imagedata fileref="media/Security/image3.png" contentwidth="159.70mm"/>
                </imageobject>
              </mediaobject>
            </figure>
            <para>If the key pair that the certificate shall be linked to does not have status <emphasis>ok</emphasis>, an InvalidKeyStatus fault is produced, and the uploaded certificate is not stored in the keystore.</para>
            <para>If the signature algorithm that the signature of the supplied certificate is based on is not supported by the device, the device shall generate an UnsupportedSignatureAlgorithm fault and shall not store the uploaded certificate nor the contained public key in the keystore.</para>
            <para>If the device cannot process the uploaded certificate, a BadCertificate fault is produced and neither the uploaded certificate nor the public key are stored in the device’s keystore. The BadCertificate fault shall not be produced based on the mere fact that the device’s current time lies outside the interval defined by the notBefore and notAfter fields as specified by RFC 5280, Sect. 4.1.</para>
            <para>The device shall not mark the uploaded certificate as trusted.</para>
            <para>If the device does not have enough storage capacity for storing the certificate to be uploaded, the maximum number of certificates reached fault shall be produced and no certificate shall be uploaded.</para>
            <para>If the device does not have enough storage capacity for storing the key pair that eventually has to be created, the device shall generate a maximum number of keys reached fault. Furthermore the device shall not generate a key pair and no certificate shall be stored.</para>
            <para>If the command was successful, the device returns the ID of the uploaded certificate and the ID of the key pair that contains the public key in the certificate.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">Certificate - [tas:Base64DERencodedASN1Value] </para>
                  <para role="text">The base64-encoded DER representation of the X.509 certificate to be uploaded.</para>
                  <para role="param">Alias - optional [xs:string]</para>
                  <para role="text"> The client-defined alias of the certificate.</para>
                  <para role="param">KeyAlias - optional [xs:string]</para>
                  <para role="text"> The client-defined alias of the key pair.</para>
                  <para role="param">PrivateKeyRequired - optional [xs:boolean]</para>
                  <para role="text"> Indicates if the device shall verify that a matching key pair with a private key exists in the keystore.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">CertificateID - [tas:CertificateID]</para>
                  <para role="text"> The ID of the uploaded certificate.</para>
                  <para role="param">KeyID - [tas:KeyID]</para>
                  <para role="text"> The ID of the key that the uploaded certificate certifies.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">ter:Receiver - ter:Action - ter:MaximumNumberOfCertificatesReached</para>
                  <para role="text"> The device does not have enough storage space to store the certificate to be uploaded.</para>
                  <para role="param">ter:Receiver - ter:Action - ter:MaximumNumberOfKeysReached</para>
                  <para role="text"> The device does not have enough storage space to store the key pair to be uploaded.</para>
                  <para role="param">ter:Receiver - ter:Action - ter:NoMatchingPrivateKey </para>
                  <para role="text">The keystore does not contain a key pair with a private key that matches the public key in the uploaded certificate.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:BadCertificate </para>
                  <para role="text">The supplied certificate file cannot be processed by the device.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:UnsupportedPublicKeyAlgorithm</para>
                  <para role="text"> The public key algorithm of the public key in the certificate is not supported by the device.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:UnsupportedSignatureAlgorithm</para>
                  <para role="text"> The specified signature algorithm is not supported by the device.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:InvalidKeyStatus</para>
                  <para role="text"> The key pair has an inappropriate status.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:Duplicate</para>
                  <para role="text"> The certificate already exists.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">WRITE_SYSTEM</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>UploadCertificateWithPrivateKeyInPKCS12</title>
            <para>This operation uploads a certification path consisting of X.509 certificates as specified by RFC 5280 in DER encoding along with a private key to a device’s keystore. Certificates and private key are supplied in the form of a PKCS#12 file as specified in PKCS#12.</para>
            <para>The device shall support PKCS#12 files that contain the following safe bags:</para>
            <itemizedlist>
              <listitem>
                <para>one or more instances of CertBag PKCS#12, Sect. 4.2.3</para>
              </listitem>
              <listitem>
                <para>either exactly one instance of KeyBag PKCS#12, Sect. 4.3.1 or exactly one instance of PKCS8ShroudedKeyBag PKCS#12, Sect. 4.2.2.</para>
              </listitem>
            </itemizedlist>
            <para>If the IgnoreAdditionalCertificates parameter has the value <emphasis>true</emphasis>, the device shall behave as if the client had supplied only the first CertBag in the sequence of CertBag instances.</para>
            <para>The device shall support PKCS#12 passphrase integrity mode for integrity protection of the PKCS#12 PFX as specified in PKCS#12, Sect. 4. The device shall support PKCS8ShroudedKeyBags that are encrypted with the same passphrase as the CertBag instances.</para>
            <para>If an integrity passphrase ID is supplied, the device shall use the corresponding passphrase in the keystore to check the integrity of the supplied PKCS#12 PFX. If an integrity passphrase ID is supplied, but the supplied PKCS#12 PFX has no integrity protection, the device shall produce a BadPKCS12File fault and shall not store the uploaded certificates nor the uploaded key pair in the keystore.</para>
            <para>If an encryption passphrase ID is supplied, the device shall use the corresponding passphrase in the keystore to decrypt the PKCS8ShroudedKeyBag and the CertBag instances.</para>
            <para>If an EncryptionPassphraseID is supplied, but a CertBag is not encrypted, the device shall ignore the supplied EncryptionPassphraseID when processing this CertBag. If an EncryptionPassphraseID is supplied, but a KeyBag is provided instead of a PKCS8ShroudedKeyBag, the device shall ignore the supplied EncryptionPassphraseID when processing the KeyBag.</para>
            <para>If a passphrase is supplied, the device shall ignore an eventually supplied integrity passphrase ID and an eventually supplied encryption passphrase ID, and the device shall use the supplied passphrase to check the integrity of the PKCS#12 PFX and to decrypt the PKCS8ShroudedKeyBag and the CertBag instances. If a passphrase is supplied, but a CertBag is not encrypted, the device shall ignore the supplied passphrase when processing this CertBag. If a passphrase is supplied, but a KeyBag is supplied instead of a PKCS8ShroudedKeyBag, the device shall ignore the supplied passphrase when processing the KeyBag.</para>
            <para>If decryption of either the PKCS8ShroudedKeyBag or an encrypted CertBag failed, the device shall produce a DecryptionFailed fault and shall not store the uploaded certificates nor key pair in the keystore.</para>
            <para>If the signature algorithm of a supplied certificate is not supported by the device, the device shall produce an UnsupportedSignatureAlgorithm fault and shall not upload a certificate nor key pair.</para>
            <para>If the supplied key pair cannot be processed by the device, the device shall produce an UnsupportedPublicKeyAlgorithm fault and shall not store the uploaded key pair nor the uploaded certificates in the keystore.</para>
            <para>Certificates are uniquely identified using certificate IDs. The device shall store the uploaded certificates in the keystore and generate a new certificate ID for each of the uploaded certificates.</para>
            <para>Certification paths are uniquely identified using certification path IDs. The device shall create a certification path from the uploaded certificates. In this certification path, the certificates shall appear in the same order as in the PKCS#12 file. The device shall generate a new certification path ID for the created certification path and assign the eventually supplied CertificationPathAlias to the created certification path.</para>
            <para>The signature of each certificate in the sequence of uploaded certificates except for the last one shall be verifiable with the public key contained in the next certificate in the sequence. If there is a certificate in the request other than the last certificate for which the signature cannot be verified with the public key in the next certificate, the device shall produce an invalid certification path fault and shall not store the uploaded certificates nor uploaded private key in the keystore.</para>
            <para>If the device cannot process one of the uploaded certificates, it shall produce a BadCertificate fault and neither store the uploaded certificates nor private key in the keystore. The BadCertificate fault shall not be produced based on the mere fact that the device’s current time lies outside the interval defined by the notBefore and notAfter fields as specified by RFC 5280, Sect. 4.1.</para>
            <para>The device shall not mark the uploaded certificates as trusted.</para>
            <para>The uploaded certificates have to be linked to key pairs in the keystore. Key pairs are uniquely identified using key IDs.</para>
            <para>If a key pair exists in the keystore with the public key equal to the public key in a certificate in the request, the device shall link the uploaded certificate to the key pair in the keystore by adding a reference from the certificate to the key pair. If the key pair in the keystore does not contain a private key and the private key contained in the KeyBag or PKCS8ShroudedKeyBag that matches the public key in the key pair, the device shall add the private key contained in the KeyBag or PKCS8ShroudedKeyBag to the key pair.</para>
            <para>If no key pair exists in the keystore with the public key equal to the public key in a certificate in the request, the device shall create a new key pair with status ok, externally generated attribute set to <emphasis>true</emphasis>, and the public and private keys from the request, and shall link this key pair to the uploaded certificate by adding a reference from the certificate to the key pair.</para>
            <para>If a new key pair is created for the uploaded private key, the device shall assign the supplied KeyAlias to it. Otherwise, the device shall ignore an eventually supplied KeyAlias.</para>
            <para>How the link between an uploaded certificate and a key pair is established is illustrated in <xref linkend="_Ref379899735"/>.</para>
            <figure xml:id="_Ref379899735">
              <title>Link establishment between certificates and key pair for Upload Certificate with Private Key in PKCS#12</title>
              <mediaobject>
                <imageobject>
                  <imagedata fileref="media/Security/image4.png" contentwidth="122.16mm"/>
                </imageobject>
              </mediaobject>
            </figure>
            <para>If the key pair that a certificate shall be linked to does not have status <emphasis>ok</emphasis>, the device shall produce an invalid key status fault and shall not store the uploaded certificates nor the uploaded key pair in the keystore.</para>
            <para>If the device does not have enough storage capacity for storing the certificates to be uploaded, the device shall produce a maximum number of certificates reached fault and shall not store the uploaded certificates nor the uploaded key pair in the keystore.</para>
            <para>If the device does not have enough storage capacity for storing the key pair that eventually has to be created, the device shall generate a maximum number of keys reached fault. Furthermore the device shall not store a key pair and shall not store the uploaded certificates in the keystore.</para>
            <para>If the device does not have enough storage capacity for storing the certification path to be created, the device shall produce a maximum number of certification paths reached fault and shall not store the uploaded certificates nor the uploaded key pair in the keystore.</para>
            <para>If no passphrase exists under the ID specified by IntegrityPassphraseID, the device shall produce an invalid passphrase ID fault and shall not store the uploaded certificates nor the uploaded key pair in the keystore.</para>
            <para>If no passphrase exists under the ID specified by EncryptionPassphraseID, the device shall produce an invalid passphrase ID fault and shall not store the uploaded certificates nor the uploaded key pair in the keystore.</para>
            <para>If the supplied PKCS#12 data structure cannot be processed by the device, the device shall produce a BadPKCS12File fault and shall not store the uploaded certificates nor the uploaded key pair in the keystore.</para>
            <para>If the public key in the first uploaded certificate does not match the uploaded private key, the device shall produce a PublicPrivateKeyMismatch fault and shall not store the uploaded certificates nor the uploaded key pair in the keystore.</para>
            <para>If the command was successful, the device shall return the ID of the created certification path and the ID of the key pair that contains the public key in the certificate.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">CertWithPrivateKey - [tas:Base64DERencodedASN1Value]</para>
                  <para role="text"> The certifcates and key pair to be uploaded in a PKCS#12 data structure.</para>
                  <para role="param">CertificationPathAlias - optional [xs:string] </para>
                  <para role="text">The client-defined alias of the certification path.</para>
                  <para role="param">KeyAlias - optional [xs:string]</para>
                  <para role="text"> The client-defined alias of the key pair.</para>
                  <para role="param">IgnoreAdditionalCertificates - optional [xs:boolean]</para>
                  <para role="text"> True if and only if the device shall behave as if the client had only supplied the first certificate in the sequence of certificates.</para>
                  <para role="param">IntegrityPassphraseID - optional [tas:PassphraseID]</para>
                  <para role="text"> The ID of the passphrase to use for integrity checking of the uploaded PKCS#12 data structure.</para>
                  <para role="param">EncryptionPassphraseID - optional [tas:PassphraseID]</para>
                  <para role="text"> The ID of the passphrase to use for decrypting the uploaded PKCS#12 data structure.</para>
                  <para role="param">Passphrase - optional [xs:string]</para>
                  <para role="text"> The passphrase to use for integrity checking and decrypting the uploaded PKCS#12 data structure.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">CertificationPathID - [tas:CertificationPathID]</para>
                  <para role="text"> The certification path ID of the uploaded certification path.</para>
                  <para role="param">KeyID - [tas:KeyID]</para>
                  <para role="text"> The key ID of the uploaded key pair.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">ter:Receiver - ter:Action - ter:</para>
                  <para role="text">
                    <emphasis role="bold">MaximumNumberOfCertificatesReached</emphasis> The device does not have enough storage space to store the certificate to be uploaded.</para>
                  <para role="param">ter:Receiver - ter:Action - ter:</para>
                  <para role="text">
                    <emphasis role="bold">MaximumNumberOfKeysReached</emphasis> The device does not have enough storage space to store the key pair that has to be generated.</para>
                  <para role="param">ter:Receiver - ter:Action - ter:</para>
                  <para role="text">
                    <emphasis role="bold">MaximumNumberOfCertificationPathsReached</emphasis> The device does not have enough storage space to store the certification path to be uploaded.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:PassphraseID</para>
                  <para role="text"> No passphrase is stored under the requested PassphraseID.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:DecryptionFailed</para>
                  <para role="text"> The given data could not be decrypted.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:BadCertificate</para>
                  <para role="text"> The supplied certificate file cannot be processed by the device.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:UnsupportedPublicKeyAlgorithm</para>
                  <para role="text"> The public key algorithm of the public key in the certificate is not supported by the device.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:UnsupportedSignatureAlgorithm</para>
                  <para role="text"> The signature algorithm that the signature of the supplied certificate is based on is not supported by the device.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:InvalidKeyStatus</para>
                  <para role="text"> The key with the requested KeyID has an inappropriate status.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:BadPKCS12File</para>
                  <para role="text"> The PKCS#12 data structure cannot be processed by the device.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:PublicPrivateKeyMismatch</para>
                  <para role="text"> The supplied private key does not match the supplied public key.</para>
                  <para role="param">env:Sender - ter: InvalidArgVal - ter:InvalidCertificationPath</para>
                  <para role="text"> At least one certificate in the certification path is not correctly signed with the public key in the next certificate in the path.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">WRITE_SYSTEM</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>GetCertificate</title>
            <para>This operation returns a specific certificate from the device’s keystore.</para>
            <para>Certificates are uniquely identified using certificate IDs. If no certificate is stored under the requested certificate ID in the keystore, an InvalidArgVal fault is produced.</para>
            <para>The certificate shall be returned in DER encoding.</para>
            <para>It shall be noted that this command does not return the private key that is associated with the public key in the certificate.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">Certificateid - [tas:CertificateID]</para>
                  <para role="text"> The ID of the certificate to retrieve.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">Certificate - [tas:X509Certificate]</para>
                  <para role="text"> The DER representation of the certificate.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:CertificateID</para>
                  <para role="text"> No certificate is stored under the requested CertificateID.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">READ_SYSTEM_SECRET</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>GetAllCertificates</title>
            <para>This operation returns all certificates that are stored in the device’s keystore.</para>
            <para>This operation may be used, e.g., if a client lost track of which certificates are present on the device.</para>
            <para>The certificates shall be returned in DER encoding.</para>
            <para>If no certificate is stored in the device’s keystore, an empty list is returned.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="text">This message is empty.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">Certificate - optional, unbounded [tas:X509Certificate]</para>
                  <para role="text"> List of DER representation of certificates stored in the keystore.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="text">None</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">READ_SYSTEM_SECRET</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>DeleteCertificate</title>
            <para>This operation deletes a certificate from the device’s keystore.</para>
            <para>The operation shall not delete the public key that is contained in the certificate from the keystore.</para>
            <para>Certificates are uniquely identified using certificate IDs. If no certificate is stored under the requested certificate ID in the keystore, an InvalidArgVal fault is produced. If there is a certificate under the requested certificate ID stored in the keystore and the certificate could not be deleted, a CertificateDeletion fault is produced.</para>
            <para>If a reference exists for the specified certificate, the certificate shall not be deleted and the corresponding fault shall be produced.</para>
            <para>After a certificate has been successfully deleted, the device may assign its former ID to other certificates.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">CertificateID - [tas:CertificateID]</para>
                  <para role="text"> The ID of the certificate to delete.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="text">This message is empty.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">ter:Receiver - ter:Action - ter:CertificateDeletionFailed</para>
                  <para role="text"> Deleting the certificate with the requested CertificateID failed.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:CertificateID</para>
                  <para role="text"> No certificate is stored under the requested CertificateID.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:ReferenceExists</para>
                  <para role="text"> A reference exists for the specified certificate.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">UNRECOVERABLE</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>CreateCertificationPath</title>
            <para>This operation creates a sequence of certificates that may be used, e.g., for certification path validation or for TLS server authentication.</para>
            <para>Certification paths are uniquely identified using certification path IDs. Certificates are uniquely identified using certificate IDs. A certification path contains a sequence of certificate IDs.</para>
            <para>If there is a certificate ID in the sequence of supplied certificate IDs for which no certificate exists in the device’s keystore, the corresponding fault shall be produced and no certification path shall be created.</para>
            <para>The signature of each certificate in the certification path except for the last one shall be verifiable with the public key contained in the next certificate in the path. If there is a certificate ID in the request other than the last ID for which the corresponding certificate cannot be verified with the public key in the certificate identified by the next certificate ID, an InvalidCertificateChain fault shall be produced and no certification path shall be created.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">CertificateIDs - [tas:CertificateIDs] </para>
                  <para role="text">The IDs of the certificates to include in the certification path, where each certificate signature except for the last one in the path must be verifiable with the public key certified by the next certificate in the path.</para>
                  <para role="param">Alias - optional [xs:string] </para>
                  <para role="text">The client-defined alias of the certification path.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">CertificationPathID - [tas:CertificationPathID] </para>
                  <para role="text">The ID of the generated certification path.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Receiver - ter:Action - ter:MaximumNumberOfCertificationPathsReached</para>
                  <para role="text"> The maximum number of certification paths that may be assigned to the TLS server simultaneously is reached.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:CertificateID </para>
                  <para role="text">No certificate is stored under the requested CertificateID.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:InvalidCertificationPath </para>
                  <para role="text">At least one certificate in the certification path is not correctly signed with the public key in the next certificate in the path.</para>
                  <para role="param">env:Receiver - ter:Action - ter:CertificationPathCreationFailed </para>
                  <para role="text">Creating the certification path failed.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">WRITE_SYSTEM</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>GetCertificationPath</title>
            <para>This operation returns a specific certification path from the device’s keystore.</para>
            <para>Certification paths are uniquely identified using certification path IDs. If no certification path is stored under the requested ID in the keystore, an InvalidArgVal fault is produced.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">CertificationPathID - [tas:CertificationPathID] </para>
                  <para role="text">The ID of the certification path to retrieve.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">CertificationPath - [tas:CertificationPath] </para>
                  <para role="text">The certification path that is stored under the given ID in the keystore.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:CertificationPathID </para>
                  <para role="text">No certification path is stored under the requested certification path ID.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">READ_SYSTEM_SECRET</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>GetAllCertificationPaths</title>
            <para>This operation returns the IDs of all certification paths that are stored in the device’s keystore.</para>
            <para>This operation may be used, e.g., if a client lost track of which certificates are present on the device.</para>
            <para>If no certification path is stored on the device, an empty list is returned.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="text">This message is empty.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">CertificationPathID - optional, unbounded [tas:CertificationPathID]</para>
                  <para role="text"> List of IDs of certification paths stored in the keystore.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="text">None</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">READ_SYSTEM_SECRET</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>SetCertificationPath</title>
            <para>This operation allows to modify a certification path. A device shall support this
              method if support for SetCertPath is signaled via its capabilities.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">CertificationPathID - [tas:CertificationPathID] </para>
                  <para role="text">The ID of the certification path to modify.</para>
                  <para role="param">CertificateIDs - [tas:CertificateIDs] </para>
                  <para role="text">The IDs of the certificates to include in the certification path, where each certificate signature except for the last one in the path must be verifiable with the public key certified by the next certificate in the path.</para>
                  <para role="param">Alias - optional [xs:string] </para>
                  <para role="text">The client-defined alias of the certification path.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="text">This message is empty.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:CertificationPathID </para>
                  <para role="text">No certification path is stored under the requested certification path ID.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:CertificateID </para>
                  <para role="text">No certificate is stored under the requested CertificateID.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:InvalidCertificationPath </para>
                  <para role="text">At least one certificate in the certification path is not correctly signed with the public key in the next certificate in the path.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">READ_SYSTEM_SECRET</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>DeleteCertificationPath</title>
            <para>This operation deletes a certification path from the device’s keystore.</para>
            <para>This operation shall not delete the certificates that are referenced by the certification path.</para>
            <para>Certification paths are uniquely identified using certification path IDs. If no certification path is stored under the requested certification path ID in the keystore, an InvalidArgVal fault is produced. If there is a certification path under the requested certification path ID stored in the keystore and the certification path could not be deleted, a CertificationPathDeletion fault is produced.</para>
            <para>If a reference exists for the specified certification path, the certification path shall not be deleted and the corresponding fault shall be produced.</para>
            <para>After a certification path is successfully deleted, the device may assign its former ID to other certification paths.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">CertificationPathID - [tas:CertificationPathID]</para>
                  <para role="text"> The ID of the certification path to delete.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="text">This message is empty.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">ter:Receiver - ter:Action - ter:CertificationPathDeletionFailed</para>
                  <para role="text"> Deleting the certification path with the requested certification path ID failed.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:CertificationPathID</para>
                  <para role="text"> No certification path is stored under the requested certification path ID.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:ReferenceExists</para>
                  <para role="text"> A reference exists for the object that is to be deleted.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">UNRECOVERABLE</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
        </section>
        <section>
          <title>CRL Management</title>
          <section>
            <title>UploadCRL</title>
            <para>This operation uploads a certificate revocation list (CRL) as specified in RFC 5280 to the keystore on the device.</para>
            <para>If the device does not have enough storage space to store the CRL to be uploaded, the device shall produce a MaximumNumberOfCRLsReached fault and shall not store the supplied CRL.</para>
            <para>If the device is not able to process the supplied CRL, the device shall produce a BadCRL fault and shall not store the supplied CRL.</para>
            <para>If the device does not support the signature algorithm that was used to sign the supplied CRL, the device shall produce an UnsupportedSignatureAlgorithm fault and shall not store the supplied CRL.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">Crl - [tas:Base64DERencodedASN1Value]</para>
                  <para role="text"> The CRL to be uploaded to the device.</para>
                  <para role="param">Alias - optional [xs:string] </para>
                  <para role="text">The alias to assign to the uploaded CRL.</para>
                  <para role="param">anyParameters - optional, unbounded [xs:any]</para>
                  <para role="text">
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">CrlID - [tas:CRLID] </para>
                  <para role="text">The ID of the uploaded CRL.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Receiver - ter:Action - ter:MaximumNumberOfCRLsReached</para>
                  <para role="text">The device does not have enough storage space to store the CRL to be uploaded.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:BadCRL</para>
                  <para role="text">The supplied CRL cannot be processed by the device.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:UnsupportedSignatureAlgorithm </para>
                  <para role="text">
                    <phrase>The specified signature algorithm is not supported by the device.</phrase>
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">WRITE_SYSTEM</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>GetCRL</title>
            <para>This operation returns a specific certificate revocation list (CRL) from the keystore on the device.</para>
            <para>Certification revocation lists are uniquely identified using CRLIDs. If no CRL is stored under the requested CRLID, the device shall produce a CRLID fault.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">CrlID - [tas:CRLID]</para>
                  <para role="text"> The ID of the CRL to be returned.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">Crl - [tas:CRL] </para>
                  <para role="text">The CRL with the requested ID.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:CRLID </para>
                  <para role="text">
                    <phrase>No CRL is stored under the requested CRL ID.</phrase>
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">READ_SYSTEM_SECRET</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>GetAllCRLs</title>
            <para>This operation returns all certificate revocation lists (CRLs) that are stored in the keystore on the device.</para>
            <para>If no certificate revocation list is stored in the device’s keystore, an empty list is returned.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="text">This message is empty.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">Crl - optional, unbounded [tas:CRL]</para>
                  <para role="text"> A list of all CRLs that are stored in the keystore on the device.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="text">None</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">READ_SYSTEM_SECRET</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>DeleteCRL</title>
            <para>This operation deletes a certificate revocation list (CRL) from the keystore on the device.</para>
            <para>Certification revocation lists are uniquely identified using CRLIDs. If no CRL is stored under the requested CRLID, the device shall produce a CRLID fault.</para>
            <para>If a reference exists for the specified CRL, the device shall produce a ReferenceExists fault and shall not delete the CRL.</para>
            <para>After a CRL has been successfully deleted, a device may assign its former ID to other CRLs.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">CrlID - [tas:CRLID]</para>
                  <para role="text"> The ID of the CRL to be deleted.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="text">This message is empty.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:CRLID</para>
                  <para role="text"> No CRL is stored under the requested CRL ID.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:ReferenceExists</para>
                  <para role="text"> A reference exists for the object that is to be deleted.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">UNRECOVERABLE</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
        </section>
        <section>
          <title>Certification Path Validation Policy Management</title>
          <section>
            <title>CreateCertPathValidationPolicy</title>
            <para>This operation creates a certification path validation policy.</para>
            <para>Certification path validation policies are uniquely identified using certification path validation policy IDs. The device shall generate a new certification path validation policy ID for the created certification path validation policy.</para>
            <para>If the device does not have enough storage capacity for storing the certification path validation policy to be created, the device shall produce a maximum number of certification path validation policies reached fault and shall not create a certification path validation policy.</para>
            <para>If there is at least one trust anchor certificate ID in the request for which there exists no certificate in the device’s keystore, the device shall produce a CertificateID fault and shall not create a certification path validation policy.</para>
            <para>If the device cannot process the supplied certification path validation parameters, the device shall produce a CertPathValidationParameters fault and shall not create a certification path validation policy.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">Alias - optional [xs:string] </para>
                  <para role="text">The alias to assign to the created certification path validation policy.</para>
                  <para role="param">Parameters - [tas:CertPathValidationParameters] </para>
                  <para role="text">The parameters of the certification path validation policy to be created.</para>
                  <para role="param">TrustAnchor - unbounded [tas:TrustAnchor] </para>
                  <para role="text">The trust anchors of the certification path validation policy to be created.</para>
                  <para role="param">anyParameters - optional [xs:any]</para>
                  <para role="text">
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">CertPathValidationPolicyID - [tas:CertPathValidationPolicyID] </para>
                  <para role="text">The ID of the created certification path validation policy.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Receiver - ter:Action - ter:MaximumNumberOfCertPathValidationPoliciesReached </para>
                  <para role="text">The device does not have enough storage to store the certification path validation policy to be created.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:CertificateID </para>
                  <para role="text">No certificate is stored under the requested CertificateID.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:CertPathValidationParameters </para>
                  <para role="text">The specified certification path validation parameters are invalid.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">WRITE_SYSTEM</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>GetCertPathValidationPolicy</title>
            <para>This operation returns a certification path validation policy from the keystore on the device.</para>
            <para>Certification path validation policies are uniquely identified using certification path validation policy IDs. If no certification path validation policy is stored under the requested certification path validation policy ID, the device shall produce a CertPathValidationPolicyID fault.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">CertPathValidationPolicyID - [tas:CertPathValidationPolicyID] </para>
                  <para role="text">The ID of the certification path validation policy to be created.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">CertPathValidationPolicy - [tas:CertPathValidationPolicy] </para>
                  <para role="text">The certification path validation policy that is stored under the requested ID.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:CertPathValidationPolicyID </para>
                  <para role="text">No certification path validation policy is stored under the requested certification path validation policy ID.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">READ_SYSTEM_SECRET</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>GetAllCertPathValidationPolicies</title>
            <para>This operation returns all certification path validation policies that are stored in the keystore on the device.</para>
            <para>If no certification path validation policy is stored in the device’s keystore, an empty list is returned.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="text">This message is empty.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="param">CertPathValidationPolicy - optional, unbounded - [tas:CertPathValidationPolicy] </para>
                  <para role="text">A list of all certification path validation policies that are stored in the keystore on the device.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="text">None</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">READ_SYSTEM_SECRET</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>SetCertPathValidationPolicy</title>
            <para>This operation allows to modify a certification path validation policy in the
              keystore on the device. A device shall support this method if support for SetCertPath
              is signaled via its capabilities.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">CertPathValidationPolicyID - [tas:CertPathValidationPolicyID] </para>
                  <para role="text">The ID of the certification path validation policy to be modified.</para>
                  <para role="param">Parameters - [tas:CertPathValidationParameters] </para>
                  <para role="text">The parameters of the certification path validation
                    policy.</para>
                  <para role="param">TrustAnchor - unbounded [tas:TrustAnchor] </para>
                  <para role="text">The trust anchors of the certification path validation
                    policy.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="text">This message is empty.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:CertPathValidationPolicyID </para>
                  <para role="text">No certification path validation policy is stored under the requested certification path validation policy ID.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:CertificateID </para>
                  <para role="text">No certificate is stored under the requested
                    CertificateID.</para>
                  <para role="param">env:Sender - ter:InvalidArgVal -
                    ter:CertPathValidationParameters </para>
                  <para role="text">The specified certification path validation parameters are
                    invalid.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">WRITE_SYSTEM</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
          <section>
            <title>DeleteCertPathValidationPolicy</title>
            <para>This operation deletes a certification path validation policy from the keystore on the device.</para>
            <para>Certification path validation policies are uniquely identified using certification path validation policy IDs. If no certification path validation policy is stored under the requested certification path validation policy ID, the device shall produce an CertPathValidationPolicyID fault.</para>
            <para>If a reference exists for the requested certification path validation policy, the device shall produce a ReferenceExists fault and shall not delete the certification path validation policy.</para>
            <para>After the certification path validation policy has been deleted, the device may assign its former ID to other certification path validation policies.</para>
            <variablelist role="op">
              <varlistentry>
                <term>request</term>
                <listitem>
                  <para role="param">CertPathValidationPolicyID - [tas:CertPathValidationPolicyID] </para>
                  <para role="text">The ID of the certification path validation policy to be deleted.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>response</term>
                <listitem>
                  <para role="text">This message is empty.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>faults</term>
                <listitem>
                  <para role="param">env:Sender - ter:InvalidArgVal - ter:CertPathValidationPolicyID </para>
                  <para role="text">No certification path validation policy is stored under the requested certification path validation policy ID.</para>
                  <para role="param">ter:Sender - ter:InvalidArgVal - ter:ReferenceExists</para>
                  <para role="text"> A reference exists for the object that is to be deleted.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>access class</term>
                <listitem>
                  <para role="access">UNRECOVERABLE</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </section>
        </section>
      </section>
    </section>
    <section>
      <title>TLS Server</title>
      <section>
        <title>Elements of the TLS Server</title>
        <para>The TLS server security feature implements a TLS server as specified in RFC 2246 and subsequent specifications.</para>
        <para>This specification defines how to manage the associations between certification paths and the TLS server. All other TLS server configuration actions are outside the scope of this specification. In particular, enabling and disabling the TLS server on the device shall be performed using the device management service specified in the ONVIF Core Specification.</para>
      </section>
      <section>
        <title>Authorization of TLS authenticated connections</title>
        <para>If TLS client authentication is enabled, connections shall be authenticated as specified in RFC 2246, and the device shall before all validate the client TLS certificate. In case of invalid certificate the TLS connection shall be terminated and the device shall ignore any other credentials received on HTTP or WS layer.</para>
        <para>Once a service request is authenticated on the TLS layer, the device shall decide based on its  access policy whether the requestor is authorized to receive the service. In order to authorize the requestor, additional information for the device is required.</para>
        <para>If CnMapsToUser is true, the name of the user requiring access to the device shall be presented in the Common Name (CN) attribute of the certificate presented by the client to the device. The device shall validate the provided username against its set of credentials, and grant access to the requested function in case of success. If the user is not allowed to access the function, the device shall return a 403 Forbidden.</para>
        <para>If CnMapsToUser is false, from this point forward the authorization procedure follows what is specified in the ONVIF Core Specification as part of the security service.</para>
        <para>The authentication  and authorization process and falling back to the  ONVIF Core Specification is illustrated in <xref linkend="image5"/>.</para>
        <figure xml:id="image5">
          <title>Authentication and authorization flow chart and fallback mechanism to the ONVIF Core Specification.</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="media/Security/image5.svg" contentwidth="160mm"/>
            </imageobject>
          </mediaobject>
        </figure>
      </section>
      <section>
        <title>TLS Server Operations</title>
        <section>
          <title>AddServerCertificateAssignment</title>
          <para>This operation assigns a key pair and certificate along with a certification path (certificate chain) to the TLS server on the device. The TLS server shall use this information for key exchange during the TLS handshake, particularly for constructing server certificate messages as specified in RFC 4346, RFC 2246.</para>
          <para>Certification paths are identified by their certification path IDs in the keystore. The first certificate in the certification path shall be the TLS server certificate.</para>
          <para>Since each certificate has exactly one associated key pair, a reference to the key pair that is associated with the server certificate is not supplied explicitly. Devices shall obtain the private key or results of operations under the private key by suitable internal interaction with the keystore.</para>
          <para>If a device chooses to perform a TLS key exchange based on the supplied certification path,  it shall use the key pair that is associated with the server certificate for key exchange and transmit the certification path to TLS clients as-is, i.e., the device shall not check conformance of the certification path to RFC 4346, RFC 2246.</para>
          <para>In order to use the server certificate during the TLS handshake, the corresponding private key is required. Therefore, if the key pair that is associated with the server certificate, i.e., the first certificate in the certification path, does not have an associated private key, the NoPrivateKey fault is produced and the certification path is not associated with the TLS server.</para>
          <para>A TLS server may present different certification paths to different clients during the TLS handshake instead of presenting the same certification path to all clients. Therefore more than one certification path may be assigned to the TLS server. If the maximum number of certification paths that may be assigned to the TLS server simultaneously is reached, the device shall generate a MaximumNumberOfTLSCertificationPathsReached fault and the requested certification path shall not be assigned to the TLS server.</para>
          <para>If the certification path identified by the supplied certification path ID is already assigned to the TLS server, this command shall have no effect.</para>
          <variablelist role="op">
            <varlistentry>
              <term>request</term>
              <listitem>
                <para role="param">CertificationPathID - [tas:CertificationPathID] </para>
                <para role="text">The ID of the certification path to assign to the TLS
                  server.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>response</term>
              <listitem>
                <para role="text">This message is empty.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>faults</term>
              <listitem>
                <para role="param">env:Sender - ter:InvalidArgVal - ter:CertificationPathID </para>
                <para role="text">No certification path is stored in the keystore under the given certification path ID.</para>
                <para role="param">env:Sender - ter:InvalidArgVal - ter:NoPrivateKey </para>
                <para role="text">The key pair that is associated with the first certificate in the certificate chain does not have an associated private key.</para>
                <para role="param">env: Receiver - ter: Action - ter:MaximumNumberOfTLSCertificationPathsReached </para>
                <para role="text">The maximum number of certification paths that may be assigned to the TLS server simultaneously is reached.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>access class</term>
              <listitem>
                <para role="access">WRITE_SYSTEM</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>RemoveServerCertificateAssignment</title>
          <para>This operation removes a key pair and certificate assignment (including certification path) to the TLS server on the device.</para>
          <para>Certification paths are identified using certification path IDs. If the supplied certification path ID is not associated with the TLS server, an InvalidArgVal fault is produced.</para>
          <para>If the TLS server on the device is enabled, the device shall produce a ReferenceExists fault and shall not remove the server certificate assignment.</para>
          <variablelist role="op">
            <varlistentry>
              <term>request</term>
              <listitem>
                <para role="param">CertificationPathID - [tas:CertificationPathID] The ID of the certification path to remove from the TLS server.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>response</term>
              <listitem>
                <para role="text">This message is empty.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>faults</term>
              <listitem>
                <para role="param">env:Sender - ter:InvalidArgVal - ter:OldCertificationPathID</para>
                <para role="text"> No certification path under the given certification path ID is associated with the TLS server.</para>
                <para role="param">env:Sender - ter:InvalidArgVal - ter:ReferenceExists</para>
                <para role="text"> A reference exists for the object that is to be deleted.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>access class</term>
              <listitem>
                <para role="access">WRITE_SYSTEM</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>ReplaceServerCertificateAssignment</title>
          <para>This operation replaces an existing key pair and certificate assignment to the TLS server on the device by a new key pair and certificate assignment (including certification paths).</para>
          <para>After the replacement, the TLS server shall use the new certificate and certification path exactly in those cases in which it would have used the old certificate and certification path. Therefore, especially in the case that several server certificates are assigned to the TLS server, clients that wish to replace an old certificate assignment by a new assignment should use this operation instead of a combination of the Add TLS Server Certificate Assignment and the Remove TLS Server Certificate Assignment operations.</para>
          <para>Certification paths are identified using certification path IDs. If the supplied old certification path ID is not associated with the TLS server, or no certification path exists under the new certification path ID, the corresponding InvalidArgVal faults are produced and the associations are unchanged.</para>
          <para>The first certificate in the new certification path shall be the TLS server certificate.</para>
          <para>Since each certificate has exactly one associated key pair, a reference to the key pair that is associated with the new server certificate is not supplied explicitly. Devices shall obtain the private key or results of operations under the private key by suitable internal interaction with the keystore.</para>
          <para>If a device chooses to perform a TLS key exchange based on the new certification path, it shall use the key pair that is associated with the server certificate for key exchange and transmit the certification path to TLS clients as-is, i.e., the device shall not check conformance of the certification path to RFC 4346, RFC 2246.</para>
          <para>In order to use the server certificate during the TLS handshake, the corresponding private key is required. Therefore, if the key pair that is associated with the server certificate, i.e., the first certificate in the certification path, does not have an associated private key, the NoPrivateKey fault is produced and the certification path is not associated with the TLS server.</para>
          <variablelist role="op">
            <varlistentry>
              <term>request</term>
              <listitem>
                <para role="param">OldCertificationPathID - [tas:CertificationPathID] </para>
                <para role="text">The ID of the certification path to remove from the TLS server.</para>
                <para role="param">NewCertificationPathID - [tas:CertificationPathID] </para>
                <para role="text">The ID of the certification path to assign to the TLS server.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>response</term>
              <listitem>
                <para role="text">This message is empty.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>faults</term>
              <listitem>
                <para role="param">env:Sender - ter:InvalidArgVal - ter:OldCertificationPathID </para>
                <para role="text">No certification path under the given certification path ID is associated with the TLS server.</para>
                <para role="param">env:Sender - ter:InvalidArgVal - ter:NewCertificationPathID </para>
                <para role="text">No certification path is stored in the keystore under the given certification path ID.</para>
                <para role="param">env:Sender - ter:InvalidArgVal - ter:NoPrivateKey </para>
                <para role="text">The key pair that is associated with the first certificate in the certificate chain does not have an associated private key.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>access class</term>
              <listitem>
                <para role="access">WRITE_SYSTEM</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>GetAssignedServerCertificates</title>
          <para>This operation returns the IDs of all certification paths that are assigned to the TLS server on the device.</para>
          <para>This operation may be used, e.g., if a client lost track of the certification path assignments on the device.</para>
          <para>If no certification path is assigned to the TLS server, an empty list is returned.</para>
          <variablelist role="op">
            <varlistentry>
              <term>request</term>
              <listitem>
                <para role="text">This message is empty.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>response</term>
              <listitem>
                <para role="param">CertificationPathID - optional, unbounded [tas:CertificationPathID] </para>
                <para role="text">List of certification path IDs assigned to the TLS server.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>faults</term>
              <listitem>
                <para role="text">None</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>access class</term>
              <listitem>
                <para role="access">READ_SYSTEM_SECRET</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>SetClientAuthenticationRequired</title>
          <para>This operation activates or deactivates TLS client authentication for the TLS server on the device.</para>
          <para>The TLS server on the device shall require client authentication if and only if clientAuthenticationRequired is set to <emphasis>true</emphasis>.</para>
          <para>If TLS client authentication is requested to be enabled and no certification path validation policy is assigned to the TLS server, the device shall return an EnablingClientAuthenticationFailed fault and shall not enable TLS client authentication.</para>
          <para>The device shall execute this command regardless of the TLS enabled/disabled state configured in the ONVIF Device Management Service.</para>
          <variablelist role="op">
            <varlistentry>
              <term>request</term>
              <listitem>
                <para role="param">clientAuthenticationRequired - [xs:boolean] </para>
                <para role="text">Define whether TLS client authentication is active on the device.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>response</term>
              <listitem>
                <para role="text">This message is empty.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>faults</term>
              <listitem>
                <para role="param">env:Receiver - ter:ActionNotSupported - ter:EnablingClientAuthenticationFailed </para>
                <para role="text">The device does not support TLS client authentication, or TLS client authentication is not configured appropriately.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>access class</term>
              <listitem>
                <para role="access">WRITE_SYSTEM</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>GetClientAuthenticationRequired</title>
          <para>This operation returns whether TLS client authentication is active.</para>
          <variablelist role="op">
            <varlistentry>
              <term>request</term>
              <listitem>
                <para role="text">This message is empty.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>response</term>
              <listitem>
                <para role="param">clientAuthenticationRequired - [xs:boolean] </para>
                <para role="text">Report whether TLS client authentication is active on the device.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>faults</term>
              <listitem>
                <para role="text">None</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>access class</term>
              <listitem>
                <para role="access">READ_SYSTEM</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>SetCnMapsToUser</title>
          <para>This operation enables or disables mapping of the Common Name present in the TLS client certificate to an existing user name in the device.</para>
          <para>The TLS server on the device shall perform mapping if parameter clientAuthenticationRequired is set to <emphasis>true</emphasis>.</para>
          <variablelist role="op">
            <varlistentry>
              <term>request</term>
              <listitem>
                <para role="param">cnMapsToUser - [xs:boolean]</para>
                <para role="text">A request for the device to enable or disable Common Name Mapping to User.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>response</term>
              <listitem>
                <para role="text">This message is empty.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>faults</term>
              <listitem>
                <para role="param">env:Receiver - ter:ActionNotSupported - ter:CnMapsToUserFailed </para>
                <para role="text">The device does not support TLS client authentication, or TLS client authentication is not configured appropriately.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>access class</term>
              <listitem>
                <para role="access">WRITE_SYSTEM</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>GetCnMapsToUser</title>
          <para>This operation returns whether the Common Name Mapping to User is enabled.</para>
          <variablelist role="op">
            <varlistentry>
              <term>request</term>
              <listitem>
                <para role="text">This message is empty.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>response</term>
              <listitem>
                <para role="param">cnMapsToUser - [xs:boolean] </para>
                <para role="text">Whether cnMapsToUser is enabled.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>faults</term>
              <listitem>
                <para role="param">None</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>access class</term>
              <listitem>
                <para role="access">READ_SYSTEM</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>AddCertPathValidationPolicyAssignment</title>
          <para>This operation assigns a certification path validation policy to the TLS server on the device. The TLS server shall enforce the policy when authenticating TLS clients and consider a client authentic if Certificaton Path Validation according to section 6 of RFC 5280 succeeds.</para>
          <para>If no certification path validation policy is stored under the requested CertPathValidationPolicyID, the device shall produce a CertPathValidationPolicyID fault.</para>
          <para>A TLS server may use different certification path validation policies to authenticate clients. Therefore more than one certification path validation policy may be assigned to the TLS server. If the maximum number of certification path validation policies that may be assigned to the TLS server simultaneously is reached, the device shall produce a MaximumNumberOfTLSCertPathValidationPoliciesReached fault and shall not assign the requested certification path validation policy to the TLS server.</para>
          <variablelist role="op">
            <varlistentry>
              <term>request</term>
              <listitem>
                <para role="param">CertPathValidationPolicyID - [tas:CertPathValidationPolicyID] </para>
                <para role="text">The ID of the certification path validation policy to assign to
                  the TLS server.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>response</term>
              <listitem>
                <para role="text">This message is empty.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>faults</term>
              <listitem>
                <para role="param">env:Sender - ter:InvalidArgVal - ter:CertPathValidationPolicyID </para>
                <para role="text">No certification path validation policy is stored under the
                  requested CertPathValidationPolicyID.</para>
                <para role="param">env:Receiver - ter:Action - ter:MaximumNumberOfTLSCertPathValidationPoliciesReached </para>
                <para role="text">The maximum number of certification path validation policies that may be assigned to the TLS server simultaneously is reached.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>access class</term>
              <listitem>
                <para role="access">WRITE_SYSTEM</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>RemoveCertPathValidationPolicyAssignment</title>
          <para>This operation removes a certification path validation policy assignment from the TLS server on the device.</para>
          <para>If the certification path validation policy identified by the requested CertPathValidationPolicyID is not associated to the TLS server, the device shall produce a CertPathValidationPolicyID fault.</para>
          <variablelist role="op">
            <varlistentry>
              <term>request</term>
              <listitem>
                <para role="param">CertPathValidationPolicyID - [tas:CertPathValidationPolicyID] </para>
                <para role="text">The ID of the certification path validation policy to remove from the TLS server.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>response</term>
              <listitem>
                <para role="text">This message is empty.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>faults</term>
              <listitem>
                <para role="param">env:Sender - ter:InvalidArgVal - ter:CertPathValidationPolicyID </para>
                <para role="text">No certification path validation policy is stored under the requested CertPathValidationPolicyID.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>access class</term>
              <listitem>
                <para role="access">WRITE_SYSTEM</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>ReplaceCertPathValidationPolicyAssignment</title>
          <para>This operation replaces a certification path validation policy assignment to the TLS server on the device with another certification path validation policy assignment.</para>
          <para>If the certification path validation policy identified by the requested OldCertPathValidationPolicyID is not associated to the TLS server, the device shall produce an OldCertPathValidationPolicyID fault and shall not associate the certification path validation policy identified by the NewCertPathValidationPolicyID to the TLS server.</para>
          <para>If no certification path validation policy exists under the requested NewCertPathValidationPolicyID in the device’s keystore, the device shall produce a NewCertPathValidationPolicyID fault and shall not remove the association of the old certification path validation policy to the TLS server.</para>
          <variablelist role="op">
            <varlistentry>
              <term>request</term>
              <listitem>
                <para role="param">OldCertPathValidationPolicyID - [tas:CertPathValidationPolicyID] </para>
                <para role="text">The ID of the certification path validation policy to remove from the TLS server.</para>
                <para role="param">NewCertPathValidationPolicyID - [tas:CertPathValidationPolicyID] </para>
                <para role="text">The ID of the certification path validation policy to assign to the TLS server.</para>
                <para role="param">RESPONSE:</para>
                <para role="text">This message is empty.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>faults</term>
              <listitem>
                <para role="param">env:Sender - ter:InvalidArgVal - ter:OldCertPathValidationPolicyID </para>
                <para role="text">No certification path validation policy under the given OldCertPathValidationPolicyID is associated with the TLS server.</para>
                <para role="param">env:Sender - ter:InvalidArgVal - ter:NewCertPathValidationPolicyID </para>
                <para role="text">No certification path validation policy under the given NewCertPathValidationPolicyID is stored in the device’s keystore.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>access class</term>
              <listitem>
                <para role="access">WRITE_SYSTEM</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>GetAssignedCertPathValidationPolicies</title>
          <para>This operation returns the IDs of all certification path validation policies that are assigned to the TLS server on the device.</para>
          <variablelist role="op">
            <varlistentry>
              <term>request</term>
              <listitem>
                <para role="text">This message is empty.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>response</term>
              <listitem>
                <para role="param">CertPathValidationPolicyID - optional, unbounded [tas:CertPathValidationPolicyID] </para>
                <para role="text">List of certification path validation policy IDs assigned to the TLS server.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>faults</term>
              <listitem>
                <para role="text">None</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>access class</term>
              <listitem>
                <para role="access">READ_SYSTEM_SECRET</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>SetEnabledTLSVersions</title>
          <para>This operation sets the version(s) of TLS which the device shall use. Valid values are taken from the TLSServerSupported capability.</para>
          <para>A client initiates a TLS session by sending a ClientHello with the highest TLS version it supports. This suggests to the server that the client can accept any TLS version up to and including that version.</para>
          <para>The server then chooses the TLS version to use. This is generally the highest TLS version the server supports that is within the range of the client. For example, if a ClientHello indicates TLS version 1.1, the server can proceed with TLS 1.0 or TLS 1.1.</para>
          <para>In the event that an ONVIF installation wishes to disable certain version(s) of TLS, it may do so with this operation. For example, to disable TLS 1.0 on a device signaling support for TLS versions 1.0, 1.1, and 1.2, the enabled version list may be set to "1.1 1.2", omitting 1.0. If a client then attempts to connect with a ClientHello containing TLS 1.0, the server shall send a "protocol_version" alert message and close the connection. This handshake indicates to the client that TLS 1.0 is not supported by the server. The client must try again with a higher TLS version suggestion.</para>
          <para>An empty version list is not permitted. Disabling all versions of TLS is not the intent of this operation. See AddServerCertificateAssignment and RemoveServerCertificateAssignment.</para>
          <para>A device signalling support for TLS version enabling with the EnabledVersionsSupported capability shall support this command.</para>
          <variablelist role="op">
            <varlistentry>
              <term>request</term>
              <listitem>
                <para role="param">Versions - [tas:TLSVersions] </para>
                <para role="text">Space-delimited list of TLS versions to allow.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>response</term>
              <listitem>
                <para role="text">This is an empty message.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>faults</term>
              <listitem>
                <para role="param">env:Sender - ter:InvalidArgVal - ter:EmptyList </para>
                <para role="text">The version list is empty.</para>
                <para role="param">env:Sender - ter:InvalidArgVal - ter:TLSVersion </para>
                <para role="text">A version is not recognized.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>access class</term>
              <listitem>
                <para role="access">WRITE_SYSTEM</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section>
          <title>GetEnabledTLSVersions</title>
          <para>This operation retrieves the version(s) of TLS which are currently enabled on the device. A device signalling support for TLS version enabling with the EnabledVersionsSupported capability shall support this command.</para>
          <variablelist role="op">
            <varlistentry>
              <term>request</term>
              <listitem>
                <para role="text">This is an empty message.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>response</term>
              <listitem>
                <para role="param">Versions - [tas:TLSVersions] </para>
                <para role="text">Space-delimited list of enabled TLS versions.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>faults</term>
              <listitem>
                <para role="text">None</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>access class</term>
              <listitem>
                <para role="access">READ_SYSTEM</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
      </section>
    </section>
    <section>
      <title>IEEE 802.1X</title>
      <section>
        <title>AddDot1XConfiguration</title>
        <para>This operation adds an IEEE 802.1X configuration to the device.</para>
        <para>Configurations are uniquely identified using IEEE 802.1X configuration IDs. The device shall ignore Dot1XID in the request, if present, and shall generate a unique configuration ID for the added configuration.</para>
        <para>If the command was successful, the device shall return the ID of the configuration.</para>
        <para>If the device does not have capacity for the configuration, the device shall produce a MaximumNumberOfDot1XConfigurationsReached fault and shall not add the configuration.</para>
        <para>If Identity is used as an anonymous identity for the corresponding authentication method, the device shall ignore an eventually supplied passphrase ID in the same Dot1XStage. Otherwise, if the device cannot process a passphrase ID included in the configuration to be added, the device shall produce a PassphraseID fault and shall not add the configuration.</para>
        <para>If the device cannot process a certification path ID included in the configuration to be added, the device shall produce a CertificationPathID fault and shall not add the configuration.</para>
        <para>If the device cannot process an authentication method included in the configuration to be added (e.g., unrecognized method or missing configuration parameter), the device shall produce a Dot1XMethod fault and shall not add the configuration.</para>
        <para>If the device cannot process the authentication method combination in the configuration to be added, the device shall produce a Dot1XMethodCombination fault and shall not add the configuration.</para>
        <para>A device signalling support for IEEE 802.1X configuration with the MaximumNumberOfDot1XConfigurations capability shall support this command.</para>
        <variablelist role="op">
          <varlistentry>
            <term>request</term>
            <listitem>
              <para role="param">Dot1XConfiguration - [tas:Dot1XConfiguration] </para>
              <para role="text">The desired 802.1X configuration.</para>
              <para role="param">Alias - optional [xs:string] </para>
              <para role="text">The client-defined alias of the 802.1X configuration.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>response</term>
            <listitem>
              <para role="param">Dot1XID - [tas:Dot1XID] </para>
              <para role="text">The unique identifier of the created 802.1X configuration.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>faults</term>
            <listitem>
              <para role="param">env:Receiver - ter:Action - ter:MaximumNumberOfDot1XConfigurationsReached </para>
              <para role="text">The device already has the number of configurations specified by MaximumNumberOfDot1XConfigurations.</para>
              <para role="param">env:Sender - ter:InvalidArgVal - ter:PassphraseID </para>
              <para role="text">A supplied passphrase ID cannot be processed by the device.</para>
              <para role="param">env:Sender - ter:InvalidArgVal - ter:CertificationPathID </para>
              <para role="text">A supplied certification path ID cannot be processed by the device.</para>
              <para role="param">env:Sender - ter:InvalidArgVal - ter:Dot1XMethod </para>
              <para role="text">A supplied IEEE 802.1X authentication method cannot be processed by the device.</para>
              <para role="param">env:Sender - ter:InvalidArgVal - ter:Dot1XMethodCombination </para>
              <para role="text">The combination of IEEE 802.1X authentication methods cannot be processed by the device.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>access class</term>
            <listitem>
              <para role="access">WRITE_SYSTEM</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section>
        <title>GetAllDot1XConfigurations</title>
        <para>This operation returns details of all IEEE 802.1X configurations that are on the device.  This operation may be used, e.g., if a client lost track of which IEEE 802.1X configurations are present on the device.</para>
        <para>If no IEEE 802.1X configurations exist on the device, an empty list is returned.</para>
        <para>A device signalling support for IEEE 802.1X configuration with the MaximumNumberOfDot1XConfigurations capability shall support this command.</para>
        <variablelist role="op">
          <varlistentry>
            <term>request</term>
            <listitem>
              <para role="text">This is an empty message.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>response</term>
            <listitem>
              <para role="param">Configuration - optional, unbounded [tas:Dot1XConfiguration] </para>
              <para role="text">The list of 802.1X configurations on the device.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>faults</term>
            <listitem>
              <para role="text">None</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>access class</term>
            <listitem>
              <para role="access">READ_SYSTEM_SECRET</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section>
        <title>GetDot1XConfiguration</title>
        <para>This operation returns details of a specific IEEE 802.1X configuration on the device.</para>
        <para>If the device cannot process the provided IEEE 802.1X configuration ID, the device shall produce a Dot1XConfigurationID fault.</para>
        <para>A device signalling support for IEEE 802.1X configuration with the MaximumNumberOfDot1XConfigurations capability shall support this command.</para>
        <variablelist role="op">
          <varlistentry>
            <term>request</term>
            <listitem>
              <para role="param">Dot1XID - [tas:Dot1XID] </para>
              <para role="text">The unique identifier of the desired 802.1X configuration.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>response</term>
            <listitem>
              <para role="param">Dot1XConfiguration - [tas:Dot1XConfiguration] </para>
              <para role="text">The 802.1X configuration, without password information.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>faults</term>
            <listitem>
              <para role="param">env:Sender - ter:InvalidArgVal - ter:Dot1XConfigurationID </para>
              <para role="text">The supplied IEEE 802.1X configuration ID cannot be processed by the device.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>access class</term>
            <listitem>
              <para role="access">READ_SYSTEM_SECRET</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section>
        <title>DeleteDot1XConfiguration</title>
        <para>This operation deletes an IEEE 802.1X configuration from the device.</para>
        <para>If the device cannot process the provided IEEE 802.1X configuration ID, the device shall produce a Dot1XConfigurationID fault.</para>
        <para>If a reference exists for the specified IEEE 802.1X configuration, the device shall produce a ReferenceExists fault and shall not delete the configuration.</para>
        <para>After an IEEE 802.1X configuration has been successfully deleted, the device may assign its former ID to a new configuration.</para>
        <para>A device signalling support for IEEE 802.1X configuration with the MaximumNumberOfDot1XConfigurations capability shall support this command.</para>
        <variablelist role="op">
          <varlistentry>
            <term>request</term>
            <listitem>
              <para role="param">Dot1XID - [tas:Dot1XID] </para>
              <para role="text">The unique identifier of the 802.1X configuration to be deleted.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>response</term>
            <listitem>
              <para role="text">This is an empty message.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>faults</term>
            <listitem>
              <para role="param">env:Sender - ter:InvalidArgVal - ter:Dot1XConfigurationID </para>
              <para role="text">The supplied IEEE 802.1X configuration ID cannot be processed by the device.</para>
              <para role="param">env:Sender - ter:InvalidArgVal - ter:ReferenceExists </para>
              <para role="text">A network interface reference exists for the specified IEEE 802.1X configuration.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>access class</term>
            <listitem>
              <para role="access">UNRECOVERABLE</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section>
        <title>SetNetworkInterfaceDot1XConfiguration</title>
        <para>This operation binds an IEEE 802.1X configuration to a network interface on the device.  This operation shall either create a new binding or replace an existing binding.  On failure when an existing binding already exists, the existing binding shall remain.</para>
        <para>The Device Management SetNetworkInterface operation provides a method of binding an IEEE 802.1X configuration to an IEEE 802.11 (wireless) interface, and that operation may still be used.  But there is no ability for SetNetworkInterface to bind an IEEE 802.1X configuration to a hardwired interface.  This operation is provided to bind an IEEE 802.1X configuration to either type of interface.</para>
        <para>If SetNetworkInterfaceDot1XConfiguration is used to bind an IEEE 802.1X configuration to an IEEE 802.11 (wireless) interface, then the DeviceManagement GetNetworkInterfaces operation shall return the IEEE 802.1X configuration ID along with the rest of that interface’s configuration information.</para>
        <para>If the device cannot process the provided network interface token, the device shall produce an InvalidNetworkInterface fault.</para>
        <para>If the device cannot process the provided IEEE 802.1X configuration ID, the device shall produce a Dot1XConfigurationID fault.</para>
        <para>A device signalling support for IEEE 802.1X configuration with the MaximumNumberOfDot1XConfigurations capability shall support this command.</para>
        <variablelist role="op">
          <varlistentry>
            <term>request</term>
            <listitem>
              <para role="param">token - [xs:string] </para>
              <para role="text">The unique identifier of the Network Interface on which the 802.1X configuration is to be set. (NOTE: the network interface token is defined in devicemgmt.wsdl as tt:ReferenceToken, which is a derived type of xs:string.  To avoid importing all of common.xsd for this single type, the base type is used here.)</para>
              <para role="param">Dot1XID - [tas:Dot1XID] </para>
              <para role="text">The unique identifier of the 802.1X configuration to be set.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>response</term>
            <listitem>
              <para role="param">RebootNeeded - [xs:boolean] </para>
              <para role="text">Indicates whether or not a reboot is required after configuration updates.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>faults</term>
            <listitem>
              <para role="param">env:Sender - ter:InvalidArgVal - ter:InvalidNetworkInterface </para>
              <para role="text">The supplied network interface token does not exist.</para>
              <para role="param">env:Sender - ter:InvalidArgVal - ter:Dot1XConfigurationID </para>
              <para role="text">The supplied IEEE 802.1X configuration ID cannot be processed by the device.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>access class</term>
            <listitem>
              <para role="access">WRITE_SYSTEM</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section>
        <title>GetNetworkInterfaceDot1XConfiguration</title>
        <para>This operation returns the IEEE 802.1X ID and configuration associated with a network interface on the device.  If there is no IEEE 802.1X configuration associated with the specified network interface, then the response shall be empty.</para>
        <para>If the Device Management SetNetworkInterface operation was used to bind an IEEE 802.1X configuration to an IEEE 802.11 (wireless) interface, then this operation shall return the IEEE 802.1X configuration information as if the SetNetworkInterfaceDot1XConfiguration operation had been used.</para>
        <para>If the device cannot process the provided network interface token, the device shall produce an InvalidNetworkInterface fault.</para>
        <para>A device signalling support for IEEE 802.1X configuration with the MaximumNumberOfDot1XConfigurations capability shall support this command.</para>
        <variablelist role="op">
          <varlistentry>
            <term>request</term>
            <listitem>
              <para role="param">token - [xs:string] </para>
              <para role="text">The unique identifier of the Network Interface for which the 802.1X configuration is to be retrieved. (NOTE: the network interface token is defined in devicemgmt.wsdl as tt:ReferenceToken, which is a derived type of xs:string.  To avoid importing all of common.xsd for this single type, the base type is used here.)</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>response</term>
            <listitem>
              <para role="param">Dot1XID - optional [tas:Dot1XID] </para>
              <para role="text">The unique identifier of 802.1X configuration assigned to the Network Interface.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>faults</term>
            <listitem>
              <para role="param">env:Sender - ter:InvalidArgVal - ter:InvalidNetworkInterface </para>
              <para role="text">The supplied network interface token does not exist.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>access class</term>
            <listitem>
              <para role="access">READ_SYSTEM_SECRET</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section>
        <title>DeleteNetworkInterfaceDot1XConfiguration</title>
        <para>This operation unbinds the IEEE 802.1X configuration associated with a network interface on the device.  If there is no IEEE 802.1X configuration associated with the specified network interface, then the operation does nothing.</para>
        <para>The Device Management SetNetworkInterface operation provides a method of unbinding an IEEE 802.1X configuration from an IEEE 802.11 (wireless) interface by omitting the configuration ID, and that operation may still be used.  But there is no ability for SetNetworkInterface to unbind an IEEE 802.1X configuration from a hardwired interface.  This operation is provided to unbind an IEEE 802.1X configuration from either type of interface.</para>
        <para>If the Device Management SetNetworkInterface operation was used to bind an IEEE 802.1X configuration to an IEEE 802.11 (wireless) interface, then this operation shall unbind the IEEE 802.1X configuration information as if the SetNetworkInterfaceDot1XConfiguration operation had been used.</para>
        <para>If the device cannot process the provided network interface token, the device shall produce an InvalidNetworkInterface fault.</para>
        <para>A device signalling support for IEEE 802.1X configuration with the MaximumNumberOfDot1XConfigurations capability shall support this command.</para>
        <variablelist role="op">
          <varlistentry>
            <term>request</term>
            <listitem>
              <para role="param">token - [xs:string] </para>
              <para role="text">The unique identifier of the Network Interface for which the 802.1X configuration is to be deleted.  (NOTE: the network interface token is defined in devicemgmt.wsdl as tt:ReferenceToken, which is a derived type of xs:string.  To avoid importing all of common.xsd for this single type, the base type is used here.)</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>response</term>
            <listitem>
              <para role="param">RebootNeeded - [xs:boolean] </para>
              <para role="text">Indicates whether or not a reboot is required after configuration updates.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>faults</term>
            <listitem>
              <para role="param">env:Sender - ter:InvalidArgVal - ter:InvalidNetworkInterface </para>
              <para role="text">The supplied network interface token does not exist.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>access class</term>
            <listitem>
              <para role="access">WRITE_SYSTEM</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
    </section>
    <section xml:id="section_hd2_5r4_rwb">
      <title>Autorization Server Configuration</title>
      <para>This chapter describes configuration of external authorization servers. For an overview of this see <xref xmlns:xlink="http://www.w3.org/1999/xlink" linkend="section_b4m_rs4_rwb"/>.</para>
      <section xml:id="section_c22_5r4_rwb">
        <title>GetAuthorizationServerConfigurations</title>
        <para>This operation retrieves an existing authorization server configuration, or all
          existing authorization server configurations if Token is not specified. The device shall
          support this command if MaxConfigurations capability is greater than zero.</para>
        <variablelist role="op">
          <varlistentry>
            <term>request</term>
            <listitem>
              <para role="param">Token - optional [tt:ReferenceToken]</para>
              <para role="text">Optional configuration token to get.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>response</term>
            <listitem>
              <para role="param">Configuration - optional, unbounded [tas:AuthorizationServerConfiguration]</para>
              <para role="text">List of authorization server configurations.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>faults</term>
            <listitem>
              <para role="param">env:Sender - ter:InvalidArgVal - ter:NoConfig</para>
              <para role="text">The requested configuration does not exist.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>access class</term>
            <listitem>
              <para role="access">READ_SYSTEM_SECRET</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section xml:id="section_d22_5r4_rwb">
        <title>CreateAuthorizationServerConfiguration</title>
        <para>This operation creates a new authorization server configuration. The configuration
          data shall be created in the device and shall be persistent (remain after reboot). The
          device shall support this command if MaxConfigurations capability is greater than
          zero.</para>
        <variablelist role="op">
          <varlistentry>
            <term>request</term>
            <listitem>
              <para role="param">Configuration - [tas:AuthorizationServerConfigurationData]</para>
              <para role="text">Details of the configuration that shall be created.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>response</term>
            <listitem>
              <para role="param">Token - [tt:ReferenceToken]</para>
              <para role="text">Token assigned to the newly configuration.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>faults</term>
            <listitem>
              <para role="param">env:Receiver - ter:Action - ter:MaxAuthorizationServers</para>
              <para role="text">The maximum number of configurations supported by the device has been reached.</para>
              <para role="param">env:Sender - ter:InvalidArgVal - ter:InvalidConfig</para>
              <para role="text">The configuration parameters are not possible to set.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>access class</term>
            <listitem>
              <para role="access">WRITE_SYSTEM</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section xml:id="section_e22_5r4_rwb">
        <title>SetAuthorizationServerConfiguration</title>
        <para>This operation modifies an existing authorization server configuration. The device
          shall support this command if MaxConfigurations capability is greater than zero.</para>
        <variablelist role="op">
          <varlistentry>
            <term>request</term>
            <listitem>
              <para role="param">Configuration - [tas:AuthorizationServerConfiguration]</para>
              <para role="text">The modified authorization server configuration.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>response</term>
            <listitem>
              <para role="text">This is an empty message</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>faults</term>
            <listitem>
              <para role="param">env:Sender - ter:InvalidArgVal - ter:NoConfig</para>
              <para role="text">The requested configuration does not exist.</para>
              <para role="param">env:Sender - ter:InvalidArgVal - ter:InvalidConfig</para>
              <para role="text">The configuration parameters are not possible to set.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>access class</term>
            <listitem>
              <para role="access">WRITE_SYSTEM</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section xml:id="section_f22_5r4_rwb">
        <title>DeleteAuthorizationServerConfiguration</title>
        <para>This operation deletes the given authorization server configuration and configuration
          change shall always be persistent. The device shall support this command if
          MaxConfigurations capability is greater than zero.</para>
        <variablelist role="op">
          <varlistentry>
            <term>request</term>
            <listitem>
              <para role="param">Token - [tt:ReferenceToken]</para>
              <para role="text">Token of the configuration to delete.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>response</term>
            <listitem>
              <para role="text">This is an empty message</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>faults</term>
            <listitem>
              <para role="param">env:Sender - ter:InvalidArgVal - ter:NoConfig</para>
              <para role="text">The requested configuration does not exist.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>access class</term>
            <listitem>
              <para role="access">WRITE_SYSTEM</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
    </section>
    <section>
      <title>JWT-based authentication</title>
      <para>The following functions are defined to control the set of accepted <emphasis>aud</emphasis> claims. See also <xref linkend="_Ref395181339"/>.</para>
      <section>
        <title>GetJWTConfiguration</title>
        <para>This operation returns the parameters of the JWT authorization used by the device. A
          device shall support this command if the capability JsonWebToken in the device service capabilities is set.</para>
        <variablelist role="op">
          <varlistentry>
            <term>request</term>
            <listitem>
              <para role="text">This is an empty message.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>response</term>
            <listitem>
              <para role="param">Configuration - [tas:JWTConfiguration]</para>
              <para role="text">The configuration parameters for JWT authorization used by the
                device.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>faults</term>
            <listitem>
              <para role="text">None</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>access class</term>
            <listitem>
              <para role="access">READ_SYSTEM_SECRET</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section>
        <title>SetJWTConfiguration</title>
        <para>This operation sets the parameters of the JWT authorization used by the device. A
          device shall support this command if the capability JsonWebToken in the device service capabilities is set.</para>
        <para>JWT client authorization of the device is enabled when at least one key or trusted issuer URI is provided.</para>
        <variablelist role="op">
          <varlistentry>
            <term>request</term>
            <listitem>
              <para role="param">Configuration - [tas:JWTConfiguration]</para>
              <para role="text">The configuration parameters for JWT authorization used by the
                device.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>response</term>
            <listitem>
              <para role="text">This is an empty message.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>faults</term>
            <listitem>
              <para role="param">env:Sender - ter:InvalidArgVal - ter:TooManyAudiences</para>
              <para role="text">The list of audiences is too big to be saved.</para>
              <para role="param">ter:Sender - ter:InvalidArgVal - ter:KeyID</para>
              <para role="text">No key is stored under the requested KeyID.</para>
              <para role="param">ter:Sender - ter:InvalidArgVal - ter:MaxIssuersExceeded</para>
              <para role="text">Too many trusted issuers provided.</para>
              <para role="param">env:Sender - ter:InvalidArgVal - ter:CertPathValidationPolicyID </para>
              <para role="text">No certification path validation policy is stored under the requested certification path validation policy ID.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>access class</term>
            <listitem>
              <para role="access">WRITE_SYSTEM_SECRET</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>A device shall support assignment of as many keys as its key store can hold. A device shall support at least two trusted issuers.</para>
      </section>
    </section>
    <section>
      <title>Capabilities</title>
      <section>
        <title>GetServiceCapabilities</title>
        <para>The capabilities reflect optional functions and functionality of the different features in the security configuration service. The service capabilities consist of keystore capabilities and TLS server capabilities. The information is static and does not change during device operation.</para>
        <para>A device shall support this command.</para>
        <variablelist role="op">
          <varlistentry>
            <term>request</term>
            <listitem>
              <para role="text">This is an empty message.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>response</term>
            <listitem>
              <para role="param">Capabilities - [tas:Capabilities] </para>
              <para role="text">The capabilities for the security configuration service.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>faults</term>
            <listitem>
              <para role="text">None</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>access class</term>
            <listitem>
              <para role="access">PRE_AUTH</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section>
        <title>Keystore Capabilities</title>
        <para>The keystore capabilities reflect optional functions and functionality of the keystore on a device. The following capabilities are available: </para>
        <table>
          <title>Keystore Capabilities</title>
          <tgroup cols="2">
            <colspec colname="c1" colwidth="59*"/>
            <colspec colname="c2" colwidth="41*"/>
            <thead>
              <row>
                <entry>
                  <para>
                    <emphasis role="bold">Capability Name</emphasis>
                  </para>
                </entry>
                <entry>
                  <para>
                    <emphasis role="bold">Capability Semantics</emphasis>
                  </para>
                </entry>
              </row>
            </thead>
            <tbody valign="top">
              <row>
                <entry>
                  <para>MaximumNumberOfPassphrases</para>
                </entry>
                <entry>
                  <para>Indicates the maximum number of passphrases that the device is able to store simultaneously.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfKeys</para>
                </entry>
                <entry>
                  <para>Indicates the maximum number of keys that the device is able store simultaneously.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfCertificates</para>
                </entry>
                <entry>
                  <para>Indicates the maximum number of certificates that the device is able to store simultaneously.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfCertificationPaths</para>
                </entry>
                <entry>
                  <para>Indicates the maximum number of certificate paths that the device is able to store simultaneously.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>RSAKeyPairGeneration</para>
                </entry>
                <entry>
                  <para>Indicates support for on-board RSA key pair generation.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>ECCKeyPairGeneration</para>
                </entry>
                <entry>
                  <para>Indicates support for on-board ECC key pair generation.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>RSAKeyLengths</para>
                </entry>
                <entry>
                  <para>Indicates which RSA key lengths are supported by the device.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>EllipticCurves</para>
                </entry>
                <entry>
                  <para>Indicates which elliptic curves are supported by the device.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>PKCS8RSAKeyPairUpload</para>
                </entry>
                <entry>
                  <para>Indicates support for uploading an RSA key pair in a PKCS#8 data structure.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>PKCS8</para>
                </entry>
                <entry>
                  <para>Indicates support for uploading supported key pair in a PKCS#8 data structure.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>PKCS12CertificateWithRSAPrivateKeyUpload</para>
                </entry>
                <entry>
                  <para>Indicates support for uploading a certificate along with an RSA private key in a PKCS#12 data structure.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>PKCS12</para>
                </entry>
                <entry>
                  <para>Indicates support for uploading a certificate along with a private key in a PKCS#12 data structure.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>PKCS10ExternalCertificationWithRSA</para>
                </entry>
                <entry>
                  <para>Indicates support for creating PKCS#10 requests for RSA keys and uploading the certificate obtained from a CA.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>PKCS10</para>
                </entry>
                <entry>
                  <para>Indicates support for creating PKCS#10 requests for asymetric key pair and uploading the certificate obtained from a CA.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SelfSignedCertificateCreationWithRSA</para>
                </entry>
                <entry>
                  <para>Indicates support for creating self-signed certificates for RSA keys.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SelfSignedCertificateCreation</para>
                </entry>
                <entry>
                  <para>Indicates support for creating self-signed certificates.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SignatureAlgorithms</para>
                </entry>
                <entry>
                  <para>Indicates which signature algorithms are supported by the device.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>PasswordBasedEncryptionAlgorithms</para>
                </entry>
                <entry>
                  <para>Indicates which password-based encryption algorithms are supported by the device.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>PasswordBasedMACAlgorithms</para>
                </entry>
                <entry>
                  <para>Indicates which password-based MAC algorithms are supported by the device.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>X.509Versions</para>
                </entry>
                <entry>
                  <para>Indicates which X.509 versions are supported by the device.<footnote xml:id="__FN2__"><para>If a device supports X.509v3 certificates, this fact shall also be signalled by this capability.</para></footnote> X.509 versions shall be encoded as version numbers, e.g., 1, 2, 3.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfCRLs</para>
                </entry>
                <entry>
                  <para>Indicates the maximum number of CRLs that the device is able to store simultaneously.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfCertificationPathValidationPolicies</para>
                </entry>
                <entry>
                  <para>Indicates the maximum number of certification path validation policies that the device is able to store simultaneously.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>EnforceTLSWebClientAuthExtKeyUsage</para>
                </entry>
                <entry>
                  <para>Indicates whether a device supports checking for the TLS WWW client auth extended key usage extension while validating certification paths.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>NoPrivateKeySharing</para>
                </entry>
                <entry>
                  <para>Indicates the device requires that each certificate with private key has its own unique key.</para>
                </entry>
              </row>
              <row>
                <entry><para>SetCertPath</para></entry>
                <entry><para>The device supports modification of certificate path and certificate
                  validation path.</para></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>TLS Server Capabilities</title>
        <para>The TLS server capabilities reflect optional functions and functionality of the TLS server. The information is static and does not change during device operation. The following capabilities are available: </para>
        <table>
          <title>TLS Server Capabilities</title>
          <tgroup cols="2">
            <colspec colname="c1" colwidth="63*"/>
            <colspec colname="c2" colwidth="37*"/>
            <tbody valign="top">
              <row>
                <entry>
                  <para>TLSServerSupported</para>
                </entry>
                <entry>
                  <para>Indicates which TLS server versions are supported by the device. Server versions shall be encoded as version numbers, e.g., “1.0 1.1 1.2”.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfTLSCertificationPaths</para>
                </entry>
                <entry>
                  <para>Indicates the maximum number of certification paths that may be assigned to the TLS server simultaneously.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>TLSClientAuthSupported</para>
                </entry>
                <entry>
                  <para>Indicates whether the device supports TLS client authentication as defined in this specification.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>CnMapsToUserSupported</para>
                </entry>
                <entry>
                  <para>Indicates whether the device supports TLS client authorization using common name to local user mapping as defined in this specification</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfTLSCertificationPathValidationPolicies</para>
                </entry>
                <entry>
                  <para>Indicates the maximum number of certification path validation policies that may be assigned to the TLS server simultaneously</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>EnabledVersionsSupported</para>
                </entry>
                <entry>
                  <para>Indicates whether the device supports enabling and disabling specific TLS versions.</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>IEEE 802.1X Capabilities</title>
        <para>The IEEE 802.1X configuration capabilities reflect optional functions and functionality of IEEE 802.1X configuration on a device. The following additional capabilites are defined: </para>
        <table>
          <title>Additional IEEE 802.1X Configuration Capabilities</title>
          <tgroup cols="2">
            <colspec colname="c1" colwidth="50*"/>
            <colspec colname="c2" colwidth="50*"/>
            <thead>
              <row>
                <entry>
                  <para>Capability Name</para>
                </entry>
                <entry>
                  <para>Capability Semantics</para>
                </entry>
              </row>
            </thead>
            <tbody valign="top">
              <row>
                <entry>
                  <para>MaximumNumberOfDot1XConfigurations</para>
                </entry>
                <entry>
                  <para>Indicates the maximum number of IEEE 802.1X configurations that the device is able to configure simultaneously.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Dot1XMethods</para>
                </entry>
                <entry>
                  <para>A list of authentication method outer/inner (phase1/phase2) combinations supported by the device.</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>Authorization Server Capabilities</title>
        <para>The authorization server capabilities reflect optional functionality regarding
          configuration of external authorization servers. The following capabilities are
          defined:</para>
        <table>
          <title>Authorization Server Configuration Capabilities</title>
          <tgroup cols="2">
            <colspec colname="c1" colwidth="50*"/>
            <colspec colname="c2" colwidth="50*"/>
            <thead>
              <row>
                <entry>
                  <para>Capability Name</para>
                </entry>
                <entry>
                  <para>Capability Semantics</para>
                </entry>
              </row>
            </thead>
            <tbody valign="top">
              <row>
                <entry>
                  <para>MaxConfigurations</para>
                </entry>
                <entry>
                  <para>Indicates the maximum number of  authorization server configurations that
                    the device is able to configure simultaneously.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>ConfigurationTypesSupported</para>
                </entry>
                <entry>
                  <para>A list of authorization server configuration types that is supported by the
                    device, see <xref xmlns:xlink="http://www.w3.org/1999/xlink" linkend="table_ry3_fbr_swb"/> for possible values.</para>
                </entry>
              </row>
              <row>
                <entry>ClientAuthenticationMethodsSupported</entry>
                <entry>A list of authentication methods that is supported by the device, see <xref xmlns:xlink="http://www.w3.org/1999/xlink" linkend="table_smg_rzq_swb"/> for possible values.
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>Capability-implied Requirements</title>
        <para>
          <xref linkend="_Ref406569780"/> summarizes for each capability the minimum requirements that a device signaling this capability shall satisfy; it should not be seen as a recommendation.</para>
        <table xml:id="_Ref406569780">
          <title>Requirements implied by Capabilities</title>
          <tgroup cols="2">
            <colspec colname="c1" colwidth="32*"/>
            <colspec colname="c2" colwidth="68*"/>
            <thead>
              <row>
                <entry>
                  <para>Capability</para>
                </entry>
                <entry>
                  <para>Implied Requirements</para>
                </entry>
              </row>
            </thead>
            <tbody valign="top">
              <row>
                <entry>
                  <para>MaximumNumberOfPassphrases</para>
                </entry>
                <entry>
                  <para>If greater than zero, the following commands shall be supported:</para>
                  <itemizedlist>
                    <listitem>
                      <para>UploadPassphrase</para>
                    </listitem>
                    <listitem>
                      <para>GetAllPassphrases</para>
                    </listitem>
                    <listitem>
                      <para>DeletePassphrase</para>
                    </listitem>
                  </itemizedlist>
                  <para>If greater than zero, the device shall support passphrases that consist of characters from the ASCII character set and that have a length of up to 40 characters.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfKeys</para>
                </entry>
                <entry>
                  <para>If greater than zero, then the following commands shall be supported:</para>
                  <itemizedlist>
                    <listitem>
                      <para>GetKeyStatus</para>
                    </listitem>
                    <listitem>
                      <para>GetAllKeys</para>
                    </listitem>
                    <listitem>
                      <para>DeleteKey</para>
                    </listitem>
                  </itemizedlist>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfCertificates</para>
                </entry>
                <entry>
                  <para>If greater than zero, then MaximumNumberOfKeys&gt;0 shall hold.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfCertificationPaths</para>
                </entry>
                <entry>
                  <para>If greater than zero, MaximumNumberOfCertificates&gt;=2 shall hold.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>RSAKeyPairGeneration</para>
                </entry>
                <entry>
                  <para>If true, the following commands shall be supported:</para>
                  <itemizedlist>
                    <listitem>
                      <para>CreateRSAKeyPair</para>
                    </listitem>
                  </itemizedlist>
                  <para>If true, the list of supported RSA key lengths as indicated by the RSAKeyLenghts capability shall not be empty.</para>
                  <para>If true, MaximumNumberOfKeys&gt;0 shall hold.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>ECCKeyPairGeneration</para>
                </entry>
                <entry>
                  <para>If true, the following commands shall be supported:</para>
                  <itemizedlist>
                    <listitem>
                      <para>CreateECCKeyPair</para>
                    </listitem>
                  </itemizedlist>
                  <para>If true, the list of supported elliptic curves indicated by the EllipticCurves capability shall not be empty.</para>
                  <para>If true, MaximumNumberOfKeys&gt;0 shall hold.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>PKCS8</para>
                </entry>
                <entry>
                  <para>If true, the following commands shall be supported:</para>
                  <itemizedlist>
                    <listitem>
                      <para>UploadKeyPairInPKCS8</para>
                    </listitem>
                  </itemizedlist>
                  <para>If true, MaximumNumberOfKeys &gt; 0 shall hold.</para>
                  <para>If true, the list of supported password-based encryption algorithms as
                    indicated by the PasswordBasedEncryptionAlgorithms capability shall contain at
                    least the algorithm <phrase>pbeWithSHAAnd3-KeyTripleDES-CBC</phrase>.</para>
                  <para>If true, at least one capability between EllipticCurves and RSAKeyLenghts shall be specified.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>PKCS8RSAKeyPairUpload</para>
                </entry>
                <entry>
                  <para>If true, the conditions of  PKCS8 shall be supported:</para>
                  <para>If true, the list of supported RSA key lengths as indicated by the RSAKeyLenghts capability shall not be empty.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>PKCS12</para>
                </entry>
                <entry>
                  <para>If true, the following commands shall be supported:</para>
                  <itemizedlist>
                    <listitem>
                      <para>UploadCertificateWithPrivateKeyInPKCS12</para>
                    </listitem>
                    <listitem>
                      <para>GetCertificate</para>
                    </listitem>
                    <listitem>
                      <para>GetAllCertificates</para>
                    </listitem>
                    <listitem>
                      <para>DeleteCertificate</para>
                    </listitem>
                    <listitem>
                      <para>GetCertificationPath</para>
                    </listitem>
                    <listitem>
                      <para>GetAllCertificationPaths</para>
                    </listitem>
                    <listitem>
                      <para>DeleteCertificationPath</para>
                    </listitem>
                  </itemizedlist>
                  <para>If true, MaximumNumberOfKeys &gt;=2 shall hold.</para>
                  <para>If true, MaximumNumberOfCertificates &gt;=2 shall hold.</para>
                  <para>If true, MaximumNumberOfCertificattionPaths &gt;0 shall hold.</para>
                  <para>If true, the list of supported password-based encryption algorithms as indicated by the PasswordBasedEncryptionAlgorithms capability shall contain at least the algorithm <phrase>pbeWithSHAAnd3-KeyTripleDES-CBC</phrase>.</para>
                  <para>If true, the list of supported password-based MAC algorithms as indicated by the PasswordBasedMACAlgorithms capability shall contain at least the algorithm <phrase>hmacWithSHA256</phrase>.</para>
                  <para>If true, the list of supported X.509 versions as indicated by the X.509Versions capability shall contain at least the value 3.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>PKCS12CertificateWithRSAPrivateKeyUpload</para>
                </entry>
                <entry>
                  <para>If true, the conditions of capability PKCS12 shall be fulfilled.</para>
                  <para>If true, the list of supported RSA key lengths as indicated by the RSAKeyLenghts capability shall not be empty.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>PKCS10</para>
                </entry>
                <entry>
                  <para>If true, the following operations shall be supported:</para>
                  <itemizedlist>
                    <listitem>
                      <para>Creating a CSR with the CreatePKCS10CSR command.</para>
                    </listitem>
                    <listitem>
                      <para>GetCertificate</para>
                    </listitem>
                    <listitem>
                      <para>GetAllCertificates</para>
                    </listitem>
                    <listitem>
                      <para>DeleteCertificate</para>
                    </listitem>
                    <listitem>
                      <para>Uploading the certificate created for the CSR as well as the certificate of the created certificate’s signer with the UploadCertificate command.</para>
                    </listitem>
                  </itemizedlist>
                  <para>If true, MaximumNumberOfCertificates&gt;=2 and MaximumNumberOfCertificationPaths&gt;0 shall hold.</para>
                  <para>If true, MaximumNumberOfKeys&gt;=2 shall hold.</para>
                  <para>If true and the capability RSAKeyLenghts is not empty the following condition shall be fulfilled:</para>
                  <itemizedlist>
                    <listitem>
                      <para>The capability RSAKeyPairGeneration shall be specified .</para>
                    </listitem>
                  </itemizedlist>
                  <para>If true and the capability EllipticCurves is provided, the following conditions shall be fulfilled:</para>
                  <itemizedlist>
                    <listitem>
                      <para>The capability ECCKeyPairGeneration shall be specified.</para>
                    </listitem>
                    <listitem>
                      <para>The list of supported signature algorithms as indicated by the SignatureAlgorithms capability shall contain at least the algorithms ECDSA-With-SHA1 and ECDSA-With-SHA256.</para>
                    </listitem>
                  </itemizedlist>
                  
                </entry>
              </row>
              <row>
                <entry><para>PKCS10ExternalCertificationWithRSA</para></entry>
                <entry>
                  <para>If true, the conditions of capability PKCS10 shall be fulfilled.</para>
                  <para>If true, the list of supported RSA key lengths as indicated by the RSAKeyLenghts capability shall not be empty.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SelfSignedCertificateCreation</para>
                </entry>
                <entry>
                  <para>If true, the following commands shall be supported:</para>
                  <itemizedlist>
                    <listitem>
                      <para>CreateSelfSignedCertificate</para>
                    </listitem>
                    <listitem>
                      <para>GetCertificate</para>
                    </listitem>
                    <listitem>
                      <para>GetAllCertificates</para>
                    </listitem>
                    <listitem>
                      <para>DeleteCertificate</para>
                    </listitem>
                  </itemizedlist>
                  <para>If true, MaximumNumberOfCertificates&gt; 0 shall hold.</para>
                  <para>If true, the following operations shall be supported:</para>
                  <itemizedlist>
                    <listitem>
                      <para>Key pair generation as signaled by the RSAKeyPairGeneration or ECCKeyPairGeneration capability or key pair upload as signaled by the PKCS8 capability or key pair upload as signaled by the PKCS12CertificateWithRSAPrivateKeyUpload capability</para>
                    </listitem>
                  </itemizedlist>
                  <para>If true and the capability RSAKeyLenghts is not empty the following conditions shall be fulfilled:</para>
                  <itemizedlist>
                    <listitem>
                      <para>The capability RSAKeyPairGeneration shall be specified .</para>
                    </listitem>
                    <listitem>
                      <para>The list of supported signature algorithms as indicated by the SignatureAlgorithms capability shall contain at least the algorithms sha1-WithRSAEncryption and sha256WithRSAEncryption.</para>
                    </listitem>
                  </itemizedlist>
                  <para>If true and the capability EllipticCurves is provided, the following condition shall be fulfilled:</para>
                  <itemizedlist>
                    <listitem>
                      <para>The capability ECCKeyPairGeneration shall be specified.</para>
                    </listitem>
                  </itemizedlist>
                </entry>
              </row>
              <row>
                <entry>
                  <para>SelfSignedCertificateCreationWithRSA</para>
                </entry>
                <entry>
                  <para>If true, the conditions of the SelfSignedCertificateCreation capability shall be supported.</para>
                  <para>If true, the list of supported RSA key lengths as indicated by the RSAKeyLenghts capability shall not be empty.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>TLSServerSupported</para>
                </entry>
                <entry>
                  <para>If not empty, PKCS10ExternalCertificationWithRSA or SelfSignedCertificateCreationWithRSA or PKCS10 or SelfSignedCertificateCreation shall be true.</para>
                  <para>If not empty, the following commands shall be supported:</para>
                  <itemizedlist>
                    <listitem>
                      <para>CreateCertificationPath</para>
                    </listitem>
                    <listitem>
                      <para>GetCertificationPath</para>
                    </listitem>
                    <listitem>
                      <para>GetAllCertificationPaths</para>
                    </listitem>
                    <listitem>
                      <para>DeleteCertificationPath</para>
                    </listitem>
                    <listitem>
                      <para>AddServerCertificateAssignment</para>
                    </listitem>
                    <listitem>
                      <para>RemoveServerCertificateAssignment</para>
                    </listitem>
                    <listitem>
                      <para>ReplaceServerCertificateAssignment</para>
                    </listitem>
                    <listitem>
                      <para>GetAssignedServerCertificates</para>
                    </listitem>
                  </itemizedlist>
                  <para>If not empty, MaximumNumberOfCertificationPaths&gt;=2 and MaximumNumberOfTLSCertificationPaths&gt;0 shall hold.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>TLSServerSupported and PKCS10ExternalCertificationWithRSA</para>
                </entry>
                <entry>
                  <para>If TLSServerSupported is non-empty and PKCS10ExternalCertificationWithRSA is true, MaximumNumberOfCertificates&gt;=3 shall hold.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>TLSServerSupported and PKCS10</para>
                </entry>
                <entry>
                  <para>If TLSServerSupported is non-empty and PKCS10 is true, MaximumNumberOfCertificates&gt;=3 shall hold.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfTLSCertificationPaths</para>
                </entry>
                <entry>
                  <para>If greater than zero, MaximumNumberOfCertificationPaths&gt;0 shall hold.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>EnabledVersionsSupported</para>
                </entry>
                <entry>
                  <para>If true, the following commands are supported:</para>
                  <itemizedlist>
                    <listitem>
                      <para>SetEnabledTLSVersions</para>
                    </listitem>
                    <listitem>
                      <para>GetEnabledTLSVersions</para>
                    </listitem>
                  </itemizedlist>
                </entry>
              </row>
              <row>
                <entry>
                  <para>X.509Versions</para>
                </entry>
                <entry>
                  <para>
                    <phrase>If X.509v3 is supported, the device shall support the distinguished name attribute types </phrase>
                    <emphasis>country</emphasis>, <emphasis>organization</emphasis>, <emphasis>organizational unit</emphasis>, <emphasis>distinguished name qualifier</emphasis>, <emphasis>state or province name</emphasis>, <emphasis>common name</emphasis>, and <emphasis>serial number</emphasis>.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfCRLs</para>
                </entry>
                <entry>
                  <para>If greater than zero, then the following commands shall be supported</para>
                  <itemizedlist>
                    <listitem>
                      <para>UploadCRL</para>
                    </listitem>
                    <listitem>
                      <para>GetCRL</para>
                    </listitem>
                    <listitem>
                      <para>GetAllCRLs</para>
                    </listitem>
                    <listitem>
                      <para>DeleteCRL</para>
                    </listitem>
                  </itemizedlist>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfCertificationPathValidationPolicies</para>
                </entry>
                <entry>
                  <para>If greater than zero, then the following command shall be supported</para>
                  <itemizedlist>
                    <listitem>
                      <para>CreateCertPathValidationPolicy</para>
                    </listitem>
                    <listitem>
                      <para>GetCertPathValidationPolicy</para>
                    </listitem>
                    <listitem>
                      <para>GetAllCertPathValidationPolicies</para>
                    </listitem>
                    <listitem>
                      <para>DeleteCertPathValidationPolicy</para>
                    </listitem>
                  </itemizedlist>
                  <para>If greater than zero, PKCS12CertificateWithRSAPrivateKeyUpload, PKCS10ExternalCertificationWithRSA or SelfSignedCertificateCreationWithRSA or PKCS12 or PKCS10 or SelfSignedCertificateCreation shall be true.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>TLSClientAuthSupported</para>
                </entry>
                <entry>
                  <para>If true, the following commands shall be supported</para>
                  <itemizedlist>
                    <listitem>
                      <para>SetClientAuthenticationRequired</para>
                    </listitem>
                    <listitem>
                      <para>GetClientAuthenticationRequired</para>
                    </listitem>
                    <listitem>
                      <para>AddCertPathValidationPolicyAssignment</para>
                    </listitem>
                    <listitem>
                      <para>RemoveCertPathValidationPolicyAssignment</para>
                    </listitem>
                    <listitem>
                      <para>ReplaceCertPathValidationPolicyAssignment</para>
                    </listitem>
                    <listitem>
                      <para>GetAssignedCertPathValidationPolicies</para>
                    </listitem>
                  </itemizedlist>
                  <para>If true, TLSServerSupported shall not be empty.</para>
                  <para>If true, MaximumNumberOfCertificationPathValidationPolicies&gt;=2 and MaximumNumberOfTLSCertificationPathValidationPolicies&gt;0 shall hold.</para>
                  <para>If true, the device shall support</para>
                  <itemizedlist>
                    <listitem>
                      <para>validating certification paths containing X.509v3 certificates that are signed with signatures of type sha1-WithRSAEncryption or sha256WithRSAEncrpytion</para>
                    </listitem>
                    <listitem>
                      <para>processing X.509 CRLs that are compliant to the CRL profile defined in RFC 5280, Sect. 5 and that</para>
                      <itemizedlist>
                        <listitem>
                          <para>are signed with signatures of type sha1-WithRSAEncryption or, sha256WithRSAEncryption and</para>
                        </listitem>
                        <listitem>
                          <para>are complete direct CRLs as defined in RFC 5280 that are signed with the same signature key as the signature key that the CA uses to sign issued certificates</para>
                        </listitem>
                      </itemizedlist>
                    </listitem>
                  </itemizedlist>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfTLSCertificationPathValidationPolicies</para>
                </entry>
                <entry>
                  <para>If greater than zero, MaximumNumberOfCertificationPathValidationPolicies &gt;0 shall hold.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>MaximumNumberOfDot1XConfigurations</para>
                </entry>
                <entry>
                  <para>If greater than zero, the following commands shall be supported:</para>
                  <itemizedlist>
                    <listitem>
                      <para>AddDot1XConfiguration</para>
                    </listitem>
                    <listitem>
                      <para>GetDot1XConfigurations</para>
                    </listitem>
                    <listitem>
                      <para>GetDot1XConfiguration</para>
                    </listitem>
                    <listitem>
                      <para>DeleteDot1XConfiguration</para>
                    </listitem>
                    <listitem>
                      <para>SetNetworkInterfaceDot1XConfiguration</para>
                    </listitem>
                    <listitem>
                      <para>GetNetworkInterfaceDot1XConfiguration</para>
                    </listitem>
                    <listitem>
                      <para>DeleteNetworkInterfaceDot1XConfiguration</para>
                    </listitem>
                  </itemizedlist>
                  <para>If greater than zero, the Dot1XMethods capability shall be present and shall contain at least the EAP-PEAP MSCHAPv2 method.</para>
                </entry>
              </row>
              <row>
                <entry>
                  <para>Dot1XMethods</para>
                </entry>
                <entry>
                  <para>If not empty, shall contain at least the “EAP-PEAP/MSCHAPv2” method, and MaximumNumberOfDot1XConfigurations shall be greater than zero.</para>
                </entry>
              </row>
              <row>
                <entry>EllipticCurves</entry>
                <entry>The list of supported elliptic curves.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
    </section>
    <section>
      <title>Events</title>
      <section xml:id="_Ref353780603">
        <title>Key Status</title>
        <para>A device that indicates support for key handling via the MaximumNumberOfKeys capability shall provide information about key status changes through key status events.</para>
        <para>A device shall include optional item OldStatus unless NewStatus is generating.</para>
        <programlisting><![CDATA[Topic: tns1:Advancedsecurity/Keystore/KeyStatus
<tt:MessageDescription>
  <tt:Source>
    <tt:SimpleItemDescription Name="KeyID" Type="tas:KeyID"/>
  </tt:Source>
  <tt:Data>
    <tt:SimpleItemDescription Name="OldStatus" Type="tas:KeyStatus"/>
    <tt:SimpleItemDescription Name="NewStatus" Type="tas:KeyStatus"/>
  </tt:Data>
</tt:MessageDescription>
]]></programlisting>
      </section>
    </section>
    <section>
      <title>Service specific data types</title>
      <para>The service specific data types are defined in security.wsdl.</para>
    </section>
  </chapter>
  <chapter>
    <title>Security Considerations</title>
    <para>This section is informative.</para>
    <itemizedlist>
      <listitem>
        <para>Faults and their types shall not disclose sensitive information to an attacker that he could not obtain otherwise.</para>
      </listitem>
      <listitem>
        <para>Secure up to date signature algorithm should be implemented by devices and clients.
          Devices signal the supported algorithm via their capabilities and clients should select
          the algorithm with highest security strength supported by both parties. As common baseline
          this specification requires device side support for SHA-2, particularly
          sha256WithRSAEncryption as specified in RFC 4055. Note that for backward compatibility of
          some usages this specification currently mandates device side support for
          sha1WithRSAEncryption as specified in RFC 3279. </para>
      </listitem>
      <listitem>
        <para>Operations with arguments that need protection against eavesdropping or manipulation shall only be executed over sufficiently protected communication channels. </para>
      </listitem>
      <listitem>
        <para>It is good practice not to use the same key for different purposes. In order to prevent the device from using the same key for different purposes unnoticedly, this specification mandates that all keys in the keystore be distinct.</para>
      </listitem>
      <listitem>
        <para>Private keys must be protected against disclosure to unauthorized parties. If a private key is uploaded in an encrypted PKCS#8 or PKCS#12 structure, the passphrase that is used to encrypt the structure must be uploaded to the device over a communication channel that is protected against eavesdropping in order to preserve the confidentiality of the private key. Moreover, the confidentiality of the uploaded private key depends on the strength of the encryption passphrase. It is therefore strongly recommended to use random passwords with sufficient length.</para>
      </listitem>
      <listitem>
        <para>In general, externally generated keys must be regarded less trustworthy than keys that are generated by the device because the probability of being disclosed to an attacker is higher for an externally generated key than for an internally generated key. A client may determine whether a key was generated by the device from the <emphasis>externallyGenerated</emphasis> attribute of the key.</para>
      </listitem>
      <listitem>
        <para>While new specifications should be based on PKCS#5 v2.0 or higher, adoption of this standard is still limited. Therefore, this specification intends to balance security and interoperability by mandating cryptographic algorithms based on PKCS#5 v1.5 as interoperability baseline while strongly encouraging the use of PKCS#5 v2.0 or higher. Future versions of this specification or specifications referring to this specification may mandate additional cryptographic algorithms.</para>
      </listitem>
      <listitem>
        <para>Although PKCS#8 RFC 5208 is widely used for exchanging cryptographic keys, this specification is based on the successor standard RFC 5958, particularly in order to incorporate both private key and public key in the same data structure.</para>
      </listitem>
      <listitem>
        <para>The default certification path validation policy is designed as a permissive interoperability baseline based on the certification path validation algorithm defined in RFC 5280. </para>
      </listitem>
      <listitem>
        <para>CRLs can be expected to be available from virtually any CA as a source of revocation information. The benefit of OCSP RFC 6960 as a means to obtain revocation information is increasingly under question, since a man-in-the-middle attacker blocking OCSP traffic combined with a permissive validator that silently accepts certificates for which no revocation is available limits the effective security gain of using OCSP. Therefore, this specification mandates support for CRLs as interoperability baseline and leaves other revocation information sources to future versions.</para>
      </listitem>
      <listitem>
        <para>Devices may be required to use different trust anchors for different security features. Therefore, trust in a certificate is indicated as part of a certification path validation policy rather than globally, e.g., with an attribute of the X509Certificate data type. </para>
      </listitem>
      <listitem>
        <para>RFC 5280, Sect. 6.1.4 (k) mandates that every certificate in a certification path except for the end entity certificate must be verified to be a CA certificate. For X.509 version 3 certificates, this is verified through the CA attribute in the basic constraints extension. For X.509 version 1 and 2 certificates, this information must be supplied by out-of-band mechanisms. Within the scope of this specification, the only means to obtain this information is the trust anchor information contained in the certification path validation algorithm. </para>
      </listitem>
      <listitem>
        <para>When configuring IEEE 802.1X, it is usually necessary to upload a password to the device’s keystore.  This should be done either on a private network (e.g., using a direct network connection between a laptop and a device) or using TLS (SSL) on the device to encrypt client / device traffic.</para>
      </listitem>
    </itemizedlist>
  </chapter>
  <chapter>
    <title>Design Rationale</title>
    <para>This section is informative.</para>
    <section>
      <title>General Design Goals</title>
      <para>The Security Configuration Service is designed for modularity and extensibility. Therefore, each security feature is encapsulated in a separate port type within the service. Later revisions of this specification may add port types to enhance the Security Configuration Service by additional security features.</para>
      <para>Within a security feature, capabilities indicate support for sub-features and configuration options. Later revisions of this specification may add additional sub-features to existing features and identify them by additional capabilities.</para>
      <para>Port types and capabilities enable devices to support well-defined subsets of this specification and to communicate this information to clients effectively.</para>
    </section>
    <section>
      <title>Keystore</title>
      <para>The keystore design assumes that passphrases are chosen by clients. Therefore, an operation for retrieving passphrases from a device is deliberately omitted. If client loses a previously uploaded passphrase, the client should create a new passphrase, upload the new passphrase to the device, and delete the old passphrase from the device.</para>
      <para>This specification deliberately deviates from the terminology in PKCS#8 and PKCS#12 by using the term ‘passphrase’ instead of ‘password’ in order to avoid confusion with the password that is assigned to ONVIF device users and the corresponding API in the ONVIF Device Management Service.</para>
      <para>The keystore design is based on the rationale that an RSA key pair is a special type of key pair and a key pair is a special type of key. Therefore, key-related operations in the keystore deliberately refer to the most generic possible type in this hierarchy. For example, the DeleteKey operation (see Sect. <xref linkend="_Ref363540841"/>) refers to a key instead of a key pair or even an RSAKeyPair because it is applicable to all keys. On the other hand, the GetPrivateKeyStatus command refers to a key pair instead of a key, since this command is not meaningful for a key that is not a key pair, e.g., a symmetric key.</para>
      <para>While this revision of the keystore specification only supports RSA key pairs as key pairs, later revisions of this specification may add other types of key pairs or symmetric keys as special types of keys.</para>
      <para>Some interactions with the keystore, e.g., retrieving the private key for a public key that is contained in a certificate, are required device-internally, but need not be accessible to clients and may even, as in the above example, imply a security risk when made available outside the device. Such operations are therefore deliberately omitted from this specification.</para>
      <para>The certificate-based client authentication specification intends to balance security concerns, interoperability, and implementation effort in order to facilitate adoption. Therefore, the certification path validation algorithm defined in RFC 5280 serves as interoperability baseline. The parameter values in the default certification path validation policy have been selected such that widely used implementations of the certification path validation algorithm can be used in their default configurations as much as permitted by the objective to provide an acceptable security baseline.</para>
      <para>At the same time, more fine grained customization of the default certification path validation behavior in future versions of this specification is enabled by an extensible CertValidationPolicyParameters data type and capabilities that indicate which configuration options a device supports. As an example, checking for the TLS WWW client authentication key usage extension in client certificates is included in this specification, which can be implemented with moderate effort on the device side (e.g., with the OpenSSL option –purpose sslclient). Customization options for other parameters of the certification path validation algorithm are deliberately left to future versions of this specification in order to limit the required initial implementation effort.</para>
      <para>In order to facilitate future extensions of this specification, the number of certification path validation policies that may be assigned to the TLS server simultaneously is not limited, but the certification path validation behavior is unspecified if more than one policy is assigned to the TLS server at the same time. Therefore, devices implementing this specification should limit the number of simultaneously assigned policies to one.</para>
    </section>
    <section>
      <title>TLS Server</title>
      <para>This revision of the Security Configuration Service Specification allows to manage assignments of certification paths to the TLS server on a device. It is permitted that a TLS server presents different certification paths to different clients, therefore more than one certification path may be assigned simultaneously to the TLS server to use as a server certificate.</para>
      <para>All other configuration of the TLS server on a device is outside the scope of this specification revision and may be addressed by later revisions of this document.</para>
    </section>
  </chapter>
  <appendix xml:id= "q5l_q5m_51c">
    <title>JWT Content example</title>
    <para>Here is an example of JWT components to be encoded into a JWT Token</para>
    <programlisting><![CDATA[{
    "typ":"JWT",
    "alg":"ES256",
}.{
    "iss":"server.path.com", // FQDN of the server that issued the JWT
    "nbf":1670482800, // not before Thursday, December 8, 2022 7:00:00 AM (GMT)
    "exp":1670572800, // expire at Friday, December 9, 2022 8:00:00 AM (GMT)
    "aud":"target.audience",
    "roles":["onvif:Operator"]
}
]]></programlisting>
    <para>which is base64url-encoded in three parts according to RFC 7519 as</para>
    <programlisting>eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NiJ9.eyJpc3MiOiJzZXJ2ZXIucGF0aC5jb20iLCJuYmYiOjE2NzA0ODI4MDAsImV
4cCI6MTY3MDU3MjgwMCwiYXVkIjoidGFyZ2V0LmF1ZGllbmNlIiwicm9sZXMiOlsib252aWY6T3BlcmF0b3IiXX0.SflKxw
RJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</programlisting>
  </appendix>
  <appendix xml:id="_Ref460769599">
    <title>JWT over SCTP example</title>
    <para>A JWT, whose content example is shown in <xref xmlns:xlink="http://www.w3.org/1999/xlink"
        linkend="q5l_q5m_51c"/>, can be used in the WS-Security header of the SOAP request. To conform
        to the BinarySecurityToken format, the JWT itself must be base64-encoded before being embedded
        in the request:</para>
    <programlisting><![CDATA[ZZXlKMGVYQWlPaUpLVjFRaUxDSmhiR2NpT2lKRlV6STFOaUo5LmV5SnBjM01pT2lKelpYSjJaWEl1Y0dGMGFDNW
piMjBpTENKdVltWWlPakUyTnpBME9ESTRNREFzSW1WNGNDSTZNVFkzTURVM01qZ3dNQ3dpWVhWa0lqb2lkR0Z5
WjJWMExtRjFaR2xsYm1ObElpd2ljbTlzWlhNaU9sc2liMjUyYVdZNlQzQmxjbUYwYjNJaVhYMC5TZmxLeHdSSl
NNZUtLRjJRVDRmd3BNZUpmMzZQT2s2eUpWX2FkUXNzdzVj]]></programlisting>
    <para>This encoded token can then be added to the SOAP request in a BinarySecurityToken element.</para>
    <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<env:Envelope xmlns:env="http://www.w3.org/2003/05/soap-envelope"
              xmlns:enc="http://www.w3.org/2003/05/soap-encoding"
              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
              xmlns:xsd="http://www.w3.org/2001/XMLSchema"
              xmlns:xop="http://www.w3.org/2004/08/xop/include"
              xmlns:tds="http://www.onvif.org/ver10/device/wsdl"
              xmlns:tt="http://www.onvif.org/ver10/schema">
  <env:Header>
    <wsse:Security>
      <wsse:BinarySecurityToken ValueType="urn:ietf:params:oauth:token-type:jwt"
EncodingType=”http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-sec
urity-1.0#BinarySecurityToken”>
ZXlKMGVYQWlPaUpLVjFRaUxDSmhiR2NpT2lKRlV6STFOaUo5LmV5SnBjM01pT2lKelpYSjJaWEl1Y0dGMGFDNW
piMjBpTENKdVltWWlPakUyTnpBME9ESTRNREFzSW1WNGNDSTZNVFkzTURVM01qZ3dNQ3dpWVhWa0lqb2lkR0Z5
WjJWMExtRjFaR2xsYm1ObElpd2ljbTlzWlhNaU9sc2liMjUyYVdZNlQzQmxjbUYwYjNJaVhYMD0uU2ZsS3h3Uk
pTTWVLS0YyUVQ0ZndwTWVKZjM2UE9rNnlKVl9hZFFzc3c1Yw==
      </wsse:BinarySecurityToken>
    </wsse:Security>
  </env:Header>
  <env:Body>
    <tds:GetDeviceInformation/>
  <env:Body>
</env:Envelope>]]></programlisting>
  </appendix>
  <appendix xml:id= "hq4_s5m_51c">
    <title>JWT over HTTPS example</title>
    <para>The following exchange between client and device over HTTPS demonstrates a device supporting MD5 and SHA-256 for digest authentication as well as JWT-based client authentication.</para>
    <para>Unauthenticated request from the client:</para>
    <programlisting><![CDATA[POST /onvif/device_service HTTP/1.1
Host: 10.XX.XX.XX
Content-Type: application/soap+xml; charset=utf-8
Content-Length: 299

<?xml version="1.0" encoding="utf-8"?>
<s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope">
<s:Body xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<GetDeviceInformation xmlns="http://www.onvif.org/ver10/device/wsdl"/>
</s:Body></s:Envelope>]]></programlisting>
    <para>Response from the device challenging for authentication</para>
    <programlisting><![CDATA[HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer realm="Silvan_http_digest"
WWW-Authenticate: Digest algorithm=MD5, realm="Silvan_http_digest", qop="auth",
nonce="62d82aa9ca59e3a04cd1", opaque="5b6ea228"
WWW-Authenticate: Digest algorithm=SHA-256, realm="Silvan_http_digest", qop="auth",
nonce="62d82aa9ca59e3a04cd1", opaque="5b6ea228"
X-Frame-Options: SAMEORIGIN]]></programlisting>
    <para>Authenticated request from the client, by using JWT-based client authentication whose JWT
      content looks like the example is shown in <xref xmlns:xlink="http://www.w3.org/1999/xlink"
        linkend="q5l_q5m_51c"/></para>
    <programlisting><![CDATA[POST /onvif/device_service HTTP/1.1
Host: 10.XX.XX.XX
Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NiJ9.eyJpc3MiOiJzZXJ2ZXIucGF0aC5
jb20iLCJuYmYiOjE2NzA0ODI4MDAsImV4cCI6MTY3MDU3MjgwMCwiYXVkIjoidGFyZ2V0LmF1ZGllbmNlIiwic
m9sZXMiOlsib252aWY6T3BlcmF0b3IiXX0.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
Content-Type: application/soap+xml; charset=utf-8
Content-Length: 299

<?xml version="1.0" encoding="utf-8"?>
<s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope">
<s:Body xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<GetDeviceInformation xmlns="http://www.onvif.org/ver10/device/wsdl"/>
</s:Body></s:Envelope>]]></programlisting>
    <para>Response from the device, rejecting the expired token</para>
    <programlisting><![CDATA[HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer realm="Silvan_http_digest", error="invalid_token",
error_description="The access token expired"
WWW-Authenticate: Digest algorithm=MD5, realm="Silvan_http_digest", qop="auth",
nonce="62d82aa9ca59e3a04cd1", opaque="5b6ea228"
WWW-Authenticate: Digest algorithm=SHA-256, realm="Silvan_http_digest", qop="auth",
nonce="62d82aa9ca59e3a04cd1", opaque="5b6ea228"
X-Frame-Options: SAMEORIGIN]]></programlisting>
  </appendix>
  <appendix xml:id= "b14_55m_51c">
    <title>JWT over RTSPS example</title>
    <para>The following exchange between client and device over RTSPS demonstrates a device supporting MD5 and SHA-256 for digest authentication as well as JWT-based client authentication.</para>
    <para>Unauthenticated request from the client:</para>
    <programlisting><![CDATA[DESCRIBE rtsp://10.XX.XX.XX/stream RTSP/1.0
CSeq: 1
User-Agent: ./onvifClient
Accept: application/sdp]]></programlisting>
    <para>Response from the device challenging for authentication</para>
    <programlisting><![CDATA[RTSP/1.0 401 Unauthorized
CSeq: 1
WWW-Authenticate: Bearer realm="Silvan_rtsp_digest"
WWW-Authenticate: Digest algorithm=MD5, realm="Silvan_rtsp_digest", qop="auth",
nonce="62d82aa9ca59e3a04cd1", opaque="5b6ea228"
WWW-Authenticate: Digest algorithm=SHA-256, realm="Silvan_rtsp_digest", qop="auth",
nonce="62d82aa9ca59e3a04cd1", opaque="5b6ea228"]]></programlisting>
    <para>Authenticated request from the client, by using JWT-based client authentication whose JWT
      content looks like the example is shown in <xref xmlns:xlink="http://www.w3.org/1999/xlink"
        linkend="q5l_q5m_51c"/></para>
    <programlisting><![CDATA[DESCRIBE rtsp://10.XX.XX.XX/stream RTSP/1.0
Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NiJ9.eyJpc3MiOiJzZXJ2ZXIucGF0aC5
jb20iLCJuYmYiOjE2NzA0ODI4MDAsImV4cCI6MTY3MDU3MjgwMCwiYXVkIjoidGFyZ2V0LmF1ZGllbmNlIiwic
m9sZXMiOlsib252aWY6T3BlcmF0b3IiXX0.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
CSeq: 2
User-Agent: ./onvifClient
Accept: application/sdp]]></programlisting>
  </appendix>
  <appendix role="revhistory">
    <title>Revision History</title>
    <para/>
  </appendix>
</book>
